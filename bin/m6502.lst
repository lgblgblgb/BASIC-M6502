ca65 V2.18 - Ubuntu 2.19-1
Main file   : m6502-converted.asm
Current file: m6502-converted.asm

000000r 1               ; TITLE	BASIC M6502 8K VER 1.1 BY MICRO-SOFT
000000r 1               ; SEARCH	M6502
000000r 1               ; SALL
000000r 1               ; RADIX 10			;THROUGHOUT ALL BUT MATH-PAK.
000000r 1               
000000r 1               ; (C)1976 MICRO-SOFT (the original source)
000000r 1               ; (C)2025 Gabor Lenart "LGB" - the conversion/modification/etc project of mine to port this to CA65 assembler
000000r 1               
000000r 1               .INCLUDE "macros.inc"
000000r 2               .MACRO	ORG	addr
000000r 2               	.ORG	addr
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	BLOCK	n
000000r 2               	.RES	n
000000r 2               .ENDMACRO
000000r 2               
000000r 2               
000000r 2               .DEFINE	ADR(W)	.WORD	W
000000r 2               
000000r 2               .MACRO	DT	txt
000000r 2               	.BYTE	txt
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	REPEAT	n,what
000000r 2               	.REPEAT	n
000000r 2               		what
000000r 2               	.ENDREPEAT
000000r 2               .ENDMACRO
000000r 2               
000000r 2               
000000r 2               ; Guessing: EXP emits a byte, however it was removed to EXPOP not to collide with EXP as a label ...
000000r 2               .MACRO	EXPOP	n
000000r 2               	.BYTE	n
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO  LDADY	addr
000000r 2               	LDA	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO  STADY	addr
000000r 2               	STA	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	SBCDY addr
000000r 2               	SBC	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	CMPDY	addr
000000r 2               	CMP	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	ADCDY	addr
000000r 2               	ADC	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	JMPD	addr
000000r 2               	JMP	(addr)
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ; ---- Only for the simulation target ---
000000r 2               
000000r 2               IO_START_ADDR = $D000
000000r 2               
000000r 2               .MACRO	SIM_INSIM
000000r 2               	JSR	LGB_INSIM
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	SIM_OUTSIM
000000r 2               	STA	IO_START_ADDR + 0
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO SIMULATION_TARGET_ROUTINES
000000r 2               ; Was missing from the source: CZGETL = SIM_CZGETL_ADDR if REALIO = 0 (simulation)
000000r 2               ; That was $FFE4 for COMMODORE target, meaning KERNAL routine "GET".
000000r 2               ; No idea about the difference from "INSIM" ...
000000r 2               ; However, this is a label, so a routine should be put somewhere, and RTS from it?
000000r 2               SIM_CZGETL_ADDR:
000000r 2               	LDA	$D000
000000r 2               	CLC
000000r 2               	RTS
000000r 2               
000000r 2               LGB_INSIM:
000000r 2               	LDA	$D000
000000r 2               	CMP	#0
000000r 2               	BEQ	LGB_INSIM
000000r 2               	CLC
000000r 2               	RTS
000000r 2               .ENDMACRO
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; $Z::				;STARTING POINT FOR M6502 SIMULATOR
000000r 1               	ORG	0		;START OFF AT LOCATION ZERO.
000000  1               ; SUBTTL	SWITCHES,MACROS.
000000  1               
000000  1               REALIO=0			;5=STM
000000  1               				;4=APPLE.
000000  1               				;3=COMMODORE.
000000  1               				;2=OSI
000000  1               				;1=MOS TECH,KIM
000000  1               				;0=PDP-10 SIMULATING 6502
000000  1               INTPRC .SET 1			;INTEGER ARRAYS.
000000  1               ADDPRC .SET 1			;FOR ADDITIONAL PRECISION.
000000  1               LNGERR .SET 0			;LONG ERROR MESSAGES.
000000  1               TIME .SET 	0			;CAPABILITY TO SET AND READ A CLK.
000000  1               EXTIO .SET  0			;EXTERNAL I/O.
000000  1               DISKO .SET  0			;SAVE AND LOAD COMMANDS
000000  1               NULCMD .SET 1			;FOR THE "NULL" COMMAND
000000  1               GETCMD .SET 1
000000  1               RORSW .SET 1
000000  1               ROMSW .SET 1			;TELLS IF THIS IS ON ROM.
000000  1               CLMWID .SET 14
000000  1               LONGI .SET 1			;LONG INITIALIZATION SWITCH.
000000  1               STKEND .SET 511
000000  1               BUFPAG .SET 0
000000  1               LINLEN .SET 72			;TERMINAL LINE LENGTH.
000000  1               BUFLEN .SET 72			;INPUT BUFFER SIZE.
000000  1               ROMLOC .SET  $2000			;ADDRESS OF START OF PURE SEGMENT.
000000  1               KIMROM .SET 1
000000  1               .IF	ROMSW = 0
000000  1               	KIMROM .SET 0
000000  1               .ENDIF
000000  1               .IF	REALIO-1 <> 0
000000  1               	KIMROM .SET 0
000000  1               .ENDIF
000000  1               .IF	ROMSW <> 0
000000  1               	RAMLOC .SET  $4000		;USED ONLY IF ROMSW=1
000000  1               .IF	REALIO = 0
000000  1               	ROMLOC .SET  $2000		;START AT 8K.
000000  1               	RAMLOC .SET $300
000000  1               .ENDIF
000000  1               .ENDIF
000000  1               .IF	REALIO-3 = 0
000000  1               	DISKO .SET 1
000000  1               	RAMLOC .SET $400
000000  1               	ROMLOC .SET $C000
000000  1               	NULCMD .SET 0
000000  1               	GETCMD .SET 1
000000  1               	linlen .SET 40
000000  1               	BUFLEN .SET 81
000000  1               	CQOPEN=$FFC0
000000  1               	CQCLOS=$FFC3
000000  1               	CQOIN= $FFC6		;OPEN CHANNEL FOR INPUT
000000  1               	CQOOUT=$FFC9		;FILL FOR COMMO.
000000  1               	CQCCHN=$FFCC
000000  1               	CQINCH=$FFCF		;INCHR'S CALL TO GET A CHARACTER
000000  1               	OUTCH= $FFD2
000000  1               	CQLOAD=$FFD5
000000  1               	CQSAVE=$FFD8
000000  1               	CQVERF=$FFDB
000000  1               	CQSYS= $FFDE
000000  1               	ISCNTC=$FFE1
000000  1               	CZGETL=$FFE4		;CALL POINT FOR "GET"
000000  1               	CQCALL=$FFE7		;CLOSE ALL CHANNELS
000000  1               	CQTIMR=$8D
000000  1               	BUFPAG .SET 2
000000  1               	BUF .SET 256*BUFPAG
000000  1               	STKEND .SET 507
000000  1               	CQSTAT=$96
000000  1               	CQHTIM=$E844
000000  1               	EXTIO .SET 1
000000  1               	TIME .SET 1
000000  1               	GETCMD .SET 1
000000  1               	CLMWID .SET 10
000000  1               	PI=255				;VALUE OF PI CHARACTER FOR COMMODORE.
000000  1               	ROMSW .SET 1
000000  1               	RORSW .SET 1
000000  1               	TRMPOS=$C6
000000  1               .ENDIF
000000  1               .IF	REALIO-1 = 0
000000  1               	GETCMD .SET 1
000000  1               	DISKO .SET 1
000000  1               	OUTCH=$1EA0			;1EA0
000000  1               	ROMLOC .SET $2000
000000  1               	RORSW .SET 0
000000  1               	CZGETL=$1E5A
000000  1               .ENDIF
000000  1               .IF	REALIO-2 = 0
000000  1               	RORSW .SET 0
000000  1               	RAMLOC .SET $200
000000  1               .IF	ROMSW <> 0
000000  1               	RORSW .SET 0
000000  1               	RAMLOC .SET $8000
000000  1               .ENDIF
000000  1               	OUTCH .SET $FE0B
000000  1               .ENDIF
000000  1               .IF	REALIO-4 = 0
000000  1               	RORSW .SET 1
000000  1               	NULCMD .SET 0
000000  1               	GETCMD .SET 1
000000  1               	CQINLN .SET $FD67
000000  1               	CQPRMP .SET $33
000000  1               	CQINCH .SET $FD0C
000000  1               	CQCOUT .SET $FECD
000000  1               	CQCSIN .SET $FEFD
000000  1               	BUFPAG .SET 2
000000  1               	BUF=BUFPAG*256
000000  1               	ROMLOC .SET $800
000000  1               	RAMLOC .SET $2A00			;PAGE 2A
000000  1               	OUTCH=$FDED
000000  1               	CZGETL=$FD0C
000000  1               	LINLEN .SET 40
000000  1               	BUFLEN .SET 240
000000  1               	RORSW .SET 1
000000  1               	STKEND .SET 507
000000  1               .ENDIF
000000  1               .IF	RORSW = 0
000000  1               .OUT	"LGB: Software ROR emulation is ignored."
000000  1               .MACRO	ROR_	WD	;LGB was ROR before on old CPUs do not have bug-free ROR. On modern assemblers, we cannot define a macro with an existing opcode name though.
000000  1               	LDA	#0
000000  1               	BCC	*+4
000000  1               	LDA	#$80
000000  1               	LSR	WD
000000  1               	ORA	WD
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .ENDIF
000000  1               .MACRO	ACRLF
000000  1               .BYTE	13
000000  1               .BYTE	10
000000  1               .ENDMACRO
000000  1               .MACRO	SYNCHK	Q
000000  1               	LDA	#Q
000000  1               	JSR	SYNCHR
000000  1               .ENDMACRO
000000  1               ; LGB: begin
000000  1               ;DEFINE	DT(Q),<
000000  1               ;IRPC	Q,<IFDIF <Q><">,<EXP "Q">>  >	;
000000  1               .IF	REALIO = 0
000000  1               	;CZGETL=^O177744
000000  1               	CZGETL	= SIM_CZGETL_ADDR
000000  1               .ENDIF
000000  1               ; LGB: end
000000  1               .MACRO	LDWD	WD
000000  1               	LDA	WD
000000  1               	LDY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDWDI	WD
000000  1               	LDA	#.LOBYTE(WD)
000000  1               	LDY	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	LDWX	WD
000000  1               	LDA	WD
000000  1               	LDX	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDWXI	WD
000000  1               	LDA	#.LOBYTE(WD)
000000  1               	LDX	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	LDXY	WD
000000  1               	LDX	WD
000000  1               	LDY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDXYI	WD
000000  1               	LDX	#.LOBYTE(WD)
000000  1               	LDY	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	STWD	WD
000000  1               	STA	WD
000000  1               	STY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	STWX	WD
000000  1               	STA	WD
000000  1               	STX	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	STXY	WD
000000  1               	STX	WD
000000  1               	STY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	CLR	WD
000000  1               	LDA	#0
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .MACRO	COM	WD
000000  1               	LDA	WD
000000  1               	EOR	#$FF
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .MACRO	PULWD	WD
000000  1               	PLA
000000  1               	STA	WD
000000  1               	PLA
000000  1               	STA	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	PSHWD	WD
000000  1               	LDA	WD+1
000000  1               	PHA
000000  1               	LDA	WD
000000  1               	PHA
000000  1               .ENDMACRO
000000  1               .MACRO	JEQ	WD
000000  1               	BNE	*+5
000000  1               	JMP	WD
000000  1               .ENDMACRO
000000  1               .MACRO	JNE	WD
000000  1               	BEQ	*+5
000000  1               	JMP	WD
000000  1               .ENDMACRO
000000  1               .DEFINE	BCCA	BCC			;BRANCHES THAT ALWAYS BRANCH
000000  1               .DEFINE	BCSA	BCS			;THESE ARE USED ON THE 6502 BECAUSE
000000  1               .DEFINE	BEQA	BEQ			;THERE IS NO UNCONDITIONAL BRANCH
000000  1               .DEFINE	BNEA	BNE
000000  1               .DEFINE	BMIA	BMI
000000  1               .DEFINE	BPLA	BPL
000000  1               .DEFINE	BVCA	BVC
000000  1               .DEFINE	BVSA	BVS
000000  1               .MACRO	INCW	R
000000  1               	INC	R
000000  1               	BNE	:+
000000  1               	INC	R+1
000000  1               	:
000000  1               .ENDMACRO
000000  1               .DEFINE	SKIP1	.BYTE $24		;BIT ZERO PAGE TRICK.
000000  1               .DEFINE	SKIP2	.BYTE $2C		;BIT ABS TRICK.
000000  1               .IF	REALIO = 0
000000  1               	.OUT	"SIMULATE"
000000  1               .ENDIF
000000  1               .IF	REALIO-1 = 0
000000  1               	.OUT	"KIM"
000000  1               .ENDIF
000000  1               .IF	REALIO-2 = 0
000000  1               	.OUT	"OSI"
000000  1               .ENDIF
000000  1               .IF	REALIO-3 = 0
000000  1               	.OUT	"COMMODORE"
000000  1               .ENDIF
000000  1               .IF	REALIO-4 = 0
000000  1               	.OUT	"APPLE"
000000  1               .ENDIF
000000  1               .IF	REALIO-5 = 0
000000  1               	.OUT	"STM"
000000  1               .ENDIF
000000  1               .IF	ADDPRC <> 0
000000  1               	.OUT	"ADDITIONAL PRECISION"
000000  1               .ENDIF
000000  1               .IF	INTPRC <> 0
000000  1               	.OUT	"INTEGER ARRAYS"
000000  1               .ENDIF
000000  1               .IF	LNGERR <> 0
000000  1               	.OUT	"LONG ERRORS"
000000  1               .ENDIF
000000  1               .IF	DISKO <> 0
000000  1               	.OUT	"SAVE AND LOAD"
000000  1               .ENDIF
000000  1               .IF	ROMSW = 0
000000  1               	.OUT	"RAM"
000000  1               .ENDIF
000000  1               .IF	ROMSW <> 0
000000  1               	.OUT	"ROM"
000000  1               .ENDIF
000000  1               .IF	RORSW = 0
000000  1               	.OUT	"NO ROR"
000000  1               .ENDIF
000000  1               .IF	RORSW <> 0
000000  1               	.OUT	"ROR ASSUMED"
000000  1               .ENDIF
000000  1               ; PAGE
000000  1               ; SUBTTL	INTRODUCTION AND COMPILATION PARAMETERS.
000000  1               
000000  1               ;
000000  1               ; --------- ---- -- ---------
000000  1               ; COPYRIGHT 1976 BY MICROSOFT
000000  1               ; --------- ---- -- ---------
000000  1               ; 7/27/78 FIXED BUG WHERE FOR VARIABLE AT BYTE FF MATCHED RETURN SEARCHING
000000  1               ; 	FOR GOSUB ENTRY ON STACK IN FNDFOR CALL BY CHANGING STA FORPNT
000000  1               ; 	TO STA FORPNT+1. THIS IS A SERIOUS BUG IN ALL VERSIONS.
000000  1               ; 7/27/78 FIXED BUG AT NEWSTT UNDER IFN BUFPAG WHEN CHECK OF CURLIN
000000  1               ; 	WAS DONE BEFORE CURLIN SET UP SO INPUT RETRIES OF FIRST STATEMENT
000000  1               ; 	WAS GIVING SYNTAX ERROR INSTEAD OF REDO FROM START (CODE WAS 12/1/77 FIX)
000000  1               ; 7/1/78	SAVED A FEW BYTES IN INIT FOR COMMODORE (14)
000000  1               ; 7/1/78 FIXED BUG WHERE REPLACING A LINE OVERFLOWING MEMORY LEFT LINKS
000000  1               ; 	IN A BAD STATE. (CODE AT NODEL AND FINI) BUG#4
000000  1               ; 7/1/78 FIXED BUG WHERE GARBAGE COLLECTION NEVER(!) COLLECTS TEMPS
000000  1               ; 	(STY GRBPNT  AT FNDVAR, LDA GRBPNT ORA GRBPNT+1 AT GRBPAS)
000000  1               ; 	THIS WAS COMMODORE BUG #2
000000  1               ; 7/1/78 FIXED BUG WHERE DELETE/INSERT OF LINE COULD CAUSE A GARBAGE COLLECTION WITH BAD VARTAB IF OUT OF MEMORY
000000  1               ; 	 (LDWD MEMSIZ STWD FRETOP=JSR RUNC CLC ALSO AT NODEL)
000000  1               ; 3/9/78 EDIT TO FIX COMMO TRMPOS AND CHANGE LEFT$ AND RIGHT$ TO ALLOW A SECOND ARGUMENT OF 0 AND RETURN A NULL STRING
000000  1               ; 2/25/78 FIXED BUG THAT INPFLG WAS SET WRONG WHEN BUFPAG.NE.0
000000  1               ; 	INCREASED NUMLEV FROM 19 TO 23
000000  1               ; 2/11/78 DISALLOWED SPACES IN RESERVED WORDS. PUT IN SPECIAL CHECK FOR "GO TO"
000000  1               ; 2/11/78 FIXED BUG WHERE ROUNDING OF THE FAC BEFORE PUSHING COULD CAUSE A STRING POINTER
000000  1               ; 	IN THE FAC TO BE INCREMENTED
000000  1               ; 1/24/78 fixed problem where user defined function undefined check fix was smashing error number in [x]
000000  1               ; 12/1/77 FIXED PROBLEM WHERE PEEK WAS SMASHING (POKER) CAUSING POKE OF PEEK TO FAIL
000000  1               ; 12/1/77 FIXED PROBLEM WHERE PROBLEM WITH VARTXT=LINNUM=BUF-2 CAUSING BUF-1 COMMA TO DISAPPEAR
000000  1               ; 12/1/77 FIXED BUFPAG.NE.0 PROBLEM AT NEWSTT AND STOP : CODE WAS STILL
000000  1               ; 	ASSUMING TXTPTR+1.EQ.0 IFF STATEMENT WAS DIRECT
000000  1               
000000  1               NUMLEV .SET 23			;NUMBER OF STACK LEVELS RESERVED
000000  1               				;BY AN EXPLICIT CALL TO "GETSTK".
000000  1               STRSIZ .SET 3			;# OF LOCS PER STRING DESCRIPTOR.
000000  1               NUMTMP .SET 3			;NUMBER OF STRING TEMPORARIES.
000000  1               CONTW .SET 15			;CHARACTER TO SUPPRESS OUTPUT.
000000  1               
000000  1               ; PAGE
000000  1               ; SUBTTL	SOME EXPLANATION.
000000  1               
000000  1               ;
000000  1               ; M6502 BASIC CONFIGURES BASIC AS FOLLOWS
000000  1               ;
000000  1               ; LOW LOCATIONS
000000  1               ; 	PAGE	ZERO
000000  1               ;
000000  1               ; 		STARTUP:
000000  1               ; 		INITIALLY A JMP TO INITIALIZATION CODE BUT
000000  1               ; 		CHANGED TO A JMP TO "READY".
000000  1               ; 		RESTARTING THE MACHINE AT LOC 0 DURING PROGRAM
000000  1               ; 		EXECUTION CAN LEAVE THINGS MESSED UP.
000000  1               ;
000000  1               ; 		LOC OF FAC TO INTEGER AND INTEGER TO FAC
000000  1               ; 		ROUTINES.
000000  1               ;
000000  1               ; 		"DIRECT" MEMORY:
000000  1               ; 		THESE ARE THE MOST COMMONLY USED LOCATIONS.
000000  1               ; 		THEY HOLD BOOKKEEPING INFO AND ALL OTHER
000000  1               ; 		FREQUENTLY USED INFORMATION.
000000  1               ; 		ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
000000  1               ; 		THE FLOATING ACCUMULATOR, AND ANYTHING ELSE THAT
000000  1               ; 		IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
000000  1               ; 		IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
000000  1               ; 		IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
000000  1               ; 		IS OFTEN DEPENDED UPON.
000000  1               ;
000000  1               ; 		STILL IN RAM WE HAVE THE BEGINNING OF THE "CHRGET"
000000  1               ; 		SUBROUTINE. IT IS HERE SO [TXTPTR] CAN BE THE
000000  1               ; 		EXTENDED ADDRESS OF A LOAD INSTRUCTION.
000000  1               ; 		THIS SAVES HAVING TO BOTHER ANY REGISTERS.
000000  1               ;
000000  1               ; 	PAGE	ONE
000000  1               ; 		THE STACK.
000000  1               ;
000000  1               ; 	STORAGE PAGE TWO AND ON
000000  1               ; 		IN RAM VERSIONS THESE DATA STRUCTURES COME AT THE
000000  1               ; 		END OF BASIC. IN ROM VERSON THEY ARE AT RAMLOC WHICH
000000  1               ; 		CAN EITHER BE ABOVE OR BELOW ROMLOC, WHICH IS WHERE
000000  1               ; 		BASIC ITSELF RESIDES.
000000  1               ;
000000  1               ; 				A ZERO.
000000  1               ; 		[TXTTAB]	POINTER TO NEXT LINE'S POINTER.
000000  1               ; 				LINE # OF THIS LINE (2 BYTES).
000000  1               ; 				CHARACTERS ON THIS LINE.
000000  1               ; 				ZERO.
000000  1               ; 				POINTER AT NEXT LINE'S POINTER
000000  1               ; 					(POINTED TO BY THE ABOVE POINTER).
000000  1               ; 				... REPEATS ...
000000  1               ; 		LAST LINE:	POINTER AT ZERO POINTER.
000000  1               ; 				LINE # OF THIS LINE.
000000  1               ; 				CHARACTERS ON THIS LINE.
000000  1               ; 				ZERO.
000000  1               ; 				DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER).
000000  1               ; 		[VARTAB]	SIMPLE VARIABLES. 6 BYTES PER VALUE.
000000  1               ; 				2 BYTES GIVE THE NAME, 4 BYTES THE VALUE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[ARYTAB]	ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
000000  1               ; 				LENGTH, NUMBER OF DIMENSIONS , EXTENT OF
000000  1               ; 				EACH DIMENSION (2BYTES/), VALUES
000000  1               ; 				... REPEATS ...
000000  1               ; 		[STREND]	FREE SPACE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[FRETOP]	STRING SPACE IN USE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[MEMSIZ]	HIGHEST MACHINE LOCATION.
000000  1               ; 				UNUSED EXCEPT BY THE VAL FUNCTION.
000000  1               ;
000000  1               ; 		ROM -- CONSTANTS AND CODE.
000000  1               ;
000000  1               ; 	FUNCTION DISPATCH ADDRESSES (AT ROMLOC)
000000  1               ; 		"FUNDSP" CONTAINS THE ADDRESSES OF THE
000000  1               ; 		FUNCTION ROUTINES IN THE ORDER OF THE
000000  1               ; 		FUNCTION NAMES IN THE CRUNCH LIST.
000000  1               ; 		THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
000000  1               ; 		ARE AT THE END. SEE THE EXPLANATION AT "ISFUN".
000000  1               ;
000000  1               ; 	THE OPERATOR LIST
000000  1               ; 		THE "OPTAB" LIST CONTAINS AN OPERATOR'S PRECEDENCE
000000  1               ; 		FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
000000  1               ; 		THE OPERATION. THE INDEX INTO THE
000000  1               ; 		OPERATOR LIST IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
000000  1               ; 		OF THE LOWEST NUMBERED OPERATOR. THE ORDER
000000  1               ; 		OF OPERATORS IN THE CRUNCH LIST AND IN "OPTAB" IS IDENTICAL.
000000  1               ; 		THE PRECEDENCES ARE ARBITRARY EXCEPT FOR THEIR
000000  1               ; 		COMPARATIVE SIZES. NOTE THAT THE PRECEDENCE FOR
000000  1               ; 		UNARY OPERATORS SUCH AS "NOT" AND NEGATION ARE
000000  1               ; 		SETUP SPECIALLY WITHOUT USING THE LIST.
000000  1               ;
000000  1               ; 	THE RESERVED WORD OR CRUNCH LIST
000000  1               ; 		WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
000000  1               ; 		IT IS STORED IN "BUF". AS SOON AS THE WHOLE LINE
000000  1               ; 		HAS BEEN TYPED IN ("INLIN" RETURNS) "CRUNCH" IS
000000  1               ; 		CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
000000  1               ; 		CRUNCHED VALUES. THIS REDUCES THE SIZE OF THE
000000  1               ; 		PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
000000  1               ; 		LIST DISPATCHES TO PERFORM FUNCTIONS, STATEMENTS,
000000  1               ; 		AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
000000  1               ; 		NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
000000  1               ; 		WHEN A MATCH IS FOUND BETWEEN A STRING
000000  1               ; 		OF CHARACTERS AND A WORD IN THE CRUNCH LIST
000000  1               ; 		THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
000000  1               ; 		THE INPUT LINE AND A RESERVED WORD TOKEN IS PUT
000000  1               ; 		IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
000000  1               ; 		TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
000000  1               ; 		IN THE CRUNCH LIST.
000000  1               ;
000000  1               ; 	STATEMENT DISPATCH ADDRESSES
000000  1               ; 		WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
000000  1               ; 		CHARACTER OF THE STATEMENT IS EXAMINED
000000  1               ; 		TO SEE IF IT IS LESS THAN THE RESERVED
000000  1               ; 		WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
000000  1               ; 		IF SO, THE "LET" CODE IS CALLED TO
000000  1               ; 		TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
000000  1               ; 		OTHERWISE A CHECK IS MADE TO MAKE SURE THE
000000  1               ; 		RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
000000  1               ; 		STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
000000  1               ; 		TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
000000  1               ; 		DISPATCH LIST) USING THE RESERVED WORD
000000  1               ; 		NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
000000  1               ; 		THE LIST.
000000  1               ;
000000  1               ; 	ERROR MESSAGES
000000  1               ; 		WHEN AN ERROR CONDITION IS DETECTED,
000000  1               ; 		[ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
000000  1               ; 		MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
000000  1               ; 		TO "ERROR". THE STACK WILL BE RESET AND ALL
000000  1               ; 		PROGRAM CONTEXT WILL BE LOST. VARIABLES
000000  1               ; 		VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
000000  1               ; 		ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
000000  1               ; 		THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
000000  1               ; 		INDEX INTO "ERRTAB" WHICH GIVES THE TWO
000000  1               ; 		CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
000000  1               ; 		USER'S TERMINAL.
000000  1               ;
000000  1               ;
000000  1               ; 	TEXTUAL MESSAGES
000000  1               ; 		CONSTANT MESSAGES ARE STORED HERE. UNLESS
000000  1               ; 		THE CODE TO CHECK IF A STRING MUST BE COPIED
000000  1               ; 		IS CHANGED THESE STRINGS MUST BE STORED ABOVE
000000  1               ; 		PAGE ZERO, OR ELSE THEY WILL BE COPIED BEFORE
000000  1               ; 		THEY ARE PRINTED.
000000  1               ;
000000  1               ; 	FNDFOR
000000  1               ; 		MOST SMALL ROUTINES ARE FAIRLY SIMPLE
000000  1               ; 		AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
000000  1               ; 		USED FOR FINDING "FOR" ENTRIES ON
000000  1               ; 		THE STACK. WHENEVER A "FOR" IS EXECUTED, A
000000  1               ; 		16-BYTE ENTRY IS PUSHED ONTO THE STACK.
000000  1               ; 		BEFORE THIS IS DONE, HOWEVER, A CHECK
000000  1               ; 		MUST BE MADE TO SEE IF THERE
000000  1               ; 		ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
000000  1               ; 		FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
000000  1               ; 		AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
000000  1               ; 		ARE ELIMINATED FROM THE STACK. THIS IS SO A
000000  1               ; 		PROGRAM THAT JUMPS OUT OF THE MIDDLE
000000  1               ; 		OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
000000  1               ; 		AND AGAIN WON'T USE UP 18 BYTES OF STACK
000000  1               ; 		SPACE EVERY TIME. THE "NEXT" CODE ALSO
000000  1               ; 		CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
000000  1               ; 		THE LOOP VARIABLE IN
000000  1               ; 		THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
000000  1               ; 		THE STACK IS RESET. IF NO MATCH IS FOUND A
000000  1               ; 		"NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
000000  1               ; 		ALSO PUTS A 5-BYTE ENTRY ON STACK.
000000  1               ; 		WHEN A RETURN IS EXECUTED "FNDFOR" IS
000000  1               ; 		CALLED WITH A VARIABLE POINTER THAT CAN'T
000000  1               ; 		BE MATCHED. WHEN "FNDFOR" HAS RUN
000000  1               ; 		THROUGH ALL THE "FOR" ENTRIES ON THE STACK
000000  1               ; 		IT RETURNS AND THE RETURN CODE MAKES
000000  1               ; 		SURE THE ENTRY THAT WAS STOPPED
000000  1               ; 		ON IS A GOSUB ENTRY. THIS ASSURES THAT
000000  1               ; 		IF YOU GOSUB TO A SECTION OF CODE
000000  1               ; 		IN WHICH A FOR LOOP IS ENTERED BUT NEVER
000000  1               ; 		EXITED THE RETURN WILL STILL BE
000000  1               ; 		ABLE TO FIND THE MOST RECENT
000000  1               ; 		GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
000000  1               ; 		"GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
000000  1               ; 		THE GOSUB ENTRY.
000000  1               ;
000000  1               ; 	NON-RUNTIME STUFF
000000  1               ; 		THE CODE TO INPUT A LINE, CRUNCH IT, GIVE ERRORS,
000000  1               ; 		FIND A SPECIFIC LINE IN THE PROGRAM,
000000  1               ; 		PERFORM A "NEW", "CLEAR", AND "LIST" ARE
000000  1               ; 		ALL IN THIS AREA. GIVEN THE EXPLANATION OF
000000  1               ; 		PROGRAM STORAGE SET FORTH ABOVE, THESE ARE
000000  1               ; 		ALL STRAIGHTFORWARD.
000000  1               ;
000000  1               ; 	NEWSTT
000000  1               ; 		WHENEVER A STATEMENT FINISHES EXECUTION IT
000000  1               ; 		DOES A "RTS" WHICH TAKES
000000  1               ; 		EXECUTION BACK TO "NEWSTT". STATEMENTS THAT
000000  1               ; 		CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
000000  1               ; 		MUST GET RID OF THE RETURN ADDRESS OF "NEWSTT" AND
000000  1               ; 		JMP TO "NEWSTT" WHEN DONE. "NEWSTT" ALWAYS
000000  1               ; 		CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
000000  1               ; 		NAME BEFORE DISPATCHING. WHEN RETURNING
000000  1               ; 		BACK TO "NEWSTT" THE ONLY THING THAT
000000  1               ; 		MUST BE SET UP IS THE TEXT POINTER IN
000000  1               ; 		"TXTPTR". "NEWSTT" WILL CHECK TO MAKE SURE
000000  1               ; 		"TXTPTR" IS POINTING TO A STATEMENT TERMINATOR.
000000  1               ; 		IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
000000  1               ; 		IT IS PROPERLY FORMATTED (I.E. "NEW") IT CAN
000000  1               ; 		SIMPLY DO A RETURN AFTER READING ALL OF
000000  1               ; 		ITS ARGUMENTS. SINCE THE ZERO FLAG
000000  1               ; 		BEING OFF INDICATES THERE IS NOT
000000  1               ; 		A STATEMENT TERMINATOR "NEWSTT" WILL
000000  1               ; 		DO THE JMP TO THE "SYNTAX ERROR"
000000  1               ; 		ROUTINE. IF A STATEMENT SHOULD BE STARTED
000000  1               ; 		OVER IT CAN DO LDWD OLDTXT, STWD TXTPTR RTS SINCE THE TEXT PNTR
000000  1               ; 		AT "NEWSTT" IS ALWAYS STORED IN "OLDTXT".
000000  1               ; 		THE ^C CODE STORES [CURLIN] (THE
000000  1               ; 		CURRENT LINE NUMBER) IN "OLDLIN" SINCE THE ^C CHECK
000000  1               ; 		IS MADE BEFORE THE STATEMENT POINTED TO IS
000000  1               ; 		EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
000000  1               ; 		FROM "TXTPTR", WHICH POINTS AT THEIR TERMINATING
000000  1               ; 		CHARACTER, IN "OLDTXT".
000000  1               ;
000000  1               ; 	STATEMENT CODE
000000  1               ; 		THE INDIVIDUAL STATEMENT CODE COMES
000000  1               ; 		NEXT. THE APPROACH USED IN EXECUTING EACH
000000  1               ; 		STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
000000  1               ; 		ITSELF.
000000  1               ;
000000  1               ; 	FRMEVL, THE FORMULA EVALUATOR
000000  1               ; 		GIVEN A TEXT POINTER POINTING TO THE STARTING
000000  1               ; 		CHARACTER OF A FORMULA, "FRMEVL"
000000  1               ; 		EVALUATES THE FORMULA AND LEAVES
000000  1               ; 		THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
000000  1               ; 		"TXTPTR" IS RETURNED POINTING TO THE FIRST CHARACTER
000000  1               ; 		THAT COULD NOT BE INTERPRETED AS PART OF THE
000000  1               ; 		FORMULA. THE ALGORITHM USES THE STACK
000000  1               ; 		TO STORE TEMPORARY RESULTS:
000000  1               ;
000000  1               ; 			0. PUT A DUMMY PRECEDENCE OF ZERO ON
000000  1               ; 				THE STACK.
000000  1               ; 			1. READ LEXEME (CONSTANT,FUNCTION,
000000  1               ; 				VARIABLE,FORMULA IN PARENS)
000000  1               ; 				AND TAKE THE LAST PRECEDENCE VALUE
000000  1               ; 				OFF THE STACK.
000000  1               ; 			2. SEE IF THE NEXT CHARACTER IS AN OPERATOR.
000000  1               ; 				IF NOT, CHECK PREVIOUS ONE. THIS MAY CAUSE
000000  1               ; 				OPERATOR APPLICATION OR AN ACTUAL
000000  1               ; 				RETURN FROM "FRMEVL".
000000  1               ; 			3. IF IT IS, SEE WHAT PRECEDENCE IT HAS
000000  1               ; 				AND COMPARE IT TO THE PRECEDENCE
000000  1               ; 				OF THE LAST OPERATOR ON THE STACK.
000000  1               ; 			4. IF = OR LESS REMEMBER THE OPERATOR
000000  1               ; 				POINTER OF THIS OPERATOR
000000  1               ; 				AND BRANCH TO "QCHNUM" TO CAUSE
000000  1               ; 				APPLICATION OF THE LAST OPERATOR.
000000  1               ; 				EVENTUALLY RETURN TO STEP 2
000000  1               ; 				BY RETURNING TO JUST AFTER "DOPREC".
000000  1               ; 			5. IF GREATER PUT THE LAST PRECEDENCE
000000  1               ; 				BACK ON, SAVE THE OPERATOR ADDRESS,
000000  1               ; 				CURRENT TEMPORARY RESULT,
000000  1               ; 				AND PRECEDENCE AND RETURN TO STEP 1.
000000  1               ;
000000  1               ; 		RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
000000  1               ; 		A COMMON ROUTINE. SPECIAL
000000  1               ; 		CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F".
000000  1               ;
000000  1               ; 	EVAL -- THE ROUTINE TO READ A LEXEME
000000  1               ; 		"EVAL" CHECKS FOR THE DIFFERENT TYPES OF
000000  1               ; 		ENTITIES IT IS SUPPOSED TO DETECT.
000000  1               ; 		LEADING PLUSES ARE IGNORED,
000000  1               ; 		DIGITS AND "." CAUSE "FIN" (FLOATING INPUT)
000000  1               ; 		TO BE CALLED. FUNCTION NAMES CAUSE THE
000000  1               ; 		FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
000000  1               ; 		AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
000000  1               ; 		NAMES CAUSE "PTRGET" TO BE CALLED TO GET A POINTER
000000  1               ; 		TO THE VALUE, AND THEN THE VALUE IS PUT INTO
000000  1               ; 		THE FAC. AN OPEN PARENTHESIS CAUSES "FRMEVL"
000000  1               ; 		TO BE CALLED (RECURSIVELY), AND THE ")" TO
000000  1               ; 		BE CHECKED FOR. UNARY OPERATORS (NOT AND
000000  1               ; 		NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
000000  1               ; 		AND ENTER FORMULA EVALUATION AT STEP 1, SO
000000  1               ; 		THAT EVERYTHING UP TO AN OPERATOR GREATER THAN
000000  1               ; 		THEIR PRECEDENCE OR THE END OF THE FORMULA
000000  1               ; 		WILL BE EVALUATED.
000000  1               ;
000000  1               ; 	DIMENSION AND VARIABLE SEARCHING
000000  1               ; 		SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
000000  1               ; 		ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
000000  1               ; 		EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
000000  1               ; 		FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
000000  1               ; 		NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
000000  1               ; 		BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
000000  1               ; 		GIVE ITS VALUE. [VARTAB] GIVES THE FIRST LOCATION
000000  1               ; 		WHERE A SIMPLE VARIABLE NAME IS FOUND AND [ARYTAB]
000000  1               ; 		GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
000000  1               ; 		VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
000000  1               ; 		AND A POINTER TO A VARIABLE VALUE SO NEITHER
000000  1               ; 		THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
000000  1               ; 		MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK.
000000  1               ; 		USER DEFINED FUNCTION VALUES ALSO CONTAIN
000000  1               ; 		POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
000000  1               ; 		FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
000000  1               ; 		ARE MOVED. ADDING A SIMPLE VARIABLE IS JUST
000000  1               ; 		ADDING SIX TO [ARYTAB] AND [STREND], BLOCK TRANSFERING
000000  1               ; 		THE ARRAY VARIABLES UP BY SIX AND MAKING SURE THE
000000  1               ; 		NEW [STREND] IS NOT TOO CLOSE TO THE STRINGS.
000000  1               ; 		THIS MOVEMENT OF ARRAY VARIABLES MEANS
000000  1               ; 		THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
000000  1               ; 		NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
000000  1               ; 		WHY ARRAY VARIABLES ARE NOT ALLOWED FOR "FOR"
000000  1               ; 		LOOP VARIABLES. SETTING UP A NEW ARRAY VARIABLE
000000  1               ; 		MERELY INVOLVES BUILDING THE DESCRIPTOR,
000000  1               ; 		UPDATING [STREND], AND MAKING SURE THERE IS
000000  1               ; 		STILL ENOUGH ROOM BETWEEN [STREND] AND STRING SPACE.
000000  1               ; 		"PTRGET", THE ROUTINE WHICH RETURNS A POINTER
000000  1               ; 		TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
000000  1               ; 		"DIMFLG" WHICH INDICATES WHETHER "DIM" CALLED "PTRGET"
000000  1               ; 		OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
000000  1               ; 		QUESTION SHOULD BE FOUND, AND THE INDEX INDICATES
000000  1               ; 		HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
000000  1               ; 		BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
000000  1               ; 		SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
000000  1               ; 		ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS "SUBFLG"
000000  1               ; 		WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
000000  1               ; 		ALLOWED IN THE CURRENT CONTEXT. IF [SUBFLG] IS NON-ZERO
000000  1               ; 		THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
000000  1               ; 		WILL NOT BE SCANNED BY "PTRGET", AND "PTRGET" WILL RETURN
000000  1               ; 		WITH A TEXT POINTER POINTING TO THE "(", IF
000000  1               ; 		THERE WAS ONE.
000000  1               ; 	STRINGS
000000  1               ; 		IN THE VARIABLE TABLES STRINGS ARE STORED JUST LIKE
000000  1               ; 		NUMERIC VARIABLES. SIMPLE STRINGS HAVE THREE VALUE
000000  1               ; 		BYTES WHICH ARE INITIALIZED TO ALL ZEROS (WHICH
000000  1               ; 		REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
000000  1               ; 		IN HANDLING IS THAT WHEN "PTRGET" SEES A "$" AFTER THE
000000  1               ; 		NAME OF A VARIABLE, "PTRGET" SETS [VALTYP]
000000  1               ; 		TO NEGATIVE ONE AND TURNS
000000  1               ; 		ON THE MSB (MOST-SIGNIFIGANT-BIT) OF THE VALUE OF
000000  1               ; 		THE FIRST CHARACTER OF THE VARIABLE NAME.
000000  1               ; 		HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
000000  1               ; 		THAT THE SEARCH ROUTINE WILL NOT MATCH
000000  1               ; 		'A' WITH 'A$' OR 'A$' WITH 'A'. THE MEANING OF
000000  1               ; 		THE THREE VALUE BYTES ARE:
000000  1               ; 			LOW
000000  1               ; 				LENGTH OF THE STRING
000000  1               ; 				LOW 8 BITS
000000  1               ; 				HIGH 8 BITS  OF THE ADDRESS
000000  1               ; 					OF THE CHARACTERS IN THE
000000  1               ; 					STRING IF LENGTH.NE.0.
000000  1               ; 					MEANINGLESS OTHERWISE.
000000  1               ; 			HIGH
000000  1               ; 		THE VALUE OF A STRING VARIABLE (THESE 3 BYTES)
000000  1               ; 		IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
000000  1               ; 		IT FROM THE ACTUAL STRING DATA. WHENEVER A
000000  1               ; 		STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
000000  1               ; 		PART OF AN INPUT STRING, OR AS PART OF DATA, "STRLIT"
000000  1               ; 		IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
000000  1               ; 		THE STRING. WHEN ASSIGNMENT IS MADE TO A STRING POINTING INTO
000000  1               ; 		"BUF" THE VALUE IS COPIED INTO STRING SPACE SINCE [BUF]
000000  1               ; 		IS ALWAYS CHANGING.
000000  1               ;
000000  1               ; 		STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
000000  1               ; 		ALWAYS RETURN THEIR VALUES IN STRING SPACE.
000000  1               ; 		ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
000000  1               ; 		THROUGH A "READ" OR ASSIGNMENT STATEMENT
000000  1               ; 		WILL NOT USE ANY STRING SPACE SINCE
000000  1               ; 		THE STRING DESCRIPTOR  WILL POINT INTO THE
000000  1               ; 		PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
000000  1               ; 		WHEN A STRING VALUE IS IN "BUF", OR IT IS IN STRING
000000  1               ; 		SPACE AND THERE IS AN ACTIVE POINTER TO IT.
000000  1               ; 		THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
000000  1               ; 		STRING DATA IN STRING SPACE. F$=CHR$(7)
000000  1               ; 		WILL USE ONE BYTE OF STRING SPACE TO STORE THE
000000  1               ; 		NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
000000  1               ; 		THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
000000  1               ; 		THE ONLY POINTER AT THE NEW STRING IS A
000000  1               ; 		TEMPORARY DESCRIPTOR CREATED BY "FRMEVL" WHICH WILL
000000  1               ; 		GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
000000  1               ; 		IT IS THE NATURE OF GARBAGE COLLECTION THAT
000000  1               ; 		DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
000000  1               ; 		AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
000000  1               ; 		MUST PROCEED AS FOLLOWS:
000000  1               ; 			1) FIGURE OUT THE LENGTH OF THEIR RESULT.
000000  1               ;
000000  1               ; 			2) CALL "GETSPA" TO FIND SPACE FOR THEIR
000000  1               ; 			RESULT. THE ARGUMENTS TO THE FUNCTION
000000  1               ; 			OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
000000  1               ; 			MAY BE INVOKED. THE ONLY THING THAT CAN
000000  1               ; 			BE SAVED DURING THE CALL TO "GETSPA" IS A POINTER
000000  1               ; 			TO THE DESCRIPTORS OF THE ARGUMENTS.
000000  1               ; 			3) CONSTRUCT THE RESULT DESCRIPTOR IN "DSCTMP".
000000  1               ; 			"GETSPA" RETURNS THE LOCATION OF THE AVAILABLE
000000  1               ; 			SPACE.
000000  1               ; 			4) CREATE THE NEW VALUE BY COPYING PARTS
000000  1               ; 			OF THE ARGUMENTS OR WHATEVER.
000000  1               ; 			5) FREE UP THE ARGUMENTS BY CALLING "FRETMP".
000000  1               ; 			6) JUMP TO "PUTNEW" TO GET THE DESCRIPTOR IN
000000  1               ; 			"DSCTMP" TRANSFERRED INTO A NEW STRING TEMPORARY.
000000  1               ;
000000  1               ; 		THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
000000  1               ; 		COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
000000  1               ; 		SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
000000  1               ; 		USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
000000  1               ;
000000  1               ; 		INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
000000  1               ; 		FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
000000  1               ; 		BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
000000  1               ; 		VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
000000  1               ; 		STORED IN THE FAC, AND IT IS THIS POINTER
000000  1               ; 		THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
000000  1               ; 		STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
000000  1               ; 		AWAY SINCE "GETSPA" MAY FORCE
000000  1               ; 		GARBAGE COLLECTION AND THE ARGUMENT STRINGS
000000  1               ; 		MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
000000  1               ; 		WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
000000  1               ; 		THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
000000  1               ; 		"DSCTMP" SINCE STRING TEMPORARIES ARE ALLOCATED
000000  1               ; 		(PUTNEW) AND DEALLOCATED (FRETMP) IN A FIFO ORDERING
000000  1               ; 		(I.E. A STACK) SO THE NEW TEMPORARY CANNOT
000000  1               ; 		BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
000000  1               ; 		TO BUILD A RESULT IN A TEMPORARY AFTER
000000  1               ; 		FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
000000  1               ; 		IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
000000  1               ; 		TOO SOON BY THE NEW RESULT.
000000  1               ;
000000  1               ; 		STRING SPACE IS ALLOCATED AT THE VERY TOP
000000  1               ; 		OF MEMORY. "MEMSIZ" POINTS BEYOND THE LAST LOCATION OF
000000  1               ; 		STRING SPACE. STRINGS ARE STORED IN HIGH LOCATIONS
000000  1               ; 		FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA).
000000  1               ; 		[FRETOP], WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
000000  1               ; 		TO GIVE THE HIGHEST LOCATION IN STRING SPACE
000000  1               ; 		THAT IS NOT IN USE. THE RESULT IS THAT
000000  1               ; 		[FRETOP] GETS SMALLER AND SMALLER, UNTIL SOME
000000  1               ; 		ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
000000  1               ; 		[STREND]. THIS MEANS STRING SPACE HAS RUN INTO THE
000000  1               ; 		THE ARRAYS AND THAT GARBAGE COLLECTION MUST BE CALLED.
000000  1               ;
000000  1               ; 		GARBAGE COLLECTION:
000000  1               ; 			0. [MINPTR]=[STREND] [FRETOP]=[MEMSIZ]
000000  1               ; 			1. [REMMIN]=0
000000  1               ; 			2. FOR EACH STRING DESCRIPTOR
000000  1               ; 			(TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
000000  1               ; 			IF THE STRING IS NOT NULL AND ITS POINTER IS
000000  1               ; 			.GT.MINPTR AND .LT.FRETOP,
000000  1               ; 			[MINPTR]=THIS STRING DESCRIPTOR'S POINTER,
000000  1               ; 			[REMMIN]=POINTER AT THIS STRING DESCRIPTOR.
000000  1               ; 			END.
000000  1               ; 			3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING),
000000  1               ; 			BLOCK TRANSFER THE STRING DATA POINTED
000000  1               ; 			TO IN THE STRING DESCRIPTOR POINTED TO BY "REMMIN"
000000  1               ; 			SO THAT THE LAST BYTE OF STRING DATA IS AT
000000  1               ; 			[FRETOP]. UPDATE [FRETOP] SO THAT IT
000000  1               ; 			POINTS TO THE LOCATION JUST BELOW THE ONE
000000  1               ; 			THE STRING DATA WAS MOVED INTO. UPDATE
000000  1               ; 			THE POINTER IN THE DESCRIPTOR SO IT POINTS
000000  1               ; 			TO THE NEW LOCATION OF THE STRING DATA.
000000  1               ; 			GO TO STEP 1.
000000  1               ;
000000  1               ; 		AFTER CALLING GARBAGE COLLECTION "GETSPA" AGAIN CHECKS
000000  1               ; 		TO SEE IF [ACCA] CHARACTERS ARE AVAILABLE BETWEEN
000000  1               ; 		[STREND] AND [FRETOP]; IF NOT, AN "OUT OF STRING"
000000  1               ; 		ERROR IS INVOKED.
000000  1               ;
000000  1               ; 	MATH PACKAGE
000000  1               ; 		THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
000000  1               ; 		FLOATING OUTPUT (FOUT), FLOATING COMPARE (FCOMP)
000000  1               ; 		... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
000000  1               ; 		THE FORMATS, CONVENTIONS AND ENTRY POINTS ARE ALL
000000  1               ; 		DESCRIBED IN THE MATH PACKAGE ITSELF.
000000  1               ;
000000  1               ; 	INIT -- THE INITIALIZATION ROUTINE
000000  1               ; 		THE AMOUNT OF MEMORY,
000000  1               ; 		TERMINAL WIDTH, AND WHICH FUNCTIONS TO BE RETAINED
000000  1               ; 		ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
000000  1               ; 		AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
000000  1               ; 		AND [TXTTAB] IS SET UP TO POINT AT THE NEXT LOCATION.
000000  1               ; 		THIS DETERMINES WHERE PROGRAM STORAGE WILL START.
000000  1               ; 		SPECIAL CHECKS ARE MADE TO MAKE SURE
000000  1               ; 		ALL QUESTIONS IN "INIT" ARE ANSWERED REASONABLY, SINCE
000000  1               ; 		ONCE "INIT" FINISHES, THE LOCATIONS IT USES ARE
000000  1               ; 		USED FOR PROGRAM STORAGE. THE LAST THING "INIT" DOES IS
000000  1               ; 		CHANGE LOCATION ZERO TO BE A JUMP TO "READY" INSTEAD
000000  1               ; 		OF "INIT". ONCE THIS IS DONE THERE IS NO WAY TO RESTART
000000  1               ; 		"INIT".
000000  1               ; HIGH LOCATIONS
000000  1               ;
000000  1               
000000  1               ; PAGE
000000  1               ; SUBTTL	PAGE ZERO.
000000  1               .IF	REALIO-3 <> 0
000000  1  4C 56 3E     START:	JMP	INIT		;INITIALIZE - SETUP CERTAIN LOCATIONS
000003  1               				;AND DELETE FUNCTIONS IF NOT NEEDED,
000003  1               				;AND CHANGE THIS TO "JMP READY"
000003  1               				;IN CASE USER RESTARTS AT LOC ZERO.
000003  1  4C 56 3E     RDYJSR: JMP	INIT		;CHANGED TO "JMP STROUT" BY "INIT"
000006  1               				;TO HANDLE ERRORS.
000006  1  3C 2E        ADRAYI: ADR(AYINT)		;STORE HERE THE ADDR OF THE
000008  1               				;ROUTINE TO TURN THE FAC INTO A
000008  1               				;TWO BYTE SIGNED INTEGER IN [Y,A]
000008  1  0F 30        ADRGAY: ADR(GIVAYF)		;STORE HERE THE ADDR OF THE
00000A  1               				;ROUTINE TO CONVERT [Y,A] TO A FLOATING
00000A  1               				;POINT NUMBER IN THE FAC.
00000A  1               .ENDIF
00000A  1               .IF	ROMSW <> 0
00000A  1  4C C5 2E     USRPOK: JMP	FCERR		;SET UP ORIG BY INIT.
00000D  1               .ENDIF
00000D  1               ;
00000D  1               ; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
00000D  1               ; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
00000D  1               ; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
00000D  1               ; PROGRAM INSTRUCTIONS IN ROM.
00000D  1               ;
00000D  1               ; --- GENERAL RAM ---:
00000D  1  xx           CHARAC: BLOCK	1		;A DELIMITING CHARACTER.
00000E  1               INTEGR= CHARAC			;A ONE-BYTE INTEGER FROM "QINT".
00000E  1  xx           ENDCHR: BLOCK	1		;THE OTHER DELIMITING CHARACTER.
00000F  1  xx           COUNT:	BLOCK	1		;A GENERAL COUNTER.
000010  1               
000010  1               ; --- FLAGS ---:
000010  1  xx           DIMFLG: BLOCK	1		;IN GETTING A POINTER TO A VARIABLE
000011  1               				;IT IS IMPORTANT TO REMEMBER WHETHER IT
000011  1               				;IS BEING DONE FOR "DIM" OR NOT.
000011  1               				;DIMFLG AND VALTYP MUST BE
000011  1               				;CONSECUTIVE LOCATIONS.
000011  1               KIMY=	DIMFLG			;PLACE TO PRESERVE Y DURING OUT.
000011  1  xx           VALTYP: BLOCK	1		;THE TYPE INDICATOR.
000012  1               				;0=NUMERIC 1=STRING.
000012  1               .IF	INTPRC <> 0
000012  1  xx           INTFLG: BLOCK	1		;TELLS IF INTEGER.
000013  1               .ENDIF
000013  1  xx           DORES:	BLOCK	1		;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS.
000014  1               				;TURNED ON WHEN "DATA"
000014  1               				;BEING SCANNED BY CRUNCH SO UNQUOTED
000014  1               				;STRINGS WON'T BE CRUNCHED.
000014  1               GARBFL= DORES			;WHETHER TO DO GARBAGE COLLECTION.
000014  1  xx           SUBFLG: BLOCK	1		;FLAG WHETHER SUB'D VARIABLE ALLOWED.
000015  1               				;"FOR" AND USER-DEFINED FUNCTION
000015  1               				;POINTER FETCHING TURN
000015  1               				;THIS ON BEFORE CALLING "PTRGET"
000015  1               				;SO ARRAYS WON'T BE DETECTED.
000015  1               				;"STKINI" AND "PTRGET" CLEAR IT.
000015  1               				;ALSO DISALLOWS INTEGERS THERE.
000015  1  xx           INPFLG: BLOCK	1		;FLAGS WHETHER WE ARE DOING "INPUT"
000016  1               				;OR "READ".
000016  1  xx           TANSGN: BLOCK	1		;USED IN DETERMINING SIGN OF TANGENT.
000017  1               .IF	REALIO <> 0
000017  1               CNTWFL: BLOCK	1		;SUPPRESS OUTPUT FLAG.
000017  1               				;NON-ZERO MEANS SUPPRESS.
000017  1               				;RESET BY "INPUT", READY AND ERRORS.
000017  1               				;COMPLEMENTED BY INPUT OF ^O.
000017  1               .ENDIF
000017  1               
000017  1               .IF	REALIO-4 = 0
000017  1               	ORG	80	;ROOM FOR APPLE PAGE 0 STUFF.
000017  1               .ENDIF
000017  1               ; --- RAM DEALING WITH TERMINAL HANDLING ---:
000017  1               .IF	EXTIO <> 0
000017  1               CHANNL: BLOCK	1		;HOLDS CHANNEL NUMBER.
000017  1               .ENDIF
000017  1               .IF	NULCMD <> 0
000017  1  00           NULCNT: .BYTE 0			;NUMBER OF NULLS TO PRINT.
000018  1               .ENDIF
000018  1               .IF	REALIO-3 <> 0
000018  1  xx           TRMPOS: BLOCK	1		;POSITION OF TERMINAL CARRIAGE.
000019  1               .ENDIF
000019  1  48           LINWID: .BYTE LINLEN		;LENGTH OF LINE (WIDTH).
00001A  1  38           NCMWID: .BYTE NCMPOS		;POSITION BEYOND WHICH THERE ARE
00001B  1               				;NO MORE FIELDS.
00001B  1  00           LINNUM: .BYTE 0			;LOCATION TO STORE LINE NUMBER BEFORE BUF
00001C  1               				;SO THAT "BLTUC" CAN STORE IT ALL AWAY AT ONCE.
00001C  1  2C           .BYTE	44			;A COMMA (PRELOAD OR FROM ROM)
00001D  1               				;USED BY INPUT STATEMENT SINCE THE
00001D  1               				;DATA POINTER ALWAYS STARTS ON A
00001D  1               				;COMMA OR TERMINATOR.
00001D  1               .IF	BUFPAG = 0
00001D  1  xx xx xx xx  BUF:	BLOCK	BUFLEN		;TYPE IN STORED HERE.
000021  1  xx xx xx xx  
000025  1  xx xx xx xx  
000065  1               				;DIRECT STATEMENTS EXECUTE OUT OF
000065  1               				;HERE. REMEMBER "INPUT" SMASHES BUF.
000065  1               				;MUST BE ON PAGE ZERO
000065  1               				;OR ASSIGNMENT OF STRING
000065  1               				;VALUES IN DIRECT STATEMENTS WON'T COPY
000065  1               				;INTO STRING SPACE -- WHICH IT MUST.
000065  1               				;N.B. TWO NONZERO BYTES MUST PRECEDE "BUFLNM".
000065  1               .ENDIF
000065  1               
000065  1               ; --- STORAGE FOR TEMPORARY THINGS ---:
000065  1  xx           TEMPPT: BLOCK	1		;POINTER AT FIRST FREE TEMP DESCRIPTOR.
000066  1               				;INITIALIZED TO POINT TO TEMPST.
000066  1  xx xx        LASTPT: BLOCK	2		;POINTER TO LAST-USED STRING TEMPORARY.
000068  1  xx xx xx xx  TEMPST: BLOCK	STRSIZ*NUMTMP	;STORAGE FOR NUMTMP TEMP DESCRIPTORS.
00006C  1  xx xx xx xx  
000070  1  xx           
000071  1  xx xx        INDEX1: BLOCK	2		;INDEXES.
000073  1               INDEX=	INDEX1
000073  1  xx xx        INDEX2: BLOCK	2
000075  1  xx           RESHO:	BLOCK	1		;RESULT OF MULTIPLIER AND DIVIDER.
000076  1               .IF	ADDPRC <> 0
000076  1  xx           RESMOH: BLOCK	1		;ONE MORE BYTE.
000077  1               .ENDIF
000077  1  xx           RESMO:	BLOCK	1
000078  1  xx           RESLO:	BLOCK	1
000079  1               ADDEND= RESMO			;TEMPORARY USED BY "UMULT".
000079  1  00           .BYTE	0			;OVERFLOW FOR RES.
00007A  1               
00007A  1               ; --- POINTERS INTO DYNAMIC DATA STRUCTURES ---;
00007A  1  xx xx        TXTTAB: BLOCK	2		;POINTER TO BEGINNING OF TEXT.
00007C  1               				;DOESN'T CHANGE AFTER BEING
00007C  1               				;SETUP BY "INIT".
00007C  1  xx xx        VARTAB: BLOCK	2		;POINTER TO START OF SIMPLE
00007E  1               				;VARIABLE SPACE.
00007E  1               				;UPDATED WHENEVER THE SIZE OF THE
00007E  1               				;PROGRAM CHANGES, SET TO [TXTTAB]
00007E  1               				;BY "SCRATCH" ("NEW").
00007E  1  xx xx        ARYTAB: BLOCK	2		;POINTER TO BEGINNING OF ARRAY
000080  1               				;TABLE.
000080  1               				;INCREMENTED BY 6 WHENEVER
000080  1               				;A NEW SIMPLE VARIABLE IS FOUND, AND
000080  1               				;SET TO [VARTAB] BY "CLEARC".
000080  1  xx xx        STREND: BLOCK	2		;END OF STORAGE IN USE.
000082  1               				;INCREASED WHENEVER A NEW ARRAY
000082  1               				;OR SIMPLE VARIABLE IS ENCOUNTERED.
000082  1               				;SET TO [VARTAB] BY "CLEARC".
000082  1  xx xx        FRETOP: BLOCK	2		;TOP OF STRING FREE SPACE.
000084  1  xx xx        FRESPC: BLOCK	2		;POINTER TO NEW STRING.
000086  1  xx xx        MEMSIZ: BLOCK	2		;HIGHEST LOCATION IN MEMORY.
000088  1               
000088  1               ; --- LINE NUMBERS AND TEXTUAL POINTERS ---:
000088  1  xx xx        CURLIN: BLOCK	2		;CURRENT LINE #.
00008A  1               				;SET TO 0,255 FOR DIRECT STATEMENTS.
00008A  1  xx xx        OLDLIN: BLOCK	2		;OLD LINE NUMBER (SETUP BY ^C,"STOP"
00008C  1               				;OR "END" IN A PROGRAM).
00008C  1               POKER=	LINNUM			;SET UP LOCATION USED BY POKE.
00008C  1               				;TEMPORARY FOR INPUT AND READ CODE
00008C  1  xx xx        OLDTXT: BLOCK	2		;OLD TEXT POINTER.
00008E  1               				;POINTS AT STATEMENT TO BE EXEC'D NEXT.
00008E  1  xx xx        DATLIN: BLOCK	2		;DATA LINE # -- REMEMBER FOR ERRORS.
000090  1  xx xx        DATPTR: BLOCK	2		;POINTER TO DATA. INITIALIZED TO POINT
000092  1               				;AT THE ZERO IN FRONT OF [TXTTAB]
000092  1               				;BY "RESTORE" WHICH IS CALLED BY "CLEARC".
000092  1               				;UPDATED BY EXECUTION OF A "READ".
000092  1  xx xx        INPPTR: BLOCK	2		;THIS REMEMBERS WHERE INPUT IS COMING FROM.
000094  1               
000094  1               ; --- STUFF USED IN EVALUATIONS ---:
000094  1  xx xx        VARNAM: BLOCK	2		;VARIABLE'S NAME IS STORED HERE.
000096  1  xx xx        VARPNT: BLOCK	2		;POINTER TO VARIABLE IN MEMORY.
000098  1               FDECPT= VARPNT			;POINTER INTO POWER OF TENS OF "FOUT".
000098  1  xx xx        FORPNT: BLOCK	2		;A VARIABLE'S POINTER FOR "FOR" LOOPS
00009A  1               				;AND "LET" STATEMENTS.
00009A  1               LSTPNT= FORPNT			;PNTR TO LIST STRING.
00009A  1               ANDMSK= FORPNT			;THE MASK USED BY WAIT FOR ANDING.
00009A  1               EORMSK= FORPNT+1		;THE MASK FOR EORING IN WAIT.
00009A  1  xx xx        OPPTR:	BLOCK	2		;POINTER TO CURRENT OP'S ENTRY IN "OPTAB".
00009C  1               VARTXT= OPPTR			;POINTER INTO LIST OF VARIABLES.
00009C  1  xx           OPMASK: BLOCK	1		;MASK CREATED BY CURRENT OPERATOR.
00009D  1               DOMASK=TANSGN			;MASK IN USE BY RELATION OPERATIONS.
00009D  1  xx xx        DEFPNT: BLOCK	2		;POINTER USED IN FUNCTION DEFINITION.
00009F  1               GRBPNT= DEFPNT			;ANOTHER USED IN GARBAGE COLLECTION.
00009F  1  xx xx        DSCPNT: BLOCK	2		;POINTER TO A STRING DESCRIPTOR.
0000A1  1               .IF	ADDPRC <> 0
0000A1  1  xx           	BLOCK	1		;FOR TEMPF3.
0000A2  1               .ENDIF
0000A2  1               ; LGB: I am not sure what this means below: FOUR6:  EXP     STRSIZ
0000A2  1               ;      I assume this is an initialized byte
0000A2  1  03           FOUR6:	.BYTE	STRSIZ		;VARIABLE CONSTANT USED BY GARB COLLECT.
0000A3  1               
0000A3  1               ; --- ET CETERA ---:
0000A3  1  4C 60 EA     JMPER:	JMP	60000
0000A6  1               SIZE=	JMPER+1
0000A6  1               OLDOV=	JMPER+2			;THE OLD OVERFLOW.
0000A6  1               TEMPF3= DEFPNT			;A THIRD FAC TEMPORARY (4 BYTES).
0000A6  1               TEMPF1:
0000A6  1               .IF	ADDPRC <> 0		;FOR TEMPF1S EXTRA BYTE.
0000A6  1  00           .BYTE	0
0000A7  1               .ENDIF
0000A7  1  xx xx        HIGHDS: BLOCK	2		;DESINATION OF HIGHEST ELEMENT IN BLT.
0000A9  1  xx xx        HIGHTR: BLOCK	2		;SOURCE OF HIGHEST ELEMENT TO MOVE.
0000AB  1               TEMPF2:
0000AB  1               .IF	ADDPRC <> 0		;FOR TEMPF2S EXTRA BYTE.
0000AB  1  00           .BYTE	0
0000AC  1               .ENDIF
0000AC  1  xx xx        LOWDS:	BLOCK	2		;LOCATION OF LAST BYTE TRANSFERRED INTO.
0000AE  1  xx xx        LOWTR:	BLOCK	2		;LAST THING TO MOVE IN BLT.
0000B0  1               ARYPNT= HIGHDS			;A POINTER USED IN ARRAY BUILDING.
0000B0  1               GRBTOP= LOWTR			;A POINTER USED IN GARBAGE COLLECTION.
0000B0  1               DECCNT= LOWDS			;NUMBER OF PLACES BEFORE DECIMAL POINT.
0000B0  1               TENEXP= LOWDS+1			;HAS A DPT BEEN INPUT?
0000B0  1               DPTFLG= LOWTR			;BASE TEN EXPONENT.
0000B0  1               EXPSGN= LOWTR+1			;SIGN OF BASE TEN EXPONENT.
0000B0  1               
0000B0  1               ; --- THE FLOATING ACCUMULATOR ---:
0000B0  1               FAC:
0000B0  1  00           FACEXP: .BYTE 0
0000B1  1  00           FACHO:	.BYTE 0			;MOST SIGNIFICANT BYTE OF MANTISSA.
0000B2  1               .IF	ADDPRC <> 0
0000B2  1  00           FACMOH: .BYTE 0			;ONE MORE.
0000B3  1               .ENDIF
0000B3  1  00           FACMO:	.BYTE 0			;MIDDLE ORDER OF MANTISSA.
0000B4  1  00           FACLO:	.BYTE 0			;LEAST SIG BYTE OF MANTISSA.
0000B5  1  00           FACSGN: .BYTE 0			;SIGN OF FAC (0 OR -1) WHEN UNPACKED.
0000B6  1  00           SGNFLG: .BYTE 0			;SIGN OF FAC IS PRESERVED BERE BY "FIN".
0000B7  1               DEGREE= SGNFLG			;A COUNT USED BY POLYNOMIALS.
0000B7  1               DSCTMP= FAC			;THIS IS WHERE TEMP DESCS ARE BUILT.
0000B7  1               INDICE= FACMO			;INDICE IS SET UP HERE BY "QINT".
0000B7  1  00           BITS:	.BYTE 0			;SOMETHING FOR "SHIFTR" TO USE.
0000B8  1               
0000B8  1               ; --- THE FLOATING ARGUMENT (UNPACKED) ---:
0000B8  1  00           ARGEXP: .BYTE 0
0000B9  1  00           ARGHO:	.BYTE 0
0000BA  1               .IF	ADDPRC <> 0
0000BA  1  00           ARGMOH: .BYTE 0
0000BB  1               .ENDIF
0000BB  1  00           ARGMO:	.BYTE 0
0000BC  1  00           ARGLO:	.BYTE 0
0000BD  1  00           ARGSGN: .BYTE 0
0000BE  1               
0000BE  1  00           ARISGN: .BYTE 0			;A SIGN REFLECTING THE RESULT.
0000BF  1  00           FACOV:	.BYTE 0			;OVERFLOW BYTE OF THE FAC.
0000C0  1               STRNG1= ARISGN			;POINTER TO A STRING OR DESCRIPTOR.
0000C0  1               
0000C0  1  xx xx        FBUFPT: BLOCK	2		;POINTER INTO FBUFFR USED BY FOUT.
0000C2  1               BUFPTR= FBUFPT			;POINTER TO BUF USED BY "CRUNCH".
0000C2  1               STRNG2= FBUFPT			;POINTER TO STRING OR DESC.
0000C2  1               POLYPT= FBUFPT			;POINTER INTO POLYNOMIAL COEFFICIENTS.
0000C2  1               CURTOL= FBUFPT			;ABSOLUTE LINEAR INDEX IS FORMED HERE.
0000C2  1               ; PAGE
0000C2  1               ; SUBTTL	RAM CODE.
0000C2  1               ; THIS CODE GETS CHANGED THROUGHOUT EXECUTION.
0000C2  1               ; IT IS MADE TO BE FAST THIS WAY.
0000C2  1               ; ALSO, [X] AND [Y] ARE NOT DISTURBED
0000C2  1               ;
0000C2  1               ; "CHRGET" USING [TXTPTR] AS THE CURRENT TEXT PNTR
0000C2  1               ; FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [TXTPTR]
0000C2  1               ; AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
0000C2  1               ;	NOT C=	NUMERIC	  ("0" THRU "9")
0000C2  1               ;	Z=	":" OR END-OF-LINE (A NULL)
0000C2  1               ;
0000C2  1               ; [ACCA] = NEW CHAR.
0000C2  1               ; [TXTPTR]=[TXTPTR]+1
0000C2  1               ;
0000C2  1               ; THE FOLLOWING EXISTS IN ROM IF ROM EXISTS AND IS LOADED
0000C2  1               ; DOWN HERE BY INIT. OTHERWISE IT IS JUST LOADED INTO THIS
0000C2  1               ; RAM LIKE ALL THE REST OF RAM IS LOADED.
0000C2  1               ;
0000C2  1  E6 C9        CHRGET: INC	CHRGET+7	;INCREMENT THE WHOLE TXTPTR.
0000C4  1  D0 02        	BNE	CHRGOT
0000C6  1  E6 CA        	INC	CHRGET+8
0000C8  1  AD 60 EA     CHRGOT: LDA	60000		;A LOAD WITH AN EXT ADDR.
0000CB  1               TXTPTR= CHRGOT+1
0000CB  1  C9 20        	CMP	#' '		;SKIP SPACES.
0000CD  1  F0 F3        	BEQ	CHRGET
0000CF  1  C9 3A        QNUM:	CMP	#':'		;IS IT A ":"?
0000D1  1  B0 06        	BCS	CHRRTS		;IT IS .GE. ":"
0000D3  1  38           	SEC
0000D4  1  E9 30        	SBC	#'0'		;ALL CHARS .GT. "9" HAVE RET'D SO
0000D6  1  38           	SEC
0000D7  1  E9 D0        	SBC	#256-'0'		;SEE IF NUMERIC.
0000D9  1               				;TURN CARRY ON IF NUMERIC.
0000D9  1               				;ALSO, SETZ IF NULL.
0000D9  1  60           CHRRTS: RTS			;RETURN TO CALLER.
0000DA  1               
0000DA  1  80           RNDX:	.BYTE 128			;LOADED OR FROM ROM.
0000DB  1  4F           .BYTE	79			;THE INITIAL RANDOM NUMBER.
0000DC  1  C7           .BYTE	199
0000DD  1  52           .BYTE	82
0000DE  1               .IF	ADDPRC <> 0
0000DE  1  59           .BYTE	89			;ONE MORE BYTE.
0000DF  1               .ENDIF
0000DF  1               
0000DF  1               ORG	255			;PAGE 1 STUFF COMING UP.
0000FF  1  xx           LOFBUF: BLOCK	1		;THE LOW FAC BUFFER. COPYABLE.
000100  1               ;---  PAGE ZERO/ONE BOUNDARY ---.
000100  1               				;MUST HAVE 13 CONTIGUOUS BYTES.
000100  1  xx xx xx xx  FBUFFR: BLOCK	3*ADDPRC+13	;BUFFER FOR "FOUT".
000104  1  xx xx xx xx  
000108  1  xx xx xx xx  
000110  1               				;ON PAGE 1 SO THAT STRING IS NOT COPIED.
000110  1               
000110  1               ;STACK IS LOCATED HERE. IE FROM THE END OF FBUFFR TO STKEND.
000110  1               ; PAGE
000110  1               ; SUBTTL	DISPATCH TABLES, RESERVED WORDS, AND ERROR TEXTS.
000110  1               
000110  1               
000110  1               ; LGB: the trick that the "cutter" then extract the real binary, MUST be exactly before "ORG ROMLOC"
000110  1  7B 7B 43 55  .BYTE	"{{CUT#HERE}}"
000114  1  54 23 48 45  
000118  1  52 45 7D 7D  
00011C  1  00 20        .WORD	ROMLOC
00011E  1  56 3E        .WORD	INIT	; also give information about the entry point
000120  1  00 D0        .WORD	IO_START_ADDR
000122  1  00           .BYTE	REALIO
000123  1               ; LGB: end of hack
000123  1               
000123  1               	ORG	ROMLOC
002000  1               
002000  1  FE 25 1B 25  STMDSP: ADR(END-1)
002004  1  3D 2A C9 26  
002008  1               	ADR(FOR-1)
002008  1               	ADR(NEXT-1)
002008  1               	ADR(DATA-1)
002008  1  06 29 17 2D  .IF	EXTIO <> 0
00200C  1  30 29 76 27  
002010  1  76 26 4E 26  
002022  1               	ADR(INPUTN-1)
002022  1               .ENDIF
002022  1               	ADR(INPUT-1)
002022  1               	ADR(DIM-1)
002022  1               	ADR(READ-1)
002022  1               	ADR(LET-1)
002022  1               	ADR(GOTO-1)
002022  1               	ADR(RUN-1)
002022  1               	ADR(IF-1)
002022  1               	ADR(RESTOR-1)
002022  1               	ADR(GOSUB-1)
002022  1               	ADR(RETURN-1)
002022  1               	ADR(REM-1)
002022  1               	ADR(STOP-1)
002022  1               	ADR(ONGOTO-1)
002022  1  3D 26        .IF	NULCMD <> 0
002024  1               	ADR(NULL-1)
002024  1  AA 34        .ENDIF
002026  1               	ADR(FNWAIT-1)
002026  1  2E 30 A1 34  .IF	DISKO <> 0
00202A  1               .IF	REALIO-3 = 0
00202A  1               	ADR(CQLOAD-1)
00202A  1               	ADR(CQSAVE-1)
00202A  1               	ADR(CQVERF-1)
00202A  1               .ENDIF
00202A  1               .IF	REALIO <> 0
00202A  1               .IF	REALIO-2 <> 0
00202A  1               .IF	REALIO-3 <> 0
00202A  1               .IF	REALIO-5 <> 0
00202A  1               	ADR(LOAD-1)
00202A  1               	ADR(SAVE-1)
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .IF	REALIO-1 <> 0
00202A  1               .IF	REALIO-3 <> 0
00202A  1               .IF	REALIO-4 <> 0
00202A  1               	ADR(511)		;ADDRESS OF LOAD
00202A  1               	ADR(511)		;ADDRESS OF SAVE
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               	ADR(DEF-1)
00202A  1               	ADR(POKE-1)
00202A  1  05 28 23 26  .IF	EXTIO <> 0
00202E  1               	ADR(PRINTN-1)
00202E  1               .ENDIF
00202E  1               	ADR(PRINT-1)
00202E  1               	ADR(CONT-1)
00202E  1  21 26        .IF	REALIO = 0
002030  1               	ADR(DDT-1)
002030  1  8F 24 54 24  .ENDIF
002034  1               	ADR(LIST-1)
002034  1               	ADR(CLEAR-1)
002034  1               .IF	EXTIO <> 0
002034  1               	ADR(CMD-1)
002034  1               	ADR(CQSYS-1)
002034  1               	ADR(CQOPEN-1)
002034  1               	ADR(CQCLOS-1)
002034  1               .ENDIF
002034  1  F7 28        .IF	GETCMD <> 0
002036  1               	ADR(GET-1)		;FILL W/ GET ADDR.
002036  1  38 24        .ENDIF
002038  1               	ADR(SCRATH-1)
002038  1               
002038  1  B7 38 4A 39  FUNDSP: ADR(SGN)
00203C  1  D6 38        
00203E  1               	ADR(INT)
00203E  1               	ADR(ABS)
00203E  1               .IF	ROMSW = 0
00203E  1               USRLOC: ADR(FCERR)		;INITIALLY NO USER ROUTINE.
00203E  1               .ENDIF
00203E  1               .IF	ROMSW <> 0
00203E  1  0A 00        USRLOC: ADR(USRPOK)
002040  1  FB 2F 1C 30  .ENDIF
002044  1  B4 3B D5 3C  
002048  1  68 36 30 3C  
00204C  1               	ADR(FRE)
00204C  1               	ADR(POS)
00204C  1               	ADR(SQR)
00204C  1               	ADR(RND)
00204C  1               	ADR(LOG)
00204C  1               	ADR(EXP)
00204C  1               .IF	KIMROM <> 0
00204C  1               	REPEAT	4,{ADR(FCERR)}
00204C  1               .ENDIF
00204C  1               .IF	KIMROM = 0
00204C  1  11 3D        COSFIX: ADR(COS)
00204E  1  18 3D        SINFIX: ADR(SIN)
002050  1  61 3D        TANFIX: ADR(TAN)
002052  1  C5 3D        ATNFIX: ADR(ATN)
002054  1  8B 34 F9 33  .ENDIF
002058  1  E1 30 2A 34  
00205C  1  08 34 69 33  
002066  1               	ADR(PEEK)
002066  1               	ADR(LEN)
002066  1               	ADR(STR)
002066  1               	ADR(VAL)
002066  1               	ADR(ASC)
002066  1               	ADR(CHR)
002066  1               	ADR(LEFT)
002066  1               	ADR(RIGHT)
002066  1               	ADR(MID)
002066  1  79 E7 34     OPTAB:	.BYTE 121
002069  1               	ADR(FADDT-1)
002069  1  79 D0 34     .BYTE	121
00206C  1               	ADR(FSUBT-1)
00206C  1  7B A8 36     .BYTE	123
00206F  1               	ADR(FMULTT-1)
00206F  1  7B 8F 37     .BYTE	123
002072  1               	ADR(FDIVT-1)
002072  1  7F BD 3B     .BYTE	127
002075  1               	ADR(FPWRT-1)
002075  1  50 7F 2C     .BYTE	80
002078  1               	ADR(ANDOP-1)
002078  1  46 7C 2C     .BYTE	70
00207B  1               	ADR(OROP-1)
00207B  1  7D F6 3B     NEGTAB: .BYTE 125
00207E  1               	ADR(NEGOP-1)
00207E  1  5A D9 2B     NOTTAB: .BYTE 90
002081  1               	ADR(NOTOP-1)
002081  1  64 AC 2C     PTDORL: .BYTE 100			;PRECEDENCE.
002084  1               	ADR	(DOREL-1)	;OPERATOR ADDRESS.
002084  1               ;
002084  1               ; TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
002084  1               ; SIGNIFICANT BIT ON.
002084  1               ; THE LIST OF RESERVED WORDS:
002084  1               ;
002084  1               Q .SET 128-1
002084  1               ;DEFINE	DCI(A),<Q=Q+1	; LGB converted
002084  1               ;	DC(A)>		; LGB converted
002084  1               .MACRO	DCI	txt
002084  1               	Q	.SET Q + 1
002084  1               	.BYTE	txt
002084  1               .ENDMACRO
002084  1               
002084  1  45 4E 44     RESLST: DCI"END"
002087  1               	ENDTK .SET Q
002087  1  46 4F 52     	DCI"FOR"
00208A  1               	FORTK .SET Q
00208A  1  4E 45 58 54  	DCI"NEXT"
00208E  1  44 41 54 41  	DCI"DATA"
002092  1               	DATATK .SET Q
002092  1               .IF	EXTIO <> 0
002092  1               	DCI"INPUT#"
002092  1               .ENDIF
002092  1  49 4E 50 55  	DCI"INPUT"
002096  1  54           
002097  1  44 49 4D     	DCI"DIM"
00209A  1  52 45 41 44  	DCI"READ"
00209E  1  4C 45 54     	DCI"LET"
0020A1  1  47 4F 54 4F  	DCI"GOTO"
0020A5  1               	GOTOTK .SET Q
0020A5  1  52 55 4E     	DCI"RUN"
0020A8  1  49 46        	DCI"IF"
0020AA  1  52 45 53 54  	DCI"RESTORE"
0020AE  1  4F 52 45     
0020B1  1  47 4F 53 55  	DCI"GOSUB"
0020B5  1  42           
0020B6  1               	GOSUTK=Q
0020B6  1  52 45 54 55  	DCI"RETURN"
0020BA  1  52 4E        
0020BC  1  52 45 4D     	DCI"REM"
0020BF  1               	REMTK=Q
0020BF  1  53 54 4F 50  	DCI"STOP"
0020C3  1  4F 4E        	DCI"ON"
0020C5  1               .IF	NULCMD <> 0
0020C5  1  4E 55 4C 4C  	DCI"NULL"
0020C9  1               .ENDIF
0020C9  1  57 41 49 54  	DCI"WAIT"
0020CD  1               .IF	DISKO <> 0
0020CD  1               	DCI"LOAD"
0020CD  1               	DCI"SAVE"
0020CD  1               .IF	REALIO-3 = 0
0020CD  1               	DCI"VERIFY"
0020CD  1               .ENDIF
0020CD  1               .ENDIF
0020CD  1  44 45 46     	DCI"DEF"
0020D0  1  50 4F 4B 45  	DCI"POKE"
0020D4  1               .IF	EXTIO <> 0
0020D4  1               	DCI"PRINT#"
0020D4  1               .ENDIF
0020D4  1  50 52 49 4E  	DCI"PRINT"
0020D8  1  54           
0020D9  1               	PRINTK .SET Q
0020D9  1  43 4F 4E 54  	DCI"CONT"
0020DD  1               .IF	REALIO = 0
0020DD  1  44 44 54     	DCI"DDT"
0020E0  1               .ENDIF
0020E0  1  4C 49 53 54  	DCI"LIST"
0020E4  1               .IF	REALIO-3 <> 0
0020E4  1  43 4C 45 41  	DCI"CLEAR"
0020E8  1  52           
0020E9  1               .ENDIF
0020E9  1               .IF	REALIO-3 = 0
0020E9  1               	DCI"CLR"
0020E9  1               .ENDIF
0020E9  1               .IF	EXTIO <> 0
0020E9  1               	DCI"CMD"
0020E9  1               	DCI"SYS"
0020E9  1               	DCI"OPEN"
0020E9  1               	DCI"CLOSE"
0020E9  1               .ENDIF
0020E9  1               .IF	GETCMD <> 0
0020E9  1  47 45 54     	DCI"GET"
0020EC  1               .ENDIF
0020EC  1  4E 45 57     	DCI"NEW"
0020EF  1               	SCRATK=Q
0020EF  1               ; END OF COMMAND LIST.
0020EF  1  54           	.BYTE "T"
0020F0  1  41           	.BYTE "A"
0020F1  1  42           	.BYTE "B"
0020F2  1  A8           	.BYTE '('+128
0020F3  1               	Q .SET Q+1
0020F3  1               	TABTK=Q
0020F3  1  54 4F        	DCI"TO"
0020F5  1               	TOTK .SET Q
0020F5  1  46 4E        	DCI"FN"
0020F7  1               	FNTK .SET Q
0020F7  1  53           	.BYTE "S"
0020F8  1  50           	.BYTE "P"
0020F9  1  43           	.BYTE "C"
0020FA  1  A8           	.BYTE '('+128		;MACRO DOESNT LIKE ('S IN ARGUMENTS.
0020FB  1               	Q .SET Q+1
0020FB  1               	SPCTK .SET Q
0020FB  1  54 48 45 4E  	DCI"THEN"
0020FF  1               	THENTK=Q
0020FF  1  4E 4F 54     	DCI"NOT"
002102  1               	NOTTK .SET Q
002102  1  53 54 45 50  	DCI"STEP"
002106  1               	STEPTK=Q
002106  1  2B           	DCI"+"
002107  1               	PLUSTK=Q
002107  1  2D           	DCI"-"
002108  1               	MINUTK=Q
002108  1  2A           	DCI"*"
002109  1  2F           	DCI"/"
00210A  1  5E           	DCI"^"
00210B  1  41 4E 44     	DCI"AND"
00210E  1  4F 52        	DCI"OR"
002110  1  BE           .BYTE	190			;A GREATER THAN SIGN
002111  1               	Q .SET Q+1
002111  1               	GREATK=Q
002111  1  3D           	DCI"="
002112  1               	EQULTK=Q
002112  1  BC           .BYTE	188
002113  1               	Q .SET Q+1		;A LESS THAN SIGN
002113  1               	LESSTK=Q
002113  1               ;
002113  1               ; NOTE DANGER OF ONE RESERVED WORD BEING A PART
002113  1               ; OF ANOTHER:
002113  1               ; IE . . IF 2 GREATER THAN F OR T=5 THEN...
002113  1               ; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
002113  1               ; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
002113  1               ; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
002113  1               ; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
002113  1               ;
002113  1  53 47 4E     	DCI"SGN"
002116  1               	ONEFUN=Q
002116  1  49 4E 54     	DCI"INT"
002119  1  41 42 53     	DCI"ABS"
00211C  1  55 53 52     	DCI"USR"
00211F  1  46 52 45     	DCI"FRE"
002122  1  50 4F 53     	DCI"POS"
002125  1  53 51 52     	DCI"SQR"
002128  1  52 4E 44     	DCI"RND"
00212B  1  4C 4F 47     	DCI"LOG"
00212E  1  45 58 50     	DCI"EXP"
002131  1  43 4F 53     	DCI"COS"
002134  1  53 49 4E     	DCI"SIN"
002137  1  54 41 4E     	DCI"TAN"
00213A  1  41 54 4E     	DCI"ATN"
00213D  1  50 45 45 4B  	DCI"PEEK"
002141  1  4C 45 4E     	DCI"LEN"
002144  1  53 54 52 24  	DCI"STR$"
002148  1  56 41 4C     	DCI"VAL"
00214B  1  41 53 43     	DCI"ASC"
00214E  1  43 48 52 24  	DCI"CHR$"
002152  1               LASNUM .SET Q			;NUMBER OF LAST FUNCTION
002152  1               				;THAT TAKES ONE ARG
002152  1  4C 45 46 54  	DCI"LEFT$"
002156  1  24           
002157  1  52 49 47 48  	DCI"RIGHT$"
00215B  1  54 24        
00215D  1  4D 49 44 24  	DCI"MID$"
002161  1  47 4F        	DCI"GO"
002163  1               GOTK .SET Q
002163  1  00           .BYTE	0			;MARKS END OF RESERVED WORD LIST
002164  1               
002164  1               .IF	LNGERR = 0
002164  1               Q .SET 0-2
002164  1               ;DEFINE	DCE(X),<Q=Q+2		; LGB
002164  1               ;	DC(X)>			; LGB
002164  1               .MACRO	DCE	txt
002164  1               	Q .SET	Q + 2
002164  1               	.BYTE	txt
002164  1               .ENDMACRO
002164  1  4E 46        ERRTAB: DCE"NF"
002166  1               	ERRNF .SET Q		;NEXT WITHOUT FOR.
002166  1  53 4E        	DCE"SN"
002168  1               	ERRSN .SET Q		;SYNTAX
002168  1  52 47        	DCE"RG"
00216A  1               	ERRRG .SET Q		;RETURN WITHOUT GOSUB.
00216A  1  4F 44        	DCE"OD"
00216C  1               	ERROD .SET Q		;OUT OF DATA.
00216C  1  46 43        	DCE"FC"
00216E  1               	ERRFC .SET Q		;ILLEGAL QUANTITY.
00216E  1  4F 56        	DCE"OV"
002170  1               	ERROV .SET Q		;OVERFLOW.
002170  1  4F 4D        	DCE"OM"
002172  1               	ERROM .SET Q		;OUT OF MEMORY.
002172  1  55 53        	DCE"US"
002174  1               	ERRUS .SET Q		;UNDEFINED STATEMENT.
002174  1  42 53        	DCE"BS"
002176  1               	ERRBS .SET Q		;BAD SUBSCRIPT.
002176  1  44 44        	DCE"DD"
002178  1               	ERRDD .SET Q		;REDIMENSIONED ARRAY.
002178  1  2F 30        	DCE"/0"
00217A  1               	ERRDV0 .SET Q		;DIVISION BY ZERO.
00217A  1  49 44        	DCE"ID"
00217C  1               	ERRID .SET Q		;ILLEGAL DIRECT.
00217C  1  54 4D        	DCE"TM"
00217E  1               	ERRTM .SET Q		;TYPE MISMATCH.
00217E  1  4C 53        	DCE"LS"
002180  1               	ERRLS .SET Q		;STRING TOO LONG.
002180  1               .IF	EXTIO <> 0
002180  1               	DCE"FD"			;FILE DATA.
002180  1               	ERRBD .SET Q
002180  1               .ENDIF
002180  1  53 54        	DCE"ST"
002182  1               	ERRST .SET Q		;STRING FORMULA TOO COMPLEX.
002182  1  43 4E        	DCE"CN"
002184  1               	ERRCN .SET Q		;CAN'T CONTINUE.
002184  1  55 46        	DCE"UF"
002186  1               	ERRUF .SET Q		;UNDEFINED FUNCTION.
002186  1               .ENDIF
002186  1               
002186  1               .IF	LNGERR <> 0
002186  1               Q .SET 0
002186  1               ; NOTE: THIS ERROR COUNT TECHNIQUE WILL NOT WORK IF THERE ARE MORE
002186  1               ; THAN 256 CHARACTERS OF ERROR MESSAGES
002186  1               ERRTAB: DC"NEXT WITHOUT FOR"
002186  1               	ERRNF .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"SYNTAX"
002186  1               	ERRSN .SET Q
002186  1               	Q .SET Q+6
002186  1               	DC"RETURN WITHOUT GOSUB"
002186  1               	ERRRG .SET Q
002186  1               	Q .SET Q+20
002186  1               	DC"OUT OF DATA"
002186  1               	ERROD .SET Q
002186  1               	Q .SET Q+11
002186  1               	DC"ILLEGAL QUANTITY"
002186  1               	ERRFC .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"OVERFLOW"
002186  1               	ERROV .SET Q
002186  1               	Q .SET Q+8
002186  1               	DC"OUT OF MEMORY"
002186  1               	ERROM .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"UNDEF'D STATEMENT"
002186  1               	ERRUS .SET Q
002186  1               	Q .SET Q+17
002186  1               	DC"BAD SUBSCRIPT"
002186  1               	ERRBS .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"REDIM'D ARRAY"
002186  1               	ERRDD .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"DIVISION BY ZERO"
002186  1               	ERRDV0 .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"ILLEGAL DIRECT"
002186  1               	ERRID .SET Q
002186  1               	Q .SET Q+14
002186  1               	DC"TYPE MISMATCH"
002186  1               	ERRTM .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"STRING TOO LONG"
002186  1               	ERRLS .SET Q
002186  1               	Q .SET Q+15
002186  1               .IF	EXTIO <> 0
002186  1               	DC"FILE DATA"
002186  1               	ERRBD .SET Q
002186  1               	Q .SET Q+9
002186  1               .ENDIF
002186  1               	DC"FORMULA TOO COMPLEX"
002186  1               	ERRST .SET Q
002186  1               	Q .SET Q+19
002186  1               	DC"CAN'T CONTINUE"
002186  1               	ERRCN .SET Q
002186  1               	Q .SET Q+14
002186  1               	DC"UNDEF'D FUNCTION"
002186  1               	ERRUF .SET Q
002186  1               .ENDIF
002186  1               
002186  1               ;
002186  1               ; NEEDED FOR MESSAGES IN ALL VERSIONS.
002186  1               ;
002186  1  20 45 52 52  ERR:	DT" ERROR"
00218A  1  4F 52        
00218C  1  00           .BYTE	0
00218D  1  20 49 4E 20  INTXT:	DT" IN "
002191  1  00           .BYTE	0
002192  1  0D 0A        REDDY:	ACRLF
002194  1               .IF	REALIO-3 = 0
002194  1               	DT"READY."
002194  1               .ENDIF
002194  1               .IF	REALIO-3 <> 0
002194  1  4F 4B        	DT"OK"
002196  1               .ENDIF
002196  1  0D 0A        	ACRLF
002198  1  00           .BYTE	0
002199  1  0D 0A        BRKTXT: ACRLF
00219B  1  42 52 45 41  	DT"BREAK"
00219F  1  4B           
0021A0  1  00           .BYTE	0
0021A1  1               ; PAGE
0021A1  1               ; SUBTTL	GENERAL STORAGE MANAGEMENT ROUTINES.
0021A1  1               ;
0021A1  1               ; FIND A "FOR" ENTRY ON THE STACK VIA "VARPNT".
0021A1  1               ;
0021A1  1               FORSIZ .SET 2*ADDPRC+16
0021A1  1  BA           FNDFOR: TSX			;LOAD XREG WITH STK PNTR.
0021A2  1  E8 E8 E8 E8  	REPEAT	4,{INX}		;IGNORE ADR(NEWSTT) AND RTS ADDR.
0021A6  1  BD 01 01     FFLOOP: LDA	257,X		;GET STACK ENTRY.
0021A9  1  C9 81        	CMP	#FORTK		;IS IT A "FOR" TOKEN?
0021AB  1  D0 21        	BNE	FFRTS		;NO, NO "FOR" LOOPS WITH THIS PNTR.
0021AD  1  A5 99        	LDA	FORPNT+1	;GET HIGH.
0021AF  1  D0 0A        	BNE	CMPFOR
0021B1  1  BD 02 01     	LDA	258,X		;PNTR IS ZERO, SO ASSUME THIS ONE.
0021B4  1  85 98        	STA	FORPNT
0021B6  1  BD 03 01     	LDA	259,X
0021B9  1  85 99        	STA	FORPNT+1
0021BB  1  DD 03 01     CMPFOR: CMP	259,X
0021BE  1  D0 07        	BNE	ADDFRS		;NOT THIS ONE.
0021C0  1  A5 98        	LDA	FORPNT		;GET DOWN.
0021C2  1  DD 02 01     	CMP	258,X
0021C5  1  F0 07        	BEQ	FFRTS		;WE GOT IT! WE GOT IT!
0021C7  1  8A           ADDFRS: TXA
0021C8  1  18           	CLC			;ADD 16 TO X.
0021C9  1  69 12        	ADC	#FORSIZ
0021CB  1  AA           	TAX			;RESULT BACK INTO X.
0021CC  1  D0 D8        	BNE	FFLOOP
0021CE  1  60           FFRTS:	RTS			;RETURN TO CALLER.
0021CF  1               
0021CF  1               ;
0021CF  1               ; THIS IS THE BLOCK TRANSFER ROUTINE.
0021CF  1               ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD.
0021CF  1               ;
0021CF  1               ; ON ENTRY:
0021CF  1               ; [Y,A]=[HIGHDS]    (FOR REASON).
0021CF  1               ; [HIGHDS]= DESTINATION OF [HIGH ADDRESS].
0021CF  1               ; [LOWTR]= LOWEST ADDR TO BE TRANSFERRED.
0021CF  1               ; [HIGHTR]= HIGHEST ADDR TO BE TRANSFERRED.
0021CF  1               ;
0021CF  1               ; A CHECK IS MADE TO ASCERTAIN THAT A REASONABLE
0021CF  1               ; AMOUNT OF SPACE REMAINS BETWEEN THE BOTTOM
0021CF  1               ; OF THE STRINGS AND THE HIGHEST LOCATION TRANSFERRED INTO.
0021CF  1               ;
0021CF  1               ; ON EXIT:
0021CF  1               ; [LOWTR] ARE UNCHANGED.
0021CF  1               ; [HIGHTR]=[LOWTR]-200 OCTAL.
0021CF  1               ; [HIGHDS]=LOWEST ADDR TRANSFERRED INTO MINUS 200 OCTAL.
0021CF  1               ;
0021CF  1  20 1F 22     BLTU:	JSR	REASON		;ASCERTAIN THAT STRING SPACE WON'T
0021D2  1               				;BE OVERRUN.
0021D2  1  85 80 84 81  	STWD	STREND
0021D6  1  38           BLTUC:	SEC			;PREPARE TO SUBTRACT.
0021D7  1  A5 A9        	LDA	HIGHTR
0021D9  1  E5 AE        	SBC	LOWTR		;COMPUTE NUMBER OF THINGS TO MOVE.
0021DB  1  85 71        	STA	INDEX		;SAVE FOR LATER.
0021DD  1  A8           	TAY
0021DE  1  A5 AA        	LDA	HIGHTR+1
0021E0  1  E5 AF        	SBC	LOWTR+1
0021E2  1  AA           	TAX			;PUT IT IN A COUNTER REGISTER.
0021E3  1  E8           	INX			;SO THAT COUNTER ALGORITHM WORKS.
0021E4  1  98           	TYA			;SEE IF LOW PART OF COUNT IS ZERO.
0021E5  1  F0 23        	BEQ	DECBLT		;YES, GO START MOVING BLOCKS.
0021E7  1  A5 A9        	LDA	HIGHTR		;NO, MUST MODIFY BASE ADDR.
0021E9  1  38           	SEC
0021EA  1  E5 71        	SBC	INDEX		;BORROW IS OFF SINCE [HIGHTR].GT.[LOWTR].
0021EC  1  85 A9        	STA	HIGHTR		;SAVE MODIFIED BASE ADDR.
0021EE  1  B0 03        	BCS	BLT1		;IF NO BORROW, GO SHOVE IT.
0021F0  1  C6 AA        	DEC	HIGHTR+1	;BORROW IMPLIES SUB 1 FROM HIGH ORDER.
0021F2  1  38           	SEC
0021F3  1  A5 A7        BLT1:	LDA	HIGHDS		;MOD BASE OF DEST ADDR.
0021F5  1  E5 71        	SBC	INDEX
0021F7  1  85 A7        	STA	HIGHDS
0021F9  1  B0 08        	BCS	MOREN1		;NO BORROW.
0021FB  1  C6 A8        	DEC	HIGHDS+1	;DECREMENT HIGH ORDER BYTE.
0021FD  1  90 04        	BCC	MOREN1		;ALWAYS SKIP.
0021FF  1  B1 A9        BLTLP:	LDADY	HIGHTR		;FETCH BYTE TO MOVE
002201  1  91 A7        	STADY	HIGHDS		;MOVE IT IN, MOVE IT OUT.
002203  1  88           MOREN1: DEY
002204  1  D0 F9        	BNE	BLTLP
002206  1  B1 A9        	LDADY	HIGHTR		;MOVE LAST OF THE BLOCK.
002208  1  91 A7        	STADY	HIGHDS
00220A  1  C6 AA        DECBLT: DEC	HIGHTR+1
00220C  1  C6 A8        	DEC	HIGHDS+1	;START ON NEW BLOCKS.
00220E  1  CA           	DEX
00220F  1  D0 F2        	BNE	MOREN1
002211  1  60           	RTS			;RETURN TO CALLER.
002212  1               
002212  1               ;
002212  1               ; THIS ROUTINE IS USED TO ASCERTAIN THAT A GIVEN
002212  1               ; NUMBER OF LOCS REMAIN AVAILABLE FOR THE STACK.
002212  1               ;    THE CALL IS:
002212  1               ;	LDAI	NUMBER OF 2-BYTE ENTRIES NEEDED.
002212  1               ;	JSR	GETSTK
002212  1               ;
002212  1               ; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
002212  1               ; AN ARBITRARY AMOUNT OF STUFF ON THE STACK,
002212  1               ; I.E., ANY RECURSIVE ROUTINE LIKE "FRMEVL".
002212  1               ; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
002212  1               ; WHICH MAKE PERMANENT ENTRIES ON THE STACK.
002212  1               ;
002212  1               ; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
002212  1               ; NUMLEV LOCATIONS NEED NOT CALL THIS.
002212  1               ;
002212  1               ;
002212  1               ; ON EXIT:
002212  1               ;    [A] AND [X] HAVE BEEN MODIFIED.
002212  1               ;
002212  1  0A           GETSTK: ASL	A 		;MULT [A] BY 2. NB, CLEARS C BIT.
002213  1  69 3E        	ADC	#2*NUMLEV+(3*ADDPRC)+13	;MAKE SURE 2*NUMLEV+13 LOCS
002215  1               				;(13 BECAUSE OF FBUFFR)
002215  1  B0 35        	BCS	OMERR		;WILL REMAIN IN STACK.
002217  1  85 71        	STA	INDEX
002219  1  BA           	TSX			;GET STACKED.
00221A  1  E4 71        	CPX	INDEX		;COMPARE.
00221C  1  90 2E        	BCC	OMERR		;IF STACK.LE.INDEX1, OM.
00221E  1  60           	RTS
00221F  1               
00221F  1               ;
00221F  1               ; [Y,A] IS A CERTAIN ADDRESS. "REASON" MAKES SURE
00221F  1               ; IT IS LESS THAN [FRETOP].
00221F  1               ;
00221F  1  C4 83        REASON: CPY	FRETOP+1
002221  1  90 28        	BCC	REARTS
002223  1  D0 04        	BNE	TRYMOR		;GO GARB COLLECT.
002225  1  C5 82        	CMP	FRETOP
002227  1  90 22        	BCC	REARTS
002229  1  48           TRYMOR: PHA
00222A  1  A2 09        	LDX	#8+ADDPRC	;IF TEMPF2 HAS ZERO IN BETWEEN.
00222C  1  98           	TYA
00222D  1  48           REASAV: PHA
00222E  1  B5 A6        	LDA	HIGHDS-1,X	;SAVE HIGHDS ON STACK.
002230  1  CA           	DEX
002231  1  10 FA        	BPL	REASAV		;PUT 8 OF THEM ON STK.
002233  1  20 9E 31     	JSR	GARBA2		;GO GARB COLLECT.
002236  1  A2 F7        	LDX	#256-8-ADDPRC
002238  1  68           REASTO: PLA
002239  1  95 B0        	STA	HIGHDS+8+ADDPRC,X	;RESTORE AFTER GARB COLLECT.
00223B  1  E8           	INX
00223C  1  30 FA        	BMI	REASTO
00223E  1  68           	PLA
00223F  1  A8           	TAY
002240  1  68           	PLA			;RESTORE A AND Y.
002241  1  C4 83        	CPY	FRETOP+1	;COMPARE HIGHS
002243  1  90 06        	BCC	REARTS
002245  1  D0 05        	BNE	OMERR		;HIGHER IS BAD.
002247  1  C5 82        	CMP	FRETOP		;AND THE LOWS.
002249  1  B0 01        	BCS	OMERR
00224B  1  60           REARTS: RTS
00224C  1               
00224C  1               ; PAGE
00224C  1               ; SUBTTL	ERROR HANDLER, READY, TERMINAL INPUT, COMPACTIFY, NEW, REINIT.
00224C  1  A2 0C        OMERR:	LDX	#ERROM
00224E  1               ERROR:
00224E  1               .IF	REALIO <> 0
00224E  1               	LSR	CNTWFL		;FORCE OUTPUT.
00224E  1               .ENDIF
00224E  1               .IF	EXTIO <> 0
00224E  1               	LDA	CHANNL		;CLOSE NON-TERMINAL CHANNEL.
00224E  1               	BEQ	ERRCRD
00224E  1               	JSR	CQCCHN		;CLOSE IT.
00224E  1               	LDA	#0
00224E  1               	STA	CHANNL
00224E  1               .ENDIF
00224E  1  20 44 28     ERRCRD: JSR	CRDO		;OUTPUT CRLF.
002251  1  20 BA 28     	JSR	OUTQST		;PRINT A QUESTION MARK
002254  1               .IF	LNGERR = 0
002254  1  BD 64 21     	LDA	ERRTAB,X 	;GET FIRST CHR OF ERR MSG.
002257  1  20 BC 28     	JSR	OUTDO		;OUTPUT IT.
00225A  1  BD 65 21     	LDA	ERRTAB+1,X 	;GET SECOND CHR.
00225D  1  20 BC 28     	JSR	OUTDO		;OUTPUT IT.
002260  1               .ENDIF
002260  1               .IF	LNGERR <> 0
002260  1               GETERR: LDA	ERRTAB,X
002260  1               	PHA
002260  1               	AND	#127		;GET RID OF HIGH BIT.
002260  1               	JSR	OUTDO		;OUTPUT IT.
002260  1               	INX
002260  1               	PLA			;LAST CHAR OF MESSAGE?
002260  1               	BPL	GETERR		;NO. GO GET NEXT AND OUTPUT IT.
002260  1               .ENDIF
002260  1  20 6E 24     TYPERR: JSR	STKINI		;RESET THE STACK AND FLAGS.
002263  1  A9 86 A0 21  	LDWDI	ERR		;GET PNTR TO " ERROR".
002267  1  20 9A 28     ERRFIN: JSR	STROUT		;OUTPUT IT.
00226A  1  A4 89        	LDY	CURLIN+1
00226C  1  C8           	INY			;WAS NUMBER 64000?
00226D  1  F0 03        	BEQ	READY		;YES, DON'T TYPE LINE NUMBER.
00226F  1  20 40 3A     	JSR	INPRT
002272  1               READY:
002272  1               .IF	REALIO <> 0
002272  1               	LSR	CNTWFL		;TURN OUTPUT BACK ON IF SUPRESSED
002272  1               .ENDIF
002272  1  A9 92 A0 21  	LDWDI	REDDY		;SAY "OK".
002276  1               .IF	REALIO-3 <> 0
002276  1  20 03 00     	JSR	RDYJSR		;OR GO TO INIT IF INIT ERROR.
002279  1               .ENDIF
002279  1               .IF	REALIO-3 = 0
002279  1               	JSR	STROUT		;NO INIT ERRORS POSSIBLE.
002279  1               .ENDIF
002279  1  20 51 23     MAIN:	JSR	INLIN		;GET A LINE FROM TERMINAL.
00227C  1  86 C9 84 CA  	STXY	TXTPTR
002280  1  20 C2 00     	JSR	CHRGET
002283  1  AA           	TAX			;SET ZERO FLAG BASED ON [A]
002284  1               				;THIS DISTINGUISHES ":" AND 0
002284  1  F0 F3        	BEQ	MAIN		;IF BLANK LINE, GET ANOTHER.
002286  1  A2 FF        	LDX	#255		;SET DIRECT LINE NUMBER.
002288  1  86 89        	STX	CURLIN+1
00228A  1  90 06        	BCC	MAIN1		;IS A LINE NUMBER. NOT DIRECT.
00228C  1  20 82 23     	JSR	CRUNCH		;COMPACTIFY.
00228F  1  4C B5 25     	JMP	GONE		;EXECUTE IT.
002292  1  20 3D 27     MAIN1:	JSR	LINGET		;READ LINE NUMBER INTO "LINNUM".
002295  1  20 82 23     	JSR	CRUNCH
002298  1  84 0F        	STY	COUNT		;RETAIN CHARACTER COUNT.
00229A  1  20 0A 24     	JSR	FNDLIN
00229D  1  90 44        	BCC	NODEL		;NO MATCH, SO DON'T DELETE.
00229F  1  A0 01        	LDY	#1
0022A1  1  B1 AE        	LDADY	LOWTR
0022A3  1  85 72        	STA	INDEX1+1
0022A5  1  A5 7C        	LDA	VARTAB
0022A7  1  85 71        	STA	INDEX1
0022A9  1  A5 AF        	LDA	LOWTR+1		;SET TRANSFER TO.
0022AB  1  85 74        	STA	INDEX2+1
0022AD  1  A5 AE        	LDA	LOWTR
0022AF  1  88           	DEY
0022B0  1  F1 AE        	SBCDY	LOWTR		;COMPUTE NEGATIVE LENGTH.
0022B2  1  18           	CLC
0022B3  1  65 7C        	ADC	VARTAB		;COMPUTE NEW VARTAB.
0022B5  1  85 7C        	STA	VARTAB
0022B7  1  85 73        	STA	INDEX2		;SET LOW OF TRANS TO.
0022B9  1  A5 7D        	LDA	VARTAB+1
0022BB  1  69 FF        	ADC	#255
0022BD  1  85 7D        	STA	VARTAB+1	;COMPUTE HIGH OF VARTAB.
0022BF  1  E5 AF        	SBC	LOWTR+1		;COMPUTE NUMBER OF BLOCKS TO MOVE.
0022C1  1  AA           	TAX
0022C2  1  38           	SEC
0022C3  1  A5 AE        	LDA	LOWTR
0022C5  1  E5 7C        	SBC	VARTAB		;COMPUTE OFFSET.
0022C7  1  A8           	TAY
0022C8  1  B0 03        	BCS	QDECT1		;IF VARTAB.LE.LOWTR,
0022CA  1  E8           	INX			;DECR DUE TO CARRY, AND
0022CB  1  C6 74        	DEC	INDEX2+1	;DECREMENT STORE SO CARRY WORKS.
0022CD  1  18           QDECT1: CLC
0022CE  1  65 71        	ADC	INDEX1
0022D0  1  90 03        	BCC	MLOOP
0022D2  1  C6 72        	DEC	INDEX1+1
0022D4  1  18           	CLC			;FOR LATER ADCQ
0022D5  1  B1 71        MLOOP:	LDADY	INDEX1
0022D7  1  91 73        	STADY	INDEX2
0022D9  1  C8           	INY
0022DA  1  D0 F9        	BNE	MLOOP		;BLOCK DONE?
0022DC  1  E6 72        	INC	INDEX1+1
0022DE  1  E6 74        	INC	INDEX2+1
0022E0  1  CA           	DEX
0022E1  1  D0 F2        	BNE	MLOOP		;DO ANOTHER BLOCK. ALWAYS.
0022E3  1  20 50 24     NODEL:	JSR	RUNC		;RESET ALL VARIABLE INFO SO GARBAGE
0022E6  1               				;COLLECTION CAUSED BY REASON WILL WORK
0022E6  1  20 1E 23     	JSR	LNKPRG		;FIX UP THE LINKS
0022E9  1  A5 1D        	LDA	BUF		;SEE IF ANYTHNG THERE
0022EB  1  F0 8C        	BEQ	MAIN
0022ED  1  18           	CLC
0022EE  1  A5 7C        	LDA	VARTAB
0022F0  1  85 A9        	STA	HIGHTR		;SETUP HIGHTR.
0022F2  1  65 0F        	ADC	COUNT		;ADD LENGTH OF LINE TO INSERT.
0022F4  1  85 A7        	STA	HIGHDS		;THIS GIVES DEST ADDR.
0022F6  1  A4 7D        	LDY	VARTAB+1
0022F8  1  84 AA        	STY	HIGHTR+1	;SAME FOR HIGH ORDERS.
0022FA  1  90 01        	BCC	NODELC
0022FC  1  C8           	INY
0022FD  1  84 A8        NODELC: STY	HIGHDS+1
0022FF  1  20 CF 21     	JSR	BLTU
002302  1               .IF	BUFPAG <> 0
002302  1               	LDWD	LINNUM		;POSITION THE BINARY LINE NUMBER
002302  1               	STWD	BUF-2		;IN FRONT OF BUF
002302  1               .ENDIF
002302  1  A5 80 A4 81  	LDWD	STREND
002306  1  85 7C 84 7D  	STWD	VARTAB
00230A  1  A4 0F        	LDY	COUNT
00230C  1  88           	DEY
00230D  1  B9 19 00     STOLOP: LDA	BUF-4,Y
002310  1  91 AE        	STADY	LOWTR
002312  1  88           	DEY
002313  1  10 F8        	BPL	STOLOP
002315  1  20 50 24     FINI:	JSR	RUNC		;DO CLEAR & SET UP STACK.
002318  1               				;AND SET [TXTPTR] TO [TXTTAB]-1.
002318  1  20 1E 23     	JSR	LNKPRG		;FIX UP PROGRAM LINKS
00231B  1  4C 79 22     	JMP	MAIN
00231E  1  A5 7A A4 7B  LNKPRG: LDWD	TXTTAB		;SET [INDEX] TO [TXTTAB].
002322  1  85 71 84 72  	STWD	INDEX
002326  1  18           	CLC
002327  1               ;
002327  1               ; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
002327  1               ; UP ALL THE LINKS. THE END OF EACH LINE IS FOUND
002327  1               ; BY SEARCHING FOR THE ZERO AT THE END.
002327  1               ; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM.
002327  1               ;
002327  1  A0 01        CHEAD:	LDY	#1
002329  1  B1 71        	LDADY	INDEX		;ARRIVED AT DOUBLE ZEROES?
00232B  1  F0 1D        	BEQ	LNKRTS
00232D  1  A0 04        	LDY	#4
00232F  1  C8           CZLOOP: INY			;THERE IS AT LEAST ONE BYTE.
002330  1  B1 71        	LDADY	INDEX
002332  1  D0 FB        	BNE	CZLOOP		;NO, CONTINUE SEARCHING.
002334  1  C8           	INY			;GO ONE BEYOND.
002335  1  98           	TYA
002336  1  65 71        	ADC	INDEX
002338  1  AA           	TAX
002339  1  A0 00        	LDY	#0
00233B  1  91 71        	STADY	INDEX
00233D  1  A5 72        	LDA	INDEX+1
00233F  1  69 00        	ADC	#0
002341  1  C8           	INY
002342  1  91 71        	STADY	INDEX
002344  1  86 71        	STX	INDEX
002346  1  85 72 90 DD  	STA	INDEX+1
00234A  1               	BCCA	CHEAD		;ALWAYS BRANCHES.
00234A  1  60           LNKRTS: RTS
00234B  1               ;
00234B  1               ; THIS IS THE LINE INPUT ROUTINE.
00234B  1               ; IT READS CHARACTERS INTO BUF USING BACKARROW (UNDERSCORE, OR
00234B  1               ; SHIFT O) AS THE DELETE CHARACTER AND @ AS THE
00234B  1               ; LINE DELETE CHARACTER. IF MORE THAN BUFLEN CHARACTERS
00234B  1               ; ARE TYPED, NO ECHOING IS DONE UNTIL A BACKARROW OR @ OR CR
00234B  1               ; IS TYPED. CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
00234B  1               ; THE ROUTINE IS ENTERED AT INLIN.
00234B  1               ;
00234B  1               .IF	REALIO-4 = 0
00234B  1               INLIN:	LDX	#128		;NO PROMPT CHARACTER
00234B  1               	STX	CQPRMP
00234B  1               	JSR	CQINLN		;GET A LINE ONTO PAGE 2
00234B  1               	CPX	#BUFLEN-1
00234B  1               	BCS	GDBUFS		;NOT TOO MANY CHARACTERS
00234B  1               	LDX	#BUFLEN-1
00234B  1               GDBUFS: LDA	#0		;PUT A ZERO AT THE END
00234B  1               	STA	BUF,X
00234B  1               	TXA
00234B  1               	BEQ	NOCHR
00234B  1               LOPBHT: LDA	BUF-1,X
00234B  1               	AND	#127
00234B  1               	STA	BUF-1,X
00234B  1               	DEX
00234B  1               	BNE	LOPBHT
00234B  1               NOCHR:	LDA	#0
00234B  1               	LDXYI	BUF-1		;POINT AT THE BEGINNING
00234B  1               	RTS
00234B  1               .ENDIF
00234B  1               .IF	REALIO-4 <> 0
00234B  1               .IF	REALIO-3 <> 0
00234B  1               LINLIN:
00234B  1               .IF	REALIO-2 = 0
00234B  1               	JSR	OUTDO		;ECHO IT.
00234B  1               .ENDIF
00234B  1  CA           	DEX			;BACKARROW SO BACKUP PNTR AND
00234C  1  10 05        	BPL	INLINC		;GET ANOTHER IF COUNT IS POSITIVE.
00234E  1               INLINN:
00234E  1               .IF	REALIO-2 = 0
00234E  1               	JSR	OUTDO		;PRINT THE @ OR A SECOND BACKARROW
00234E  1               				;IF THERE WERE TOO MANY.
00234E  1               .ENDIF
00234E  1  20 44 28     	JSR	CRDO
002351  1               .ENDIF
002351  1  A2 00        INLIN:	LDX	#0
002353  1  20 7E 23     INLINC: JSR	INCHR		;GET A CHARACTER.
002356  1               .IF	REALIO-3 <> 0
002356  1  C9 07        	CMP	#7		;IS IT BOB ALBRECHT RINGING THE BELL
002358  1               				;FOR SCHOOL KIDS?
002358  1  F0 14        	BEQ	GOODCH
00235A  1               .ENDIF
00235A  1  C9 0D        	CMP	#13		;CARRIAGE RETURN?
00235C  1  F0 1D        	BEQ	FININ1		;YES, FINISH UP.
00235E  1               .IF	REALIO-3 <> 0
00235E  1  C9 20        	CMP	#32		;CHECK FOR FUNNY CHARACTERS.
002360  1  90 F1        	BCC	INLINC
002362  1  C9 7D        	CMP	#125		;IS IT TILDA OR DELETE?
002364  1  B0 ED        	BCS	INLINC		;BIG BAD ONES TOO.
002366  1  C9 40        	CMP	#'@'		;LINE DELETE?
002368  1  F0 E4        	BEQ	INLINN		;YES.
00236A  1  C9 5F        	CMP	#'_'		;CHARACTER DELETE?
00236C  1  F0 DD        	BEQ	LINLIN		;YES.
00236E  1               .ENDIF
00236E  1               GOODCH:
00236E  1               .IF	REALIO-3 <> 0
00236E  1  E0 47        	CPX	#BUFLEN-1	;LEAVE ROOM FOR NULL.
002370  1               			;COMMO ASSURES US NEVER MORE THAN BUFLEN.
002370  1  B0 05        	BCS	OUTBEL
002372  1               .ENDIF
002372  1  95 1D        	STA	BUF,X
002374  1  E8           	INX
002375  1               .IF	REALIO-2 = 0
002375  1               	SKIP2
002375  1               .ENDIF
002375  1               .IF	REALIO-2 <> 0
002375  1  D0 DC        	BNE INLINC
002377  1               .ENDIF
002377  1               .IF	REALIO-3 <> 0
002377  1  A9 07        OUTBEL: LDA	#7
002379  1               .IF	REALIO <> 0
002379  1               	JSR	OUTDO		;ECHO IT.
002379  1               .ENDIF
002379  1  D0 D8        	BNE	INLINC		;CYCLE ALWAYS.
00237B  1               .ENDIF
00237B  1  4C 3E 28     FININ1: JMP	FININL		;GO TO FININL FAR, FAR AWAY.
00237E  1               .ENDIF
00237E  1               INCHR:
00237E  1               .IF	REALIO-3 = 0
00237E  1               	JSR	CQINCH		;FOR COMMODORE.
00237E  1               .ENDIF
00237E  1               .IF	REALIO-2 = 0
00237E  1               INCHRL: LDA	$FC00
00237E  1               	REPEAT	4,{NOP}
00237E  1               	LSR	A
00237E  1               	BCC	INCHRL
00237E  1               	LDA	$FC01	;GET THE CHARACTER.
00237E  1               	REPEAT	4,{NOP}
00237E  1               	AND	#127
00237E  1               .ENDIF
00237E  1               .IF	REALIO-1 = 0
00237E  1               	JSR	$1E5A		;1E5A FOR MOS TECH.
00237E  1               .ENDIF
00237E  1               .IF	REALIO-4 = 0
00237E  1               	JSR	CQINCH		;FD0C FOR APPLE COMPUTER.
00237E  1               	AND	#127
00237E  1               .ENDIF
00237E  1               .IF	REALIO = 0
00237E  1  20 8B 75     	SIM_INSIM		;GET A CHARACTER FROM SIMULATOR
002381  1               .ENDIF
002381  1               
002381  1               .IF	REALIO <> 0
002381  1               .IF	EXTIO <> 0
002381  1               	LDY	CHANNL		;CNT-O HAS NO EFFECT IF NOT FROM TERM.
002381  1               	BNE	INCRTS
002381  1               .ENDIF
002381  1               	CMP	#CONTW		;SUPPRESS OUTPUT CHARACTER (^W).
002381  1               	BNE	INCRTS		;NO, RETURN.
002381  1               	PHA
002381  1               	COM	CNTWFL		;COMPLEMENT ITS STATE.
002381  1               	PLA
002381  1               .ENDIF
002381  1  60           INCRTS: RTS			;END OF INCHR.
002382  1               
002382  1               ;
002382  1               ; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
002382  1               ; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
002382  1               ; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
002382  1               ; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
002382  1               ; RESERVED WORD LIST IN THE SAME ORDER THEY
002382  1               ; APPEAR IN STMDSP.
002382  1               ;
002382  1               BUFOFS .SET 0			;THE AMOUNT TO OFFSET THE LOW BYTE
002382  1               				;OF THE TEXT POINTER TO GET TO BUF
002382  1               				;AFTER TXTPTR HAS BEEN SETUP TO POINT INTO BUF
002382  1               .IF	BUFPAG <> 0
002382  1               BUFOFS .SET (BUF/256)*256
002382  1               .ENDIF
002382  1  A6 C9        CRUNCH: LDX	TXTPTR		;SET SOURCE POINTER.
002384  1  A0 04        	LDY	#4		;SET DESTINATION OFFSET.
002386  1  84 13        	STY	DORES		;ALLOW CRUNCHING.
002388  1  B5 00        KLOOP:	LDA	BUFOFS,X
00238A  1               .IF	REALIO-3 = 0
00238A  1               	BPL	CMPSPC		;GO LOOK AT SPACES.
00238A  1               	CMP	#PI		;PI??
00238A  1               	BEQ	STUFFH		;GO SAVE IT.
00238A  1               	INX			;SKIP NO PRINTING.
00238A  1               	BNE	KLOOP		;ALWAYS GOES.
00238A  1               .ENDIF
00238A  1  C9 20        CMPSPC: CMP	#' '		;IS IT A SPACE TO SAVE?
00238C  1  F0 36        	BEQ	STUFFH		;YES, GO SAVE IT.
00238E  1  85 0E        	STA	ENDCHR		;IF IT'S A QUOTE, THIS WILL
002390  1               				;STOP LOOP WHEN OTHER QUOTE APPEARS.
002390  1  C9 22        	CMP	#34		;QUOTE SIGN?
002392  1  F0 54        	BEQ	STRNG		;YES, DO SPECIAL STRING HANDLING.
002394  1  24 13        	BIT	DORES		;TEST FLAG.
002396  1  70 2C        	BVS	STUFFH		;NO CRUNCH, JUST STORE.
002398  1  C9 3F        	CMP	#'?'		;A QMARK?
00239A  1  D0 04        	BNE	KLOOP1
00239C  1  A9 95        	LDA	#PRINTK		;YES, STUFF A "PRINT" TOKEN.
00239E  1  D0 24        	BNE	STUFFH		;ALWAYS GO TO STUFFH.
0023A0  1  C9 30        KLOOP1: CMP	#'0'		;SKIP NUMERICS.
0023A2  1  90 04        	BCC	MUSTCR
0023A4  1  C9 3C        	CMP	#60		;":" AND ";" ARE ENTERED STRAIGHTAWAY.
0023A6  1  90 1C        	BCC	STUFFH
0023A8  1  84 C0        MUSTCR: STY	BUFPTR		;SAVE BUFFER POINTER.
0023AA  1  A0 00        	LDY	#0		;LOAD RESLST POINTER.
0023AC  1  84 0F        	STY	COUNT		;ALSO CLEAR COUNT.
0023AE  1  88           	DEY
0023AF  1  86 C9        	STX	TXTPTR		;SAVE TEXT POINTER FOR LATER USE.
0023B1  1  CA           	DEX
0023B2  1  C8           RESER:	INY
0023B3  1  E8           RESPUL: INX
0023B4  1  B5 00        RESCON: LDA	BUFOFS,X
0023B6  1  38           	SEC			;PREPARE TO SUBSTARCT.
0023B7  1  F9 84 20     	SBC	RESLST,Y	;CHARACTERS EQUAL?
0023BA  1  F0 F6        	BEQ	RESER		;YES, CONTINUE SEARCH.
0023BC  1  C9 80        	CMP	#128		;NO BUT MAYBE THE END IS HERE.
0023BE  1  D0 2F        	BNE	NTHIS		;NO, TRULY UNEQUAL.
0023C0  1  05 0F        	ORA	COUNT
0023C2  1  A4 C0        GETBPT: LDY	BUFPTR		;GET BUFFER PNTR.
0023C4  1  E8           STUFFH: INX
0023C5  1  C8           	INY
0023C6  1  99 18 00     	STA	BUF-5,Y
0023C9  1  B9 18 00     	LDA	BUF-5,Y
0023CC  1  F0 34        	BEQ	CRDONE		;NULL IMPLIES END OF LINE.
0023CE  1  38           	SEC			;PREPARE TO SUBSTARCT.
0023CF  1  E9 3A        	SBC	#':'		;IS IT A ":"?
0023D1  1  F0 04        	BEQ	COLIS		;YES, ALLOW CRUNCHING AGAIN.
0023D3  1  C9 49        	CMP	#DATATK-':'	;IS IT A DATATK?
0023D5  1  D0 02        	BNE	NODATT		;NO, SEE IF IT IS REM TOKEN.
0023D7  1  85 13        COLIS:	STA	DORES		;SETUP FLAG.
0023D9  1  38           NODATT: SEC			;PREP TO SBCQ
0023DA  1  E9 54        	SBC	#REMTK-':'	;REM ONLY STOPS ON NULL.
0023DC  1  D0 AA        	BNE	KLOOP		;NO, CONTINUE CRUNCHING.
0023DE  1  85 0E        	STA	ENDCHR		;REM STOPS ONLY ON NULL, NOT : OR ".
0023E0  1  B5 00        STR1:	LDA	BUFOFS,X
0023E2  1  F0 E0        	BEQ	STUFFH		;YES, END OF LINE, SO DONE.
0023E4  1  C5 0E        	CMP	ENDCHR		;END OF GOBBLE?
0023E6  1  F0 DC        	BEQ	STUFFH		;YES, DONE WITH STRING.
0023E8  1  C8           STRNG:	INY			;INCREMENT BUFFER POINTER.
0023E9  1  99 18 00     	STA	BUF-5,Y
0023EC  1  E8           	INX
0023ED  1  D0 F1        	BNE	STR1		;PROCESS NEXT CHARACTER.
0023EF  1  A6 C9        NTHIS:	LDX	TXTPTR		;RESTORE TEXT POINTER.
0023F1  1  E6 0F        	INC	COUNT		;INCREMENT RES WORD COUNT.
0023F3  1  C8           NTHIS1: INY
0023F4  1  B9 83 20     	LDA	RESLST-1,Y 	;GET RES CHARACTER.
0023F7  1  10 FA        	BPL	NTHIS1		;END OF ENTRY?
0023F9  1  B9 84 20     	LDA	RESLST,Y 	;YES. IS IT THE END?
0023FC  1  D0 B6        	BNE	RESCON		;NO, TRY THE NEXT WORD.
0023FE  1  B5 00        	LDA	BUFOFS,X	;YES, END OF TABLE. GET 1ST CHR.
002400  1  10 C0        	BPL	GETBPT		;STORE IT AWAY (ALWAYS BRANCHES).
002402  1  99 1A 00     CRDONE: STA	BUF-3,Y 	;SO THAT IF THIS IS A DIR STATEMENT
002405  1               				;ITS END WILL LOOK LIKE END OF PROGRAM.
002405  1               .IF	((BUF+BUFLEN)/256)-((BUF-1)/256) <> 0
002405  1               	DEC	TXTPTR+1
002405  1               .ENDIF
002405  1               ;	LDAI	(BUF&255)-1	;LGB - the original line
002405  1  A9 1C        	LDA	#.LOBYTE(BUF-1)	;MAKE TXTPTR POINT TO
002407  1  85 C9        	STA	TXTPTR		;CRUNCHED LINE.
002409  1  60           LISTRT: RTS			;RETURN TO CALLER.
00240A  1               ;
00240A  1               ; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
00240A  1               ; WHOSE NUMBER IS PASSED IN "LINNUM".
00240A  1               ; THERE ARE TWO POSSIBLE RETURNS:
00240A  1               ;
00240A  1               ;	1) CARRY SET.
00240A  1               ;	   LOWTR POINTS TO THE LINK FIELD IN THE LINE
00240A  1               ;	   WHICH IS THE ONE SEARCHED FOR.
00240A  1               ;
00240A  1               ;	2) CARRY NOT SET.
00240A  1               ;	   LINE NOT FOUND. [LOWTR] POINTS TO THE LINE IN THE
00240A  1               ;	   PROGRAM GREATER THAN THE ONE SOUGHT AFTER.
00240A  1               ;
00240A  1  A5 7A A6 7B  FNDLIN: LDWX	TXTTAB		;LOAD [X,A] WITH [TXTTAB]
00240E  1  A0 01        FNDLNC: LDY	#1
002410  1  85 AE 86 AF  	STWX	LOWTR		;STORE [X,A] INTO LOWTR
002414  1  B1 AE        	LDADY	LOWTR		;SEE IF LINK IS 0
002416  1  F0 1F        	BEQ	FLINRT
002418  1  C8           	INY
002419  1  C8           	INY
00241A  1  A5 1C        	LDA	LINNUM+1	;COMP HIGH ORDERS OF LINE NUMBERS.
00241C  1  D1 AE        	CMPDY	LOWTR
00241E  1  90 18        	BCC	FLNRTS		;NO SUCH LINE NUMBER.
002420  1  F0 03        	BEQ	FNDLO1
002422  1  88           	DEY
002423  1  D0 09        	BNE	AFFRTS		;ALWAYS BRANCH.
002425  1  A5 1B        FNDLO1: LDA	LINNUM
002427  1  88           	DEY
002428  1  D1 AE        	CMPDY	LOWTR		;COMPARE LOW ORDERS.
00242A  1  90 0C        	BCC	FLNRTS		;NO SUCH NUMBER.
00242C  1  F0 0A        	BEQ	FLNRTS		;GO TIT.
00242E  1  88           AFFRTS: DEY
00242F  1  B1 AE        	LDADY	LOWTR		;FETCH LINK.
002431  1  AA           	TAX
002432  1  88           	DEY
002433  1  B1 AE        	LDADY	LOWTR
002435  1  B0 D7        	BCS	FNDLNC		;ALWAYS BRANCHES.
002437  1  18           FLINRT: CLC			;C MAY BE HIGH.
002438  1  60           FLNRTS: RTS			;RETURN TO CALLER.
002439  1               ;
002439  1               ; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
002439  1               ; AS VARIABLE SPACE.
002439  1               ;
002439  1  D0 FD        SCRATH: BNE	FLNRTS		;MAKE SURE THERE IS A TERMINATOR.
00243B  1  A9 00        SCRTCH: LDA	#0		;GET A CLEARER.
00243D  1  A8           	TAY			;SET UP INDEX.
00243E  1  91 7A        	STADY	TXTTAB		;CLEAR	FIRST LINK.
002440  1  C8           	INY
002441  1  91 7A        	STADY	TXTTAB
002443  1  A5 7A        	LDA	TXTTAB
002445  1  18           	CLC
002446  1  69 02        	ADC	#2
002448  1  85 7C        	STA	VARTAB		;SETUP [VARTAB].
00244A  1  A5 7B        	LDA	TXTTAB+1
00244C  1  69 00        	ADC	#0
00244E  1  85 7D        	STA	VARTAB+1
002450  1  20 82 24     RUNC:	JSR	STXTPT
002453  1  A9 00        	LDA	#0		;SET ZERO FLAG
002455  1               ;
002455  1               ; THIS CODE IS FOR THE CLEAR COMMAND.
002455  1               ;
002455  1  D0 2A        CLEAR:	BNE	STKRTS		;SYNTAX ERROR IF NO TERMINATOR.
002457  1               ;
002457  1               ; CLEAR INITIALIZES THE VARIABLE AND
002457  1               ; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
002457  1               ; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO "STKINI"
002457  1               ; WHICH RESETS THE STACK.
002457  1               ;
002457  1  A5 86 A4 87  CLEARC: LDWD	MEMSIZ		;FREE UP STRING SPACE.
00245B  1  85 82 84 83  	STWD	FRETOP
00245F  1               .IF	EXTIO <> 0
00245F  1               	JSR	CQCALL		;CLOSE ALL OPEN FILES.
00245F  1               .ENDIF
00245F  1  A5 7C A4 7D  	LDWD	VARTAB		;LIBERATE THE
002463  1  85 7E 84 7F  	STWD	ARYTAB		;VARIABLES AND
002467  1  85 80 84 81  	STWD	STREND		;ARRAYS.
00246B  1  20 EE 25     FLOAD:	JSR	RESTOR		;RESTORE DATA.
00246E  1               ;
00246E  1               ; STKINI RESETS THE STACK POINTER ELIMINATING
00246E  1               ; GOSUB AND FOR CONTEXT. STRING TEMPORARIES ARE FREED
00246E  1               ; UP, SUBFLG IS RESET. CONTINUING IS PROHIBITED.
00246E  1               ; AND A DUMMY ENTRY IS LEFT AT THE BOTTOM OF THE STACK SO "FNDFOR" WILL ALWAYS
00246E  1               ; FIND A NON-"FOR" ENTRY AT THE BOTTOM OF THE STACK.
00246E  1               ;
00246E  1  A2 68        STKINI: LDX	#TEMPST		;INITIALIZE STRING TEMPORARIES.
002470  1  86 65        	STX	TEMPPT
002472  1  68           	PLA			;SETUP RETURN ADDRESS.
002473  1  A8           	TAY
002474  1  68           	PLA
002475  1  A2 FE        	LDX	#STKEND-257
002477  1  9A           	TXS
002478  1  48           	PHA
002479  1  98           	TYA
00247A  1  48           	PHA
00247B  1  A9 00        	LDA	#0
00247D  1  85 8D        	STA	OLDTXT+1	;DISALLOWING CONTINUING
00247F  1  85 14        	STA	SUBFLG		;ALLOW SUBSCRIPTS.
002481  1  60           STKRTS: RTS
002482  1               
002482  1  18           STXTPT: CLC
002483  1  A5 7A        	LDA	TXTTAB
002485  1  69 FF        	ADC	#255
002487  1  85 C9        	STA	TXTPTR
002489  1  A5 7B        	LDA	TXTTAB+1
00248B  1  69 FF        	ADC	#255
00248D  1  85 CA        	STA	TXTPTR+1	;SETUP TEXT POINTER.
00248F  1  60           	RTS
002490  1               ; PAGE
002490  1               ; SUBTTL	THE "LIST" COMMAND.
002490  1               
002490  1  90 06        LIST:	BCC	GOLST		;IT IS A DIGIT.
002492  1  F0 04        	BEQ	GOLST		;IT IS A TERMINATOR.
002494  1  C9 A4        	CMP	#MINUTK		;DASH PRECEDING?
002496  1  D0 E9        	BNE	STKRTS		;NO, SO SYNTAX ERROR.
002498  1  20 3D 27     GOLST:	JSR	LINGET		;GET LINE NUMBER INTO NUMLIN.
00249B  1  20 0A 24     	JSR	FNDLIN		;FIND LINE .GE. [NUMLIN].
00249E  1  20 C8 00     	JSR	CHRGOT		;GET LAST CHARACTER.
0024A1  1  F0 0C        	BEQ	LSTEND		;IF END OF LINE, # IS THE END.
0024A3  1  C9 A4        	CMP	#MINUTK		;DASH?
0024A5  1  D0 91        	BNE	FLNRTS		;IF NOT, SYNTAX ERROR.
0024A7  1  20 C2 00     	JSR	CHRGET		;GET NEXT CHAR.
0024AA  1  20 3D 27     	JSR	LINGET		;GET END #.
0024AD  1  D0 89        	BNE	FLNRTS		;IF NOT TERMINATOR, ERROR.
0024AF  1  68           LSTEND: PLA
0024B0  1  68           	PLA			;GET RID OF "NEWSTT" RTS ADDR.
0024B1  1  A5 1B        	LDA	LINNUM		;SEE IF IT WAS EXISTENT.
0024B3  1  05 1C        	ORA	LINNUM+1
0024B5  1  D0 06        	BNE	LIST4		;IT WAS TYPED.
0024B7  1  A9 FF        	LDA	#255
0024B9  1  85 1B        	STA	LINNUM
0024BB  1  85 1C        	STA	LINNUM+1	;MAKE IT HUGE.
0024BD  1  A0 01        LIST4:	LDY	#1
0024BF  1               .IF	REALIO-3 = 0
0024BF  1               	STY	DORES
0024BF  1               .ENDIF
0024BF  1  B1 AE        	LDADY	LOWTR		;IS LINK ZERO?
0024C1  1  F0 36        	BEQ	GRODY		;YES, GO TO READY.
0024C3  1               .IF	REALIO <> 0
0024C3  1               	JSR	ISCNTC		;LISTEN FOR CONT-C.
0024C3  1               .ENDIF
0024C3  1  20 44 28     	JSR	CRDO		;PRINT CRLF TO START WITH.
0024C6  1  C8           	INY
0024C7  1  B1 AE        	LDADY	LOWTR
0024C9  1  AA           	TAX
0024CA  1  C8           	INY
0024CB  1  B1 AE        	LDADY	LOWTR		;GET LINE NUMBER.
0024CD  1  C5 1C        	CMP	LINNUM+1	;SEE IF BEYOND LAST.
0024CF  1  D0 04        	BNE	TSTDUN		;GO DETERMINE RELATION.
0024D1  1  E4 1B        	CPX	LINNUM		;WAS EQUAL SO TEST LOW ORDER.
0024D3  1  F0 02        	BEQ	TYPLIN		;EQUAL, SO LIST IT.
0024D5  1  B0 22        TSTDUN: BCS	GRODY		;IF LINE IS GR THAN LAST, THEN DUNE.
0024D7  1  84 98        TYPLIN: STY	LSTPNT
0024D9  1  20 4B 3A     	JSR	LINPRT		;PRINT AS INT WITHOUT LEADING SPACE.
0024DC  1  A9 20        	LDA	#' '		;ALWAYS PRINT SPACE AFTER NUMBER.
0024DE  1  A4 98        PRIT4:	LDY	LSTPNT		;GET POINTER TO LINE BACK.
0024E0  1  29 7F        	AND	#127
0024E2  1  20 BC 28     PLOOP:	JSR	OUTDO		;PRINT CHAR.
0024E5  1               .IF	REALIO-3 = 0
0024E5  1               	CMP	#34
0024E5  1               	BNE	PLOOP1
0024E5  1               	COM	DORES		;IF QUOTE, COMPLEMENT FLAG.
0024E5  1               .ENDIF
0024E5  1  C8           PLOOP1: INY
0024E6  1  F0 11        	BEQ	GRODY		;IF WE HAVE PRINTED 256 CHARACTERS
0024E8  1               				;THE PROGRAM MUST BE MISFORMATED IN
0024E8  1               				;MEMORY DUE TO A BAD LOAD OR BAD
0024E8  1               				;HARDWARE. LET THE GUY RECOVER
0024E8  1  B1 AE        	LDADY	LOWTR		;GET NEXT CHAR. IS IT ZERO?
0024EA  1  D0 10        	BNE	QPLOP		;YES. END OF LINE.
0024EC  1  A8           	TAY
0024ED  1  B1 AE        	LDADY	LOWTR
0024EF  1  AA           	TAX
0024F0  1  C8           	INY
0024F1  1  B1 AE        	LDADY	LOWTR
0024F3  1  86 AE        	STX	LOWTR
0024F5  1  85 AF        	STA	LOWTR+1
0024F7  1  D0 C4        	BNE	LIST4		;BRANCH IF SOMETHING TO LIST.
0024F9  1  4C 72 22     GRODY:	JMP	READY
0024FC  1               				;IS IT A TOKEN?
0024FC  1  10 E4        QPLOP:	BPL	PLOOP		;NO, HEAD FOR PRINTER.
0024FE  1               .IF	REALIO-3 = 0
0024FE  1               	CMP	#PI
0024FE  1               	BEQ	PLOOP
0024FE  1               	BIT	DORES		;INSIDE QUOTE MARKS?
0024FE  1               	BMI	PLOOP		;YES, JUST TYPE THE CHARACTER.
0024FE  1               .ENDIF
0024FE  1  38           	SEC
0024FF  1  E9 7F        	SBC	#127		;GET RID OF SIGN BIT AND ADD 1.
002501  1  AA           	TAX			;MAKE IT A COUNTER.
002502  1  84 98        	STY	LSTPNT		;SAVE POINTER TO LINE.
002504  1  A0 FF        	LDY	#255		;LOOK AT RES'D WORD LIST.
002506  1  CA           RESRCH: DEX			;IS THIS THE RES'D WORD?
002507  1  F0 08        	BEQ	PRIT3		;YES, GO TOSS IT UP..
002509  1  C8           RESCR1: INY
00250A  1  B9 84 20     	LDA	RESLST,Y 	;END OF ENTRY?
00250D  1  10 FA        	BPL	RESCR1		;NO, CONTINUE PASSING.
00250F  1  30 F5        	BMI	RESRCH
002511  1  C8           PRIT3:	INY
002512  1  B9 84 20     	LDA	RESLST,Y
002515  1  30 C7        	BMI	PRIT4		;END OF RESERVED WORD.
002517  1  20 BC 28     	JSR	OUTDO		;PRINT IT.
00251A  1  D0 F5        	BNE	PRIT3		;END OF ENTRY? NO, TYPE REST.
00251C  1               ; PAGE
00251C  1               ; SUBTTL THE "FOR" STATEMENT.
00251C  1               ;
00251C  1               ; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
00251C  1               ;
00251C  1               ; LOW ADDRESS
00251C  1               ;	TOKEN (FORTK) 1 BYTE
00251C  1               ;	A POINTER TO THE LOOP VARIABLE 2 BYTES
00251C  1               ;	THE STEP 4+ADDPRC BYTES
00251C  1               ;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
00251C  1               ;	THE UPPER VALUE 4+ADDPRC BYTES
00251C  1               ;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
00251C  1               ;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
00251C  1               ; HIGH ADDRESS
00251C  1               ;
00251C  1               ; TOTAL 16+2*ADDPRC BYTES.
00251C  1               ;
00251C  1               
00251C  1  A9 80        FOR:	LDA	#128		;DON'T RECOGNIZE
00251E  1  85 14        	STA	SUBFLG		;SUBSCRIPTED VARIABLES.
002520  1  20 77 27     	JSR	LET		;READ THE VARIABLE AND ASSIGN IT
002523  1               				;THE CORRECT INITIAL VALUE AND STORE
002523  1               				;A POINTER TO THE VARIABLE IN VARPNT.
002523  1  20 A1 21     	JSR	FNDFOR		;PNTR IS IN VARPNT, AND FORPNT.
002526  1  D0 05        	BNE	NOTOL		;IF NO MATCH, DON'T ELIMINATE ANYTHING.
002528  1  8A           	TXA			;MAKE IT ARITHMETICAL.
002529  1  69 0F        	ADC	#FORSIZ-3	;ELIMINATE ALMOST ALL.
00252B  1  AA           	TAX			;NOTE C=1, THEN PLA, PLA.
00252C  1  9A           	TXS			;MANIFEST.
00252D  1  68           NOTOL:	PLA			;GET RID OF NEWSTT RETURN ADDRESS
00252E  1  68           	PLA			;IN CASE THIS IS A TOTALLY NEW ENTRY.
00252F  1  A9 09        	LDA	#8+ADDPRC
002531  1  20 12 22     	JSR	GETSTK		;MAKE SURE 16 BYTES ARE AVAILABLE.
002534  1  20 D8 26     	JSR	DATAN		;GET A COUNT IN [Y] OF THE NUMBER OF
002537  1               				;CHACRACTERS LEFT IN THE "FOR" STATEMENT
002537  1               				;[TXTPTR] IS UNAFFECTED.
002537  1  18           	CLC			;PREP TO ADD.
002538  1  98           	TYA			;SAVE IT FOR PUSHING.
002539  1  65 C9        	ADC	TXTPTR
00253B  1  48           	PHA
00253C  1  A5 CA        	LDA	TXTPTR+1
00253E  1  69 00        	ADC	#0
002540  1  48           	PHA
002541  1  A5 89 48 A5  	PSHWD	CURLIN		;PUT LINE NUMBER ON STACK.
002545  1  88 48        
002547  1  A9 9D 20 05  	SYNCHK	TOTK		;"TO" IS NECESSARY.
00254B  1  2C           
00254C  1  20 AC 2A     	JSR	CHKNUM		;VALUE MUST BE A NUMBER.
00254F  1  20 A9 2A     	JSR	FRMNUM		;GET UPPER VALUE INTO FAC.
002552  1  A5 B5        	LDA	FACSGN		;PACK FAC.
002554  1  09 7F        	ORA	#127
002556  1  25 B1        	AND	FACHO
002558  1  85 B1        	STA	FACHO		;SET PACKED SIGN BIT.
00255A  1  A9 65 A0 25  	LDWDI	LDFONE
00255E  1  85 71 84 72  	STWD	INDEX1
002562  1  4C 62 2B     	JMP	FORPSH		;PUT FAC ONTO STACK, PACKED.
002565  1  A9 3A A0 36  LDFONE: LDWDI	FONE		;PUT 1.0 INTO FAC.
002569  1  20 20 38     	JSR	MOVFM
00256C  1  20 C8 00     	JSR	CHRGOT
00256F  1  C9 A2        	CMP	#STEPTK		;A STEP IS GIVEN?
002571  1  D0 06        	BNE	ONEON		;NO. ASSUME 1.0.
002573  1  20 C2 00     	JSR	CHRGET		;YES. ADVANCE POINTER.
002576  1  20 A9 2A     	JSR	FRMNUM		;READ THE STEP.
002579  1  20 A9 38     ONEON:	JSR	SIGN		;GET SIGN IN ACCA.
00257C  1  20 57 2B     	JSR	PUSHF		;PUSH FAC ONTO STACK (THRU A).
00257F  1  A5 99 48 A5  	PSHWD	FORPNT		;PUT PNTR TO VARIABLE ON STACK.
002583  1  98 48        
002585  1  A9 81        NXTCON: LDA	#FORTK		;PUT A FORTK ONTO STACK.
002587  1  48           	PHA
002588  1               ;	BNEA	NEWSTT		;SIMULATE BNE TO NEWSTT. JUST FALL IN.
002588  1               ; PAGE
002588  1               ; SUBTTL	NEW STATEMENT FETCHER.
002588  1               ;
002588  1               ; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY TXTPTR
002588  1               ; IS ":" OR END-OF-LINE. THE ADDRESS OF THIS LOC IS LEFT
002588  1               ; ON THE STACK WHEN A STATEMENT IS EXECUTED SO THAT
002588  1               ; IT CAN MERELY DO A RTS WHEN IT IS DONE.
002588  1               ;
002588  1               NEWSTT:
002588  1               .IF	REALIO <> 0
002588  1               	JSR	ISCNTC		;LISTEN FOR CONTROL-C.
002588  1               .ENDIF
002588  1  A5 C9 A4 CA  	LDWD	TXTPTR		;LOOK AT CURRENT CHARACTER.
00258C  1               .IF	BUFPAG <> 0
00258C  1               	CPY	#BUFPAG		;SEE IF IT WAS DIRECT BY CHECK FOR BUF'S PAGE NUMBER
00258C  1               .ENDIF
00258C  1  F0 06        	BEQ	DIRCON
00258E  1  85 8C 84 8D  	STWD	OLDTXT		;SAVE IN CASE OF RESTART BY INPUT.
002592  1               .IF	BUFPAG <> 0
002592  1               DIRCON:
002592  1               .ENDIF
002592  1  A0 00        	LDY	#0
002594  1               .IF	BUFPAG = 0
002594  1               DIRCON:
002594  1               .ENDIF
002594  1  B1 C9        	LDADY	TXTPTR
002596  1  D0 40        	BNE	MORSTS		;NOT NULL -- CHECK WHAT IT IS
002598  1  A0 02        	LDY	#2		;LOOK AT LINK.
00259A  1  B1 C9        	LDADY	TXTPTR		;IS LINK 0?
00259C  1  18           	CLC		;CLEAR CARRY FOR ENDCON AND MATH THAT FOLLOWS
00259D  1  D0 03 4C 16  	JEQ	ENDCON		;YES - RAN OFF THE END.
0025A1  1  26           
0025A2  1  C8           	INY			;PUT LINE NUMBER IN CURLIN.
0025A3  1  B1 C9        	LDADY	TXTPTR
0025A5  1  85 88        	STA	CURLIN
0025A7  1  C8           	INY
0025A8  1  B1 C9        	LDADY	TXTPTR
0025AA  1  85 89        	STA	CURLIN+1
0025AC  1  98           	TYA
0025AD  1  65 C9        	ADC	TXTPTR
0025AF  1  85 C9        	STA	TXTPTR
0025B1  1  90 02        	BCC	GONE
0025B3  1  E6 CA        	INC	TXTPTR+1
0025B5  1  20 C2 00     GONE:	JSR	CHRGET		;GET THE STATEMENT TYPE.
0025B8  1  20 BE 25     	JSR	GONE3
0025BB  1  4C 88 25     	JMP	NEWSTT
0025BE  1  F0 3C        GONE3:	BEQ	ISCRTS		;IF TERMINATOR, TRY AGAIN.
0025C0  1               				;NO NEED TO SET UP CARRY SINCE IT WILL
0025C0  1               				;BE ON IF NON-NUMERIC AND NUMERICS
0025C0  1               				;WILL CAUSE A SYNTAX ERROR LIKE THEY SHOULD
0025C0  1  E9 80        GONE2:	SBC	#ENDTK		;" ON ... GOTO AND GOSUB" COME HERE.
0025C2  1  90 11        	BCC	GLET
0025C4  1  C9 1C        	CMP	#SCRATK-ENDTK+1
0025C6  1  B0 17        	BCS	SNERRX		;SOME RES'D WORD BUT NOT
0025C8  1               				;A STATEMENT RES'D WORD.
0025C8  1  0A           	ASL	A 		;MULTIPLY BY TWO.
0025C9  1  A8           	TAY			;MAKE AN INDEX.
0025CA  1  B9 01 20     	LDA	STMDSP+1,Y
0025CD  1  48           	PHA
0025CE  1  B9 00 20     	LDA	STMDSP,Y
0025D1  1  48           	PHA			;PUT DISP ADDR ONTO STACK.
0025D2  1  4C C2 00     	JMP	CHRGET
0025D5  1  4C 77 27     GLET:	JMP	LET		;MUST BE A LET
0025D8  1  C9 3A        MORSTS: CMP	#':'
0025DA  1  F0 D9        	BEQ	GONE		;IF A ":" CONTINUE STATEMENT
0025DC  1  4C 0E 2C     SNERR1: JMP	SNERR		;NEITHER 0 OR ":" SO SYNTAX ERROR
0025DF  1  C9 44        SNERRX: CMP	#GOTK-ENDTK
0025E1  1  D0 F9        	BNE	SNERR1
0025E3  1  20 C2 00     	JSR	CHRGET		;READ IN THE CHARACTER AFTER "GO "
0025E6  1  A9 9D 20 05  	SYNCHK	TOTK
0025EA  1  2C           
0025EB  1  4C 77 26     	JMP	GOTO
0025EE  1               ; PAGE
0025EE  1               ; SUBTTL	RESTORE,STOP,END,CONTINUE,NULL,CLEAR.
0025EE  1               
0025EE  1  38           RESTOR: SEC
0025EF  1  A5 7A        	LDA	TXTTAB
0025F1  1  E9 01        	SBC	#1
0025F3  1  A4 7B        	LDY	TXTTAB+1
0025F5  1  B0 01        	BCS	RESFIN
0025F7  1  88           	DEY
0025F8  1  85 90 84 91  RESFIN: STWD	DATPTR		;READ FINISHES COME TO "RESFIN".
0025FC  1  60           ISCRTS: RTS
0025FD  1               
0025FD  1               .IF	REALIO-1 = 0
0025FD  1               ISCNTC: LDA	#1
0025FD  1               	BIT	$1740
0025FD  1               	BMI	ISCRTS
0025FD  1               	LDX	#8
0025FD  1               	LDA	#3
0025FD  1               	CMP	#3
0025FD  1               .ENDIF
0025FD  1               .IF	REALIO-2 = 0
0025FD  1               ISCNTC: LDA	$FC00
0025FD  1               	REPEAT	4,{NOP}
0025FD  1               	LSR	A
0025FD  1               	BCC	ISCRTS
0025FD  1               	JSR	INCHR		;EAT CHAR THAT WAS TYPED
0025FD  1               	CMP	#3		;WAS IT A CONTROL-C??
0025FD  1               .ENDIF
0025FD  1               
0025FD  1               .IF	REALIO-4 = 0
0025FD  1               ISCNTC: LDA	$C000	;CHECK THE CHARACTER
0025FD  1               	CMP	#$83
0025FD  1               	BEQ	ISCCAP
0025FD  1               	RTS
0025FD  1               ISCCAP: JSR	INCHR
0025FD  1               	CMP	#$83
0025FD  1               .ENDIF
0025FD  1  B0 01        STOP:	BCS	STOPC		;MAKE [C] NONZERO AS A FLAG.
0025FF  1  18           END:	CLC
002600  1  D0 3B        STOPC:	BNE	CONTRT		;RETURN IF NOT CONT-C OR
002602  1               				;IF NO TERMINATOR FOR STOP OR END.
002602  1               				;[C]=0 SO WILL NOT PRINT "BREAK".
002602  1  A5 C9 A4 CA  	LDWD	TXTPTR
002606  1               .IF	BUFPAG <> 0
002606  1               	LDX	CURLIN+1
002606  1               	INX
002606  1               .ENDIF
002606  1  F0 0C        	BEQ	DIRIS
002608  1  85 8C 84 8D  	STWD	OLDTXT
00260C  1  A5 88 A4 89  STPEND: LDWD	CURLIN
002610  1  85 8A 84 8B  	STWD	OLDLIN
002614  1  68           DIRIS:	PLA			;POP OFF NEWSTT ADDR.
002615  1  68           	PLA
002616  1  A9 99 A0 21  ENDCON: LDWDI	BRKTXT
00261A  1               .IF	REALIO <> 0
00261A  1               	LDX	#0
00261A  1               	STX	CNTWFL
00261A  1               .ENDIF
00261A  1  90 03        	BCC	GORDY		;CARRY CLEAR SO DON'T PRINT "BREAK".
00261C  1  4C 67 22     	JMP	ERRFIN
00261F  1  4C 72 22     GORDY:	JMP	READY		;TYPE "READY".
002622  1               
002622  1               .IF	REALIO = 0
002622  1  68           DDT:	PLA			;GET RID OF NEWSTT RETURN.
002623  1  68           	PLA
002624  1               	;HRRZ	14,.JBDDT##	;LGB
002624  1               	;JRST	0(14)		;LGB
002624  1               .ENDIF
002624  1  D0 17        CONT:	BNE	CONTRT		;MAKE SURE THERE IS A TERMINATOR.
002626  1  A2 1E        	LDX	#ERRCN		;CONTINUE ERROR.
002628  1  A4 8D        	LDY	OLDTXT+1	;A STORED TXTPTR OF ZERO IS SETUP
00262A  1               				;BY STKINI AND INDICATES THERE IS
00262A  1               				;NOTHING TO CONTINUE.
00262A  1  D0 03 4C 4E  	JEQ	ERROR		;"STOP", "END", TYPING CRLF TO
00262E  1  22           
00262F  1               				;"INPUT" AND  ^C SETUP OLDTXT.
00262F  1  A5 8C        	LDA	OLDTXT
002631  1  85 C9 84 CA  	STWD	TXTPTR
002635  1  A5 8A A4 8B  	LDWD	OLDLIN
002639  1  85 88 84 89  	STWD	CURLIN
00263D  1  60           CONTRT: RTS			;RETURN TO CALLER.
00263E  1               
00263E  1               .IF	NULCMD <> 0
00263E  1  20 1B 34     NULL:	JSR	GETBYT
002641  1  D0 FA        	BNE	CONTRT		;MAKE SURE THERE IS TERMINATOR.
002643  1  E8           	INX
002644  1  E0 F0        	CPX	#240		;IS THE NUMBER REASONABLE?
002646  1  B0 04        	BCS	FCERR1		;"FUNCTION CALL" ERROR.
002648  1  CA           	DEX			;BACK -1
002649  1  86 17        	STX	NULCNT
00264B  1  60           	RTS
00264C  1  4C C5 2E     FCERR1: JMP	FCERR
00264F  1               .ENDIF
00264F  1               ; PAGE
00264F  1               ; SUBTTL	LOAD AND SAVE SUBROUTINES.
00264F  1               
00264F  1               .IF	REALIO-1 = 0		;KIM CASSETTE I/O
00264F  1               SAVE:	TSX			;SAVE STACK POINTER
00264F  1               	STX	INPFLG
00264F  1               	LDA	#STKEND-256-200
00264F  1               	STA	$F2		;SETUP DUMMY STACK FOR KIM MONITOR
00264F  1               	LDA	#254		;MAKE ID BYTE EQUAL TO FF HEX
00264F  1               	STA	$17F9		;STORE INTO KIM ID
00264F  1               	LDWD	TXTTAB		;START DUMPING FROM TXTTAB
00264F  1               	STWD	$17F5		;SETUP SAL,SAH
00264F  1               	LDWD	VARTAB		;STOP AT VARTAB
00264F  1               	STWD	$17F7		;SETUP EAL,EAH
00264F  1               	JMP	$1800
00264F  1               RETSAV: LDX	INPFLG		;RESORE THE REAL STACK POINTER
00264F  1               	TXS
00264F  1               	LDWDI	TAPMES		;SAY IT WAS DONE
00264F  1               	JMP	STROUT
00264F  1               GLOAD:	DT"LOADED"
00264F  1               .BYTE	0
00264F  1               TAPMES: DT"SAVED"
00264F  1               	ACRLF
00264F  1               .BYTE	0
00264F  1               PATSAV: BLOCK 20
00264F  1               LOAD:	LDWD	TXTTAB		;START DUMPING IN AT TXTTAB
00264F  1               	STWD	$17F5		;SETUP SAL,SAH
00264F  1               	LDA	#255
00264F  1               	STA	$17F9
00264F  1               	LDWDI	RTLOAD
00264F  1               	STWD	$1		;SET UP RETURN ADDRESS FOR LOAD
00264F  1               	JMP	$1873		;GO READ THE DATA IN
00264F  1               RTLOAD: LDX	#STKEND-256		;RESET THE STACK
00264F  1               	TXS
00264F  1               	LDWDI	READY
00264F  1               	STWD	$1
00264F  1               	LDWDI	GLOAD		;TELL HIM IT WORKED
00264F  1               	JSR	STROUT
00264F  1               	LDXY	$17ED		;GET LAST LOCATION
00264F  1               	TXA			;ITS ONE TOO BIG
00264F  1               	BNE	DECVRT		;DECREMENT [X,Y]
00264F  1               	NOP
00264F  1               DECVRT: NOP
00264F  1               	STXY	VARTAB		;SETUP NEW VARIABLE LOCATION
00264F  1               	JMP	FINI		;RELINK THE PROGRAM
00264F  1               .ENDIF
00264F  1               .IF	REALIO-4 = 0
00264F  1               SAVE:	SEC			;CALCLUATE PROGRAM SIZE IN POKER
00264F  1               	LDA	VARTAB
00264F  1               	SBC	TXTTAB
00264F  1               	STA	POKER
00264F  1               	LDA	VARTAB+1
00264F  1               	SBC	TXTTAB+1
00264F  1               	STA	POKER+1
00264F  1               	JSR	VARTIO
00264F  1               	JSR	CQCOUT		;WRITE PROGRAM SIZE [POKER]
00264F  1               	JSR	PROGIO
00264F  1               	JMP	CQCOUT		;WRITE PROGRAM.
00264F  1               
00264F  1               LOAD:	JSR	VARTIO
00264F  1               	JSR	CQCSIN		;READ SIZE OF PROGRAM INTO POKER
00264F  1               	CLC
00264F  1               	LDA	TXTTAB		;CALCULATE VARTAB FROM SIZE AND
00264F  1               	ADC	POKER		;TXTTAB
00264F  1               	STA	VARTAB
00264F  1               	LDA	TXTTAB+1
00264F  1               	ADC	POKER+1
00264F  1               	STA	VARTAB+1
00264F  1               	JSR	PROGIO
00264F  1               	JSR	CQCSIN		;READ PROGRAM.
00264F  1               	LDWDI	TPDONE
00264F  1               	JSR	STROUT
00264F  1               	JMP	FINI
00264F  1               
00264F  1               TPDONE: DT"LOADED"
00264F  1               .BYTE	0
00264F  1               
00264F  1               VARTIO: LDWDI	POKER
00264F  1               	STWD	$3C
00264F  1               	LDA	#POKER+2
00264F  1               	STWD	$3E
00264F  1               	RTS
00264F  1               PROGIO: LDWD	TXTTAB
00264F  1               	STWD	$3C
00264F  1               	LDWD	VARTAB
00264F  1               	STWD	$3E
00264F  1               	RTS
00264F  1               .ENDIF
00264F  1               ; PAGE
00264F  1               ; SUBTTL	RUN,GOTO,GOSUB,RETURN.
00264F  1  D0 03 4C 50  RUN:	JEQ	RUNC		;IF NO LINE # ARGUMENT.
002653  1  24           
002654  1  20 57 24     	JSR	CLEARC		;CLEAN UP -- RESET THE STACK.
002657  1  4C 6E 26     	JMP	RUNC2		;MUST REPLACE RTS ADDR.
00265A  1               ;
00265A  1               ; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
00265A  1               ;
00265A  1               ; LOW ADDRESS:
00265A  1               ;	THE GOSUTK ONE BYTE
00265A  1               ;	THE LINE NUMBER OF THE GOSUB STATEMENT TWO BYTES
00265A  1               ;	A POINTER INTO THE TEXT OF THE GOSUB TWO BYTES
00265A  1               ;
00265A  1               ; HIGH ADDRESS.
00265A  1               ;
00265A  1               ; TOTAL FIVE BYTES.
00265A  1               ;
00265A  1  A9 03        GOSUB:	LDA	#3
00265C  1  20 12 22     	JSR	GETSTK		;MAKE SURE THERE IS ROOM.
00265F  1  A5 CA 48 A5  	PSHWD	TXTPTR		;PUSH ON THE TEXT POINTER.
002663  1  C9 48        
002665  1  A5 89 48 A5  	PSHWD	CURLIN		;PUSH ON THE CURRENT LINE NUMBER.
002669  1  88 48        
00266B  1  A9 8C        	LDA	#GOSUTK
00266D  1  48           	PHA			;PUSH ON A GOSUB TOKEN.
00266E  1  20 C8 00     RUNC2:	JSR	CHRGOT		;GET CHARACTER AND SET CODES FOR LINGET.
002671  1  20 77 26     	JSR	GOTO		;USE RTS SCHEME TO "NEWSTT".
002674  1  4C 88 25     	JMP	NEWSTT
002677  1               
002677  1  20 3D 27     GOTO:	JSR	LINGET		;PICK UP THE LINE NUMBER IN "LINNUM".
00267A  1  20 DB 26     	JSR	REMN		;SKIP TO END OF LINE.
00267D  1  A5 89        	LDA	CURLIN+1
00267F  1  C5 1C        	CMP	LINNUM+1
002681  1  B0 0B        	BCS	LUK4IT
002683  1  98           	TYA
002684  1  38           	SEC
002685  1  65 C9        	ADC	TXTPTR
002687  1  A6 CA        	LDX	TXTPTR+1
002689  1  90 07        	BCC	LUKALL
00268B  1  E8 B0 04     	INX
00268E  1               	BCSA	LUKALL		;ALWAYS GOES.
00268E  1  A5 7A A6 7B  LUK4IT: LDWX	TXTTAB
002692  1  20 0E 24     LUKALL: JSR	FNDLNC		;[X,A] ARE ALL SET UP.
002695  1  90 1E        QFOUND: BCC	USERR		;GOTO LINE IS NONEXISTANT.
002697  1  A5 AE        	LDA	LOWTR
002699  1  E9 01        	SBC	#1
00269B  1  85 C9        	STA	TXTPTR
00269D  1  A5 AF        	LDA	LOWTR+1
00269F  1  E9 00        	SBC	#0
0026A1  1  85 CA        	STA	TXTPTR+1
0026A3  1  60           GORTS:	RTS			;PROCESS THE STATEMENT.
0026A4  1               ;
0026A4  1               ; "RETURN" RESTORES THE LINE NUMBER AND TEXT PNTR FROM THE STACK
0026A4  1               ; AND ELIMINATES ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB" ENTRY.
0026A4  1               ;
0026A4  1  D0 FD        RETURN: BNE	GORTS		;NO TERMINATOR=BLOW HIM UP.
0026A6  1  A9 FF        	LDA	#255
0026A8  1  85 99        	STA	FORPNT+1	;MAKE SURE THE VARIABLE'S PNTR
0026AA  1               				;NEVER GETS MATCHED.
0026AA  1  20 A1 21     	JSR	FNDFOR		;GO PAST ALL THE "FOR" ENTRIES.
0026AD  1  9A           	TXS
0026AE  1  C9 8C        	CMP	#GOSUTK		;RETURN WITHOUT GOSUB?
0026B0  1  F0 0B        	BEQ	RETU1
0026B2  1  A2 04 2C     	LDX	#ERRRG
0026B5  1               	SKIP2
0026B5  1  A2 0E        USERR:	LDX	#ERRUS		;NO MATCH SO "US" ERROR.
0026B7  1  4C 4E 22     	JMP	ERROR		;YES.
0026BA  1  4C 0E 2C     SNERR2: JMP	SNERR
0026BD  1  68           RETU1:	PLA			;REMOVE GOSUTK.
0026BE  1  68 85 88 68  	PULWD	CURLIN		;GET LINE NUMBER "GOSUB" WAS FROM.
0026C2  1  85 89        
0026C4  1  68 85 C9 68  	PULWD	TXTPTR		;GET TEXT PNTR FROM "GOSUB".
0026C8  1  85 CA        
0026CA  1  20 D8 26     DATA:	JSR	DATAN		;SKIP TO END OF STATEMENT,
0026CD  1               				;SINCE WHEN "GOSUB" STUCK THE TEXT  PNTR
0026CD  1               				;ONTO THE STACK, THE LINE NUMBER ARG
0026CD  1               				;HADN'T BEEN READ YET.
0026CD  1  98           ADDON:	TYA
0026CE  1  18           	CLC
0026CF  1  65 C9        	ADC	TXTPTR
0026D1  1  85 C9        	STA	TXTPTR
0026D3  1  90 02        	BCC	REMRTS
0026D5  1  E6 CA        	INC	TXTPTR+1
0026D7  1  60           REMRTS: RTS			;"NEWSTT" RTS ADDR IS STILL THERE.
0026D8  1               
0026D8  1  A2 3A 2C     DATAN:	LDX	#':'		;"DATA" TERMINATES ON ":" AND NULL.
0026DB  1               	SKIP2
0026DB  1  A2 00        REMN:	LDX	#0		;THE ONLY TERMINATOR IS NULL.
0026DD  1  86 0D        	STX	CHARAC		;PRESERVE IT.
0026DF  1  A0 00        	LDY	#0		;THIS MAKES CHARAC=0 AFTER SWAP.
0026E1  1  84 0E        	STY	ENDCHR
0026E3  1  A5 0E        EXCHQT: LDA	ENDCHR
0026E5  1  A6 0D        	LDX	CHARAC
0026E7  1  85 0D        	STA	CHARAC
0026E9  1  86 0E        	STX	ENDCHR
0026EB  1  B1 C9        REMER:	LDADY	TXTPTR
0026ED  1  F0 E8        	BEQ	REMRTS		;NULL ALWAYS TERMINATES.
0026EF  1  C5 0E        	CMP	ENDCHR		;IS IT THE OTHER TERMINATOR?
0026F1  1  F0 E4        	BEQ	REMRTS		;YES, IT'S FINISHED.
0026F3  1  C8           	INY			;PROGRESS TO NEXT CHARACTER.
0026F4  1  C9 22        	CMP	#34		;IS IT A QUOTE?
0026F6  1  D0 F3 F0 E9  	BNE	REMER		;NO, JUST CONTINUE.
0026FA  1               	BEQA	EXCHQT		;YES, TIME TO TRADE.
0026FA  1               ; PAGE
0026FA  1               ; SUBTTL	"IF ... THEN" CODE.
0026FA  1  20 BD 2A     IF:	JSR	FRMEVL		;EVALUATE A FORMULA.
0026FD  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER.
002700  1  C9 88        	CMP	#GOTOTK		;IS TERMINATING CHARACTER A GOTOTK?
002702  1  F0 05        	BEQ	OKGOTO		;YES.
002704  1  A9 A0 20 05  	SYNCHK	THENTK		;NO, IT MUST BE "THEN".
002708  1  2C           
002709  1  A5 B0        OKGOTO: LDA	FACEXP		;0=FALSE. ALL OTHERS TRUE.
00270B  1  D0 05        	BNE	DOCOND		;TRUE !
00270D  1  20 DB 26 F0  REM:	JSR	REMN		;SKIP REST OF STATEMENT.
002711  1  BB           
002712  1               	BEQA	ADDON		;WILL ALWAYS BRANCH.
002712  1  20 C8 00     DOCOND: JSR	CHRGOT		;TEST CURRENT CHARACTER.
002715  1  B0 03        	BCS	DOCO		;IF A NUMBER, GOTO IT.
002717  1  4C 77 26     	JMP	GOTO
00271A  1  4C BE 25     DOCO:	JMP	GONE3		;INTERPRET NEW STATEMENT.
00271D  1               ; PAGE
00271D  1               ; SUBTTL	"ON ... GO TO ..." CODE.
00271D  1  20 1B 34     ONGOTO: JSR	GETBYT		;GET VALUE IN FACLO.
002720  1  48           	PHA			;SAVE FOR LATER.
002721  1  C9 8C        	CMP	#GOSUTK		;AN "ON ... GOSUB" PERHAPS?
002723  1  F0 04        	BEQ	ONGLOP		;YES.
002725  1  C9 88        SNERR3: CMP	#GOTOTK		;MUST BE "GOTOTK".
002727  1  D0 91        	BNE	SNERR2
002729  1  C6 B4        ONGLOP: DEC	FACLO
00272B  1  D0 04        	BNE	ONGLP1		;SKIP ANOTHER LINE NUMBER.
00272D  1  68           	PLA			;GET DISPATCH CHARACTER.
00272E  1  4C C0 25     	JMP	GONE2
002731  1  20 C2 00     ONGLP1: JSR	CHRGET		;ADVANCE AND SET CODES.
002734  1  20 3D 27     	JSR	LINGET
002737  1  C9 2C        	CMP	#44		;IS IT A COMMA?
002739  1  F0 EE        	BEQ	ONGLOP
00273B  1  68           	PLA			;REMOVE STACK ENTRY (TOKEN).
00273C  1  60           ONGRTS: RTS			;EITHER END-OF-LINE OR SYNTAX ERROR.
00273D  1               ; PAGE
00273D  1               ; SUBTTL	LINGET -- READ A LINE NUMBER INTO LINNUM
00273D  1               ;
00273D  1               ; "LINGET" READS A LINE NUMBER FROM THE CURRENT TEXT POSITION.
00273D  1               ;
00273D  1               ; LINE NUMBERS RANGE FROM 0 TO 64000-1.
00273D  1               ;
00273D  1               ; THE ANSWER IS RETURNED IN "LINNUM".
00273D  1               ; "TXTPTR" IS UPDATED TO POINT TO THE TERMINATING CHARCTER
00273D  1               ; AND [A] = THE TERMINATING CHARACTER WITH CONDITION
00273D  1               ; CODES SET UP TO REFLECT ITS VALUE.
00273D  1               ;
00273D  1  A2 00        LINGET: LDX	#0
00273F  1  86 1B        	STX	LINNUM		;INITIALIZE LINE NUMBER TO ZERO.
002741  1  86 1C        	STX	LINNUM+1
002743  1  B0 F7        MORLIN: BCS	ONGRTS		;IT IS NOT A DIGIT.
002745  1  E9 2F        	SBC	#'0'-1		;-1 SINCE C=0.
002747  1  85 0D        	STA	CHARAC		;SAVE CHARACTER.
002749  1  A5 1C        	LDA	LINNUM+1
00274B  1  85 71        	STA	INDEX
00274D  1  C9 19        	CMP	#25		;LINE NUMBER WILL BE .LT. 64000?
00274F  1  B0 D4        	BCS	SNERR3
002751  1  A5 1B        	LDA	LINNUM
002753  1  0A           	ASL	A 		;MULTIPLY BY 10.
002754  1  26 71        	ROL	INDEX
002756  1  0A           	ASL	A
002757  1  26 71        	ROL	INDEX
002759  1  65 1B        	ADC	LINNUM
00275B  1  85 1B        	STA	LINNUM
00275D  1  A5 71        	LDA	INDEX
00275F  1  65 1C        	ADC	LINNUM+1
002761  1  85 1C        	STA	LINNUM+1
002763  1  06 1B        	ASL	LINNUM
002765  1  26 1C        	ROL	LINNUM+1
002767  1  A5 1B        	LDA	LINNUM
002769  1  65 0D        	ADC	CHARAC		;ADD IN DIGIT.
00276B  1  85 1B        	STA	LINNUM
00276D  1  90 02        	BCC	NXTLGC
00276F  1  E6 1C        	INC	LINNUM+1
002771  1  20 C2 00     NXTLGC: JSR	CHRGET
002774  1  4C 43 27     	JMP	MORLIN
002777  1               
002777  1               ; PAGE
002777  1               ; SUBTTL	"LET" CODE.
002777  1  20 22 2D     LET:	JSR	PTRGET		;GET PNTR TO VARIABLE INTO "VARPNT".
00277A  1  85 98 84 99  	STWD	FORPNT		;PRESERVE POINTER.
00277E  1  A9 AB 20 05  	SYNCHK	EQULTK		;"=" IS NECESSARY.
002782  1  2C           
002783  1               .IF	INTPRC <> 0
002783  1  A5 12        	LDA	INTFLG		;SAVE FOR LATER.
002785  1  48           	PHA
002786  1               .ENDIF
002786  1  A5 11        	LDA	VALTYP		;RETAIN THE VARIABLE'S VALUE TYPE.
002788  1  48           	PHA
002789  1  20 BD 2A     	JSR	FRMEVL		;GET VALUE OF FORMULA INTO "FAC".
00278C  1  68           	PLA
00278D  1  2A           	ROL	A 		;CARRY SET FOR STRING, OFF FOR
00278E  1               				;NUMERIC.
00278E  1  20 AF 2A     	JSR	CHKVAL		;MAKE SURE "VALTYP" MATCHES CARRY.
002791  1               				;AND SET ZERO FLAG FOR NUMERIC.
002791  1  D0 18        	BNE	COPSTR		;IF NUMERIC, COPY IT.
002793  1               COPNUM:
002793  1               .IF	INTPRC <> 0
002793  1  68           	PLA			;GET NUMBER TYPE.
002794  1  10 12        QINTGR: BPL	COPFLT		;STORE A FLTING NUMBER.
002796  1  20 99 38     	JSR	ROUND		;ROUND INTEGER.
002799  1  20 3C 2E     	JSR	AYINT		;MAKE 2-BYTE NUMBER.
00279C  1  A0 00        	LDY	#0
00279E  1  A5 B3        	LDA	FACMO		;GET HIGH.
0027A0  1  91 98        	STADY	FORPNT		;STORE IT.
0027A2  1  C8           	INY
0027A3  1  A5 B4        	LDA	FACLO		;GET LOW.
0027A5  1  91 98        	STADY	FORPNT
0027A7  1  60           	RTS
0027A8  1               .ENDIF
0027A8  1  4C 4E 38     COPFLT: JMP	MOVVF		;PUT NUMBER @FORPNT.
0027AB  1               
0027AB  1               COPSTR:
0027AB  1               .IF	INTPRC <> 0
0027AB  1  68           	PLA		;IF STRING, NO INTFLG.
0027AC  1               .ENDIF
0027AC  1               INPCOM:
0027AC  1               .IF	TIME <> 0
0027AC  1               	LDY	FORPNT+1	;TI$?
0027AC  1               	CPY	#ZERO/256	;ONLY TI$ CAN BE THIS ON ASSIG.
0027AC  1               	BNE	GETSPT		; WAS NOT TI$.
0027AC  1               	JSR	FREFAC		;WE WONT NEEDIT.
0027AC  1               	CMP	#6		;LENGTH CORRECT?
0027AC  1               	BNE	FCERR2
0027AC  1               	LDY	#0		;YES. DO SETUP.
0027AC  1               	STY	FACEXP		;ZERO FAC TO START WITH.
0027AC  1               	STY	FACSGN
0027AC  1               TIMELP: STY	FBUFPT		;SAVE POSOTION.
0027AC  1               	JSR	TIMNUM		;GET A DIGIT.
0027AC  1               	JSR	MUL10		;WHOLE QTY BY 10.
0027AC  1               	INC	FBUFPT
0027AC  1               	LDY	FBUFPT
0027AC  1               	JSR	TIMNUM
0027AC  1               	JSR	MOVAF
0027AC  1               	TAX			;IF NUM=0 THEN NO MULT.
0027AC  1               	BEQ	NOML6		;IF =0, GO TIT.
0027AC  1               	INX			;MULT BY TWO.
0027AC  1               	TXA
0027AC  1               	JSR	FINML6		;ADD IN AND MULT BY 2 GIVES *6.
0027AC  1               NOML6:	LDY	FBUFPT
0027AC  1               	INY
0027AC  1               	CPY	#6		;DONE ALL SIX?
0027AC  1               	BNE	TIMELP
0027AC  1               	JSR	MUL10		;ONE LAST TIME.
0027AC  1               	JSR	QINT		;SHIFT IT OVER TO THE RIGHT.
0027AC  1               	LDX	#2
0027AC  1               	SEI			;DISALLOW INTERRUPTS.
0027AC  1               TIMEST: LDA	FACMOH,X
0027AC  1               	STA	CQTIMR,X
0027AC  1               	DEX
0027AC  1               	BPL	TIMEST		;LOOP 3 TIMES.
0027AC  1               	CLI			;TURN ON INTS AGAIN.
0027AC  1               	RTS
0027AC  1               TIMNUM: LDADY	INDEX		;INDEX SET UP BY FREFAC.
0027AC  1               	JSR	QNUM
0027AC  1               	BCC	GOTNUM
0027AC  1               FCERR2: JMP	FCERR		;MUST BE NUMERIC STRING.
0027AC  1               GOTNUM: SBC	#'0'-1		;C IS OFF.
0027AC  1               	JMP	FINLOG		;ADD IN DIGIT TO FAC.
0027AC  1               .ENDIF
0027AC  1               
0027AC  1  A0 02        GETSPT: LDY	#2		;GET PNTR TO DESCRIPTOR.
0027AE  1  B1 B3        	LDADY	FACMO
0027B0  1  C5 83        	CMP	FRETOP+1	;SEE IF IT POINTS INTO STRING SPACE.
0027B2  1  90 17        	BCC	DNTCPY		;IF [FRETOP],GT.[2&3,FACMO], DON'T COPY.
0027B4  1  D0 07        	BNE	QVARIA		;IT IS LESS.
0027B6  1  88           	DEY
0027B7  1  B1 B3        	LDADY	FACMO
0027B9  1  C5 82        	CMP	FRETOP		;COMPARE LOW ORDERS.
0027BB  1  90 0E        	BCC	DNTCPY
0027BD  1  A4 B4        QVARIA: LDY	FACLO
0027BF  1  C4 7D        	CPY	VARTAB+1	;IF [VARTAB].GT.[FACMO], DON'T COPY.
0027C1  1  90 08        	BCC	DNTCPY
0027C3  1  D0 0D        	BNE	COPY		;IT IS LESS.
0027C5  1  A5 B3        	LDA	FACMO
0027C7  1  C5 7C        	CMP	VARTAB		;COMPARE LOW ORDERS.
0027C9  1  B0 07        	BCS	COPY
0027CB  1  A5 B3 A4 B4  DNTCPY: LDWD	FACMO
0027CF  1  4C E8 27     	JMP	COPYZC
0027D2  1  A0 00        COPY:	LDY	#0
0027D4  1  B1 B3        	LDADY	FACMO
0027D6  1  20 F1 30     	JSR	STRINI		;GET ROOM TO COPY STRING INTO.
0027D9  1  A5 9F A4 A0  	LDWD	DSCPNT		;GET POINTER TO OLD DESCRIPTOR, SO
0027DD  1  85 BE 84 BF  	STWD	STRNG1		;MOVINS CAN FIND STRING.
0027E1  1  20 F7 32     	JSR	MOVINS		;COPY IT.
0027E4  1  A9 B0 A0 00  	LDWDI	DSCTMP		;GET POINTER TO OLD DESCRIPTOR.
0027E8  1  85 9F 84 A0  COPYZC: STWD	DSCPNT		;REMEMBER POINTER TO DESCRIPTOR.
0027EC  1  20 58 33     	JSR	FRETMS		;FREE UP THE TEMPORARY WITHOUT
0027EF  1               				;FREEING UP ANY STRING SPACE.
0027EF  1  A0 00        	LDY	#0
0027F1  1  B1 9F        	LDADY	DSCPNT
0027F3  1  91 98        	STADY	FORPNT
0027F5  1  C8           	INY			;POINT TO STRING PNTR.
0027F6  1  B1 9F        	LDADY	DSCPNT
0027F8  1  91 98        	STADY	FORPNT
0027FA  1  C8           	INY
0027FB  1  B1 9F        	LDADY	DSCPNT
0027FD  1  91 98        	STADY	FORPNT
0027FF  1  60           	RTS
002800  1               ; PAGE
002800  1               ; SUBTTL	PRINT CODE.
002800  1               .IF	EXTIO <> 0
002800  1               PRINTN: JSR	CMD		;DOCMD
002800  1               	JMP	IODONE		;RELEASE CHANNEL.
002800  1               CMD:	JSR	GETBYT
002800  1               	BEQ	SAVEIT
002800  1               	SYNCHK	44		;COMMA?
002800  1               SAVEIT: PHP
002800  1               	JSR	CQOOUT		;CHECK AND OPEN OUTPUT CHANNL.
002800  1               	STX	CHANNL		;CHANNL TO OUTPUT ON.
002800  1               	PLP			;GET STATUS BACK.
002800  1               	JMP	PRINT
002800  1               .ENDIF
002800  1  20 9D 28     STRDON: JSR	STRPRT
002803  1  20 C8 00     NEWCHR: JSR	CHRGOT		;REGET LAST CHARACTER.
002806  1  F0 3C        PRINT:	BEQ	CRDO		;TERMINATOR SO TYPE CRLF.
002808  1  F0 58        PRINTC: BEQ	PRTRTS		;HERE AFTER SEEING TAB(X) OR , OR ;
00280A  1               				;IN WHICH CASE A TERMINATOR DOES NOT
00280A  1               				;MEAN TYPE A CRLF BUT JUST RTS.
00280A  1  C9 9C        	CMP	#TABTK		;TAB FUNCTION?
00280C  1  F0 6C        	BEQ	TABER		;YES.
00280E  1  C9 9F        	CMP	#SPCTK		;SPACE FUNCTION?
002810  1  18           	CLC
002811  1  F0 67        	BEQ	TABER
002813  1  C9 2C        	CMP	#44		;A COMMA?
002815  1  F0 4C        	BEQ	COMPRT		;YES.
002817  1  C9 3B        	CMP	#59		;A SEMICOLON?
002819  1  F0 74        	BEQ	NOTABR		;YES.
00281B  1  20 BD 2A     	JSR	FRMEVL		;EVALUATE THE FORMULA.
00281E  1  24 11        	BIT	VALTYP		;A STRING?
002820  1  30 DE        	BMI	STRDON		;YES.
002822  1  20 5B 3A     	JSR	FOUT
002825  1  20 03 31     	JSR	STRLIT		;BUILD DESCRIPTOR.
002828  1               .IF	REALIO-3 <> 0
002828  1  A0 00        	LDY	#0		;GET THE POINTER.
00282A  1  B1 B3        	LDADY	FACMO
00282C  1  18           	CLC
00282D  1  65 18        	ADC	TRMPOS		;MAKE SURE LEN+POS.LT.WIDTH.
00282F  1  C5 19        	CMP	LINWID		;GREATER THAN LINE LENGTH?
002831  1               				;REMEMBER SPACE PRINTED AFTER NUMBER.
002831  1  90 03        	BCC	LINCHK		;GO TYPE.
002833  1  20 44 28     	JSR	CRDO		;YES, TYPE CRLF FIRST.
002836  1               .ENDIF
002836  1  20 9D 28     LINCHK: JSR	STRPRT		;PRINT THE NUMBER.
002839  1  20 B7 28 D0  	JSR	OUTSPC		;PRINT A SPACE
00283D  1  C5           
00283E  1               	BNEA	NEWCHR		;ALWAYS GOES.
00283E  1               .IF	REALIO-4 <> 0
00283E  1               .IF	BUFPAG <> 0
00283E  1               FININL: LDA	#0
00283E  1               	STA	BUF,X
00283E  1               	LDXYI	BUF-1
00283E  1               .ENDIF
00283E  1               .IF	BUFPAG = 0
00283E  1  A0 00        FININL: LDY	#0		;PUT A ZERO AT END OF BUF.
002840  1  94 1D        	STY	BUF,X
002842  1  A2 1C        	LDX	#BUF-1		;SETUP POINTER.
002844  1               .ENDIF
002844  1               .IF	EXTIO <> 0
002844  1               	LDA	CHANNL		;NO CRDO IF NOT TERMINAL.
002844  1               	BNE	PRTRTS
002844  1               .ENDIF
002844  1               .ENDIF
002844  1               CRDO:
002844  1               .IF	EXTIO = 0
002844  1  A9 0D        	LDA	#13		;MAKE TRMPOS LESS THAN LINE LENGTH.
002846  1  85 18        	STA	TRMPOS
002848  1               .ENDIF
002848  1               .IF	EXTIO <> 0
002848  1               .IF	REALIO-3 <> 0
002848  1               	LDA	CHANNL
002848  1               	BNE	GOCR
002848  1               	STA	TRMPOS
002848  1               .ENDIF
002848  1               GOCR:	LDA	#13		;X AND Y MUST BE PRESERVED.
002848  1               .ENDIF
002848  1  20 BC 28     	JSR	OUTDO
00284B  1  A9 0A        	LDA	#10
00284D  1  20 BC 28     	JSR	OUTDO
002850  1               CRFIN:
002850  1               .IF	EXTIO <> 0
002850  1               .IF	REALIO-3 <> 0
002850  1               	LDA	CHANNL
002850  1               	BNE	PRTRTS
002850  1               .ENDIF
002850  1               .ENDIF
002850  1               .IF	NULCMD = 0
002850  1               .IF	REALIO-3 <> 0
002850  1               	LDA	#0
002850  1               	STA	TRMPOS
002850  1               .ENDIF
002850  1               	EOR	#255
002850  1               .ENDIF
002850  1               .IF	NULCMD <> 0
002850  1  8A           	TXA			;PRESERVE [ACCX]. SOME NEED IT.
002851  1  48           	PHA
002852  1  A6 17        	LDX	NULCNT		;GET NUMBER OF NULLS.
002854  1  F0 08        	BEQ	CLRPOS
002856  1  A9 00        	LDA	#0
002858  1  20 BC 28     PRTNUL: JSR	OUTDO
00285B  1  CA           	DEX			;DONE WITH NULLS?
00285C  1  D0 FA        	BNE	PRTNUL
00285E  1  86 18        CLRPOS: STX	TRMPOS
002860  1  68           	PLA
002861  1  AA           	TAX
002862  1               .ENDIF
002862  1  60           PRTRTS: RTS
002863  1               
002863  1  A5 18        COMPRT: LDA	TRMPOS
002865  1               NCMPOS .SET (((LINLEN/CLMWID)-1)*CLMWID)	;CLMWID BEYOND WHICH THERE ARE
002865  1               .IF	REALIO-3 <> 0
002865  1               				;NO MORE COMMA FIELDS.
002865  1  C5 1A        	CMP	NCMWID		;SO ALL COMMA DOES IS "CRDO".
002867  1               
002867  1  90 06        	BCC	MORCOM
002869  1  20 44 28     	JSR	CRDO		;TYPE CRLF.
00286C  1  4C 8F 28     	JMP	NOTABR		;AND QUIT IF BEYOND LAST FIELD.
00286F  1               .ENDIF
00286F  1  38           MORCOM: SEC
002870  1  E9 0E        MORCO1: SBC	#CLMWID		;GET [A] MODULUS CLMWID.
002872  1  B0 FC        	BCS	MORCO1
002874  1  49 FF        	EOR	#255		;FILL PRINT POS OUT TO EVEN CLMWID SO
002876  1  69 01        	ADC	#1
002878  1  D0 10        	BNE	ASPAC		;PRINT [A] SPACES.
00287A  1               
00287A  1  08           TABER:	PHP			;REMEMBER IF SPC OR TAB FUNCTION.
00287B  1  20 18 34     	JSR	GTBYTC		;GET VALUE INTO ACCX.
00287E  1  C9 29        	CMP	#41
002880  1  D0 63        	BNE	SNERR4
002882  1  28           	PLP
002883  1  90 06        	BCC	XSPAC		;PRINT [X] SPACES.
002885  1  8A           	TXA
002886  1  E5 18        	SBC	TRMPOS
002888  1  90 05        	BCC	NOTABR		;NEGATIVE, DON'T PRINT ANY.
00288A  1  AA           ASPAC:	TAX
00288B  1  E8           XSPAC:	INX
00288C  1  CA           XSPAC2: DEX			;DECREMENT THE COUNT.
00288D  1  D0 06        	BNE	XSPAC1
00288F  1  20 C2 00     NOTABR: JSR	CHRGET		;REGET LAST CHARACTER.
002892  1  4C 08 28     	JMP	PRINTC		;DON'T CALL CRDO.
002895  1  20 B7 28 D0  XSPAC1: JSR	OUTSPC
002899  1  F2           
00289A  1               	BNEA	XSPAC2
00289A  1               ;
00289A  1               ; PRINT THE STRING POINTED TO BY [Y,A] WHICH ENDS WITH A ZERO.
00289A  1               ; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE.
00289A  1               ;
00289A  1  20 03 31     STROUT: JSR	STRLIT		;GET A STRING LITERAL.
00289D  1               ;
00289D  1               ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACMO.
00289D  1               ;
00289D  1  20 23 33     STRPRT: JSR	FREFAC		;RETURN TEMP POINTER.
0028A0  1  AA           	TAX			;PUT COUNT INTO COUNTER.
0028A1  1  A0 00        	LDY	#0
0028A3  1  E8           	INX			;MOVE ONE AHEAD.
0028A4  1  CA           STRPR2: DEX
0028A5  1  F0 BB        	BEQ	PRTRTS		;ALL DONE.
0028A7  1  B1 71        	LDADY	INDEX		;PNTR TO ACT STRNG SET BY FREFAC.
0028A9  1  20 BC 28     	JSR	OUTDO
0028AC  1  C8           	INY
0028AD  1  C9 0D        	CMP	#13
0028AF  1  D0 F3        	BNE	STRPR2
0028B1  1  20 50 28     	JSR	CRFIN		;TYPE REST OF CARRIAGE RETURN.
0028B4  1  4C A4 28     	JMP	STRPR2		;AND ON AND ON.
0028B7  1               ;
0028B7  1               ; OUTDO OUTPUTS THE CHARACTER IN ACCA, USING CNTWFL
0028B7  1               ; (SUPPRESS OR NOT), TRMPOS (PRINT HEAD POSITION),
0028B7  1               ; TIMING, ETCQ. NO REGISTERS ARE CHANGED.
0028B7  1               ;
0028B7  1               OUTSPC:
0028B7  1               .IF	REALIO-3 <> 0
0028B7  1  A9 20        	LDA	#' '
0028B9  1               .ENDIF
0028B9  1  2C           .IF	REALIO-3 = 0
0028BA  1               	LDA	CHANNL
0028BA  1               	BEQ	CRTSKP
0028BA  1               	LDA	#' '
0028BA  1               	SKIP2
0028BA  1               CRTSKP: LDA	#29		;COMMODORE'S SKIP CHARACTER.
0028BA  1               .ENDIF
0028BA  1               	SKIP2
0028BA  1  A9 3F        OUTQST: LDA	#'?'
0028BC  1               OUTDO:
0028BC  1               .IF	REALIO <> 0
0028BC  1               	BIT	CNTWFL		;SHOULDN'T AFFECT CHANNEL I/O!
0028BC  1               	BMI	OUTRTS
0028BC  1               .ENDIF
0028BC  1               .IF	REALIO-3 <> 0
0028BC  1  48           	PHA
0028BD  1  C9 20        	CMP	#32		;IS THIS A PRINTING CHAR?
0028BF  1  90 0B        	BCC	TRYOUT		;NO, DON'T INCLUDE IT IN TRMPOS.
0028C1  1  A5 18        	LDA	TRMPOS
0028C3  1  C5 19        	CMP	LINWID		;LENGTH = TERMINAL WIDTH?
0028C5  1  D0 03        	BNE	OUTDO1
0028C7  1  20 44 28     	JSR	CRDO		;YES, TYPE CRLF
0028CA  1               OUTDO1:
0028CA  1               .IF	EXTIO <> 0
0028CA  1               	LDA	CHANNL
0028CA  1               	BNE	TRYOUT
0028CA  1               .ENDIF
0028CA  1  E6 18        INCTRM: INC	TRMPOS		;INCREMENT COUNT.
0028CC  1  68           TRYOUT: PLA			;RESTORE THE A REGISTER
0028CD  1               .ENDIF
0028CD  1               
0028CD  1               .IF	REALIO-1 = 0
0028CD  1               	STY	KIMY		;PRESERVE Y.
0028CD  1               .ENDIF
0028CD  1               .IF	REALIO-4 = 0
0028CD  1               	ORA	#$80	;TURN ON B7 FOR APPLE.
0028CD  1               .ENDIF
0028CD  1               .IF	REALIO <> 0
0028CD  1               OUTLOC: JSR	OUTCH		;OUTPUT THE CHARACTER.
0028CD  1               .ENDIF
0028CD  1               .IF	REALIO-1 = 0
0028CD  1               	LDY	KIMY		;GET Y BACK.
0028CD  1               .ENDIF
0028CD  1               .IF	REALIO-2 = 0
0028CD  1               	REPEAT	4,{NOP}
0028CD  1               .ENDIF
0028CD  1               .IF	REALIO-4 = 0
0028CD  1               	AND	#$7F	;GET [A] BACK FROM APPLE.
0028CD  1               .ENDIF
0028CD  1               
0028CD  1               .IF	REALIO = 0
0028CD  1  8D 00 D0     	SIM_OUTSIM		;CALL SIMULATOR OUTPUT ROUTINE
0028D0  1               .ENDIF
0028D0  1  29 FF        OUTRTS: AND	#255		;SET Z=0.
0028D2  1  60           GETRTS: RTS
0028D3  1               
0028D3  1               ; PAGE
0028D3  1               ; SUBTTL	INPUT AND READ CODE.
0028D3  1               ;
0028D3  1               ; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
0028D3  1               ; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
0028D3  1               ; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
0028D3  1               ;
0028D3  1  A5 15        TRMNOK: LDA	INPFLG
0028D5  1  F0 11        	BEQ	TRMNO1		;IF INPUT TRY AGAIN.
0028D7  1               .IF	GETCMD <> 0
0028D7  1  30 04        	BMI	GETDTL
0028D9  1  A0 FF D0 04  	LDY	#255		;MAKE IT LOOK DIRECT.
0028DD  1               	BNEA	STCURL		;ALWAYS GOES.
0028DD  1               GETDTL:
0028DD  1               .ENDIF
0028DD  1  A5 8E A4 8F  	LDWD	DATLIN		;GET DATA LINE NUMBER.
0028E1  1  85 88 84 89  STCURL: STWD	CURLIN		;MAKE IT CURRENT LINE.
0028E5  1  4C 0E 2C     SNERR4: JMP	SNERR
0028E8  1               TRMNO1:
0028E8  1               .IF	EXTIO <> 0
0028E8  1               	LDA	CHANNL		;IF NOT TERMINAL, GIVE BAD DATA.
0028E8  1               	BEQ	DOAGIN
0028E8  1               	LDX	#ERRBD
0028E8  1               	JMP	ERROR
0028E8  1               .ENDIF
0028E8  1  A9 2B A0 2A  DOAGIN: LDWDI	TRYAGN
0028EC  1  20 9A 28     	JSR	STROUT		;PRINT "?REDO FROM START".
0028EF  1  A5 8C A4 8D  	LDWD	OLDTXT		;POINT AT START
0028F3  1  85 C9 84 CA  	STWD	TXTPTR		;OF THIS CURRENT LINE.
0028F7  1  60           	RTS			;GO TO "NEWSTT".
0028F8  1               .IF	GETCMD <> 0
0028F8  1  20 22 30     GET:	JSR	ERRDIR		;DIRECT IS NOT OK.
0028FB  1               .IF	EXTIO <> 0
0028FB  1               	CMP	#'#'		;SEE IF "GET#".
0028FB  1               	BNE	GETTTY		;NO, JUST GET TTY INPUT.
0028FB  1               	JSR	CHRGET		;MOVE UP TO NEXT BYTE.
0028FB  1               	JSR	GETBYT		;GET CHANNEL INTO X
0028FB  1               	SYNCHK	44		;COMMA?
0028FB  1               	JSR	CQOIN		;GET CHANNEL OPEN FOR INPUT.
0028FB  1               	STX	CHANNL
0028FB  1               .ENDIF
0028FB  1  A2 1E A0 00  GETTTY: LDXYI	BUF+1		;POINT TO 0.
0028FF  1               .IF	BUFPAG <> 0
0028FF  1               	LDA	#0		;TO STUFF AND TO POINT.
0028FF  1               	STA	BUF+1
0028FF  1               .ENDIF
0028FF  1               .IF	BUFPAG = 0
0028FF  1  84 1E        	STY	BUF+1		;ZERO IT.
002901  1               .ENDIF
002901  1  A9 40        	LDA	#64		;TURN ON V-BIT.
002903  1  20 37 29     	JSR	INPCO1		;DO THE GET.
002906  1               .IF	EXTIO <> 0
002906  1               	LDX	CHANNL
002906  1               	BNE	IORELE		;RELEASE.
002906  1               .ENDIF
002906  1  60           	RTS
002907  1               .ENDIF
002907  1               
002907  1               .IF	EXTIO <> 0
002907  1               INPUTN: JSR	GETBYT		;GET CHANNEL NUMBER.
002907  1               	SYNCHK	44		;A COMMA?
002907  1               	JSR	CQOIN		;GO WHERE COMMODORE CHECKS IN OPEN.
002907  1               	STX	CHANNL
002907  1               	JSR	NOTQTI		;DO INPUT TO VARIABLES.
002907  1               IODONE: LDA	CHANNL		;RELEASE CHANNEL.
002907  1               IORELE: JSR	CQCCHN
002907  1               	LDX	#0		;RESET CHANNEL TO TERMINAL.
002907  1               	STX	CHANNL
002907  1               	RTS
002907  1               .ENDIF
002907  1               INPUT:
002907  1               .IF	REALIO <> 0
002907  1               	LSR	CNTWFL		;BE TALKATIVE.
002907  1               .ENDIF
002907  1  C9 22        	CMP	#34		;A QUOTE?
002909  1  D0 0B        	BNE	NOTQTI		;NO MESSAGE.
00290B  1  20 C3 2B     	JSR	STRTXT		;LITERALIZE THE STRING IN TEXT
00290E  1  A9 3B 20 05  	SYNCHK	59		;MUST END WITH SEMICOLON.
002912  1  2C           
002913  1  20 9D 28     	JSR	STRPRT		;PRINT IT OUT.
002916  1  20 22 30     NOTQTI: JSR	ERRDIR		;USE COMMON ROUTINE SINCE DEF DIRECT
002919  1  A9 2C        	LDA	#44		;GET COMMA.
00291B  1  85 1C        	STA	BUF-1
00291D  1               				;IS ALSO ILLEGAL.
00291D  1  20 28 29     GETAGN: JSR	QINLIN		;TYPE "?" AND INPUT A LINE OF TEXT.
002920  1               .IF	EXTIO <> 0
002920  1               	LDA	CHANNL
002920  1               	BEQ	BUFFUL
002920  1               	LDA	CQSTAT		;GET STATUS BYTE.
002920  1               	AND	#2
002920  1               	BEQ	BUFFUL		;A-OK.
002920  1               	JSR	IODONE		;BAD. CLOSE CHANNEL.
002920  1               	JMP	DATA		;SKIP REST OF INPUT.
002920  1               BUFFUL:
002920  1               .ENDIF
002920  1  A5 1D        	LDA	BUF		;ANYTHING INPUT?
002922  1  D0 12        	BNE	INPCON		;YES, CONTINUE.
002924  1               .IF	EXTIO <> 0
002924  1               	LDA	CHANNL		;BLANK LINE MEANS GET ANOTHER.
002924  1               	BNE	GETAGN		;IF NOT TERMINAL.
002924  1               .ENDIF
002924  1  18           	CLC			;MAKE SURE DONT PRINT BREAK
002925  1  4C 0C 26     	JMP	STPEND		;NO, STOP.
002928  1               QINLIN:
002928  1               .IF	EXTIO <> 0
002928  1               	LDA	CHANNL
002928  1               	BNE	GINLIN
002928  1               .ENDIF
002928  1  20 BA 28     	JSR	OUTQST
00292B  1  20 B7 28     	JSR	OUTSPC
00292E  1  4C 51 23     GINLIN: JMP	INLIN
002931  1  A6 90 A4 91  READ:	LDXY	DATPTR		;GET LAST DATA LOCATION.
002935  1  A9           	.BYTE	$A9	;LDAI TYA TO MAKE IT NONZERO.
002936  1               .IF	BUFPAG = 0
002936  1               INPCON:
002936  1               .ENDIF
002936  1  98           	TYA
002937  1               .IF	BUFPAG <> 0
002937  1               	SKIP2
002937  1               INPCON: LDA	#0		;SET FLAG THAT THIS IS INPUT
002937  1               .ENDIF
002937  1  85 15        INPCO1: STA	INPFLG		;STORE THE FLAG.
002939  1               ;
002939  1               ; IN THE PROCESSING OF DATA AND READ STATEMENTS:
002939  1               ; ONE POINTER POINTS TO THE DATA (IE, THE NUMBERS BEING FETCHED)
002939  1               ; AND ANOTHER POINTS TO THE LIST OF VARIABLES.
002939  1               ;
002939  1               ; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
002939  1               ; TERMINATOR -- A , : OR END-OF-LINE.
002939  1               ;
002939  1               ; AT THIS POINT TXTPTR POINTS TO LIST OF VARIABLES AND
002939  1               ; [Y,X] POINTS TO DATA OR INPUT LINE.
002939  1               ;
002939  1  86 92 84 93  	STXY	INPPTR
00293D  1  20 22 2D     INLOOP: JSR	PTRGET		;READ VARIABLE LIST.
002940  1  85 98 84 99  	STWD	FORPNT		;SAVE POINTER FOR "LET" STRING STUFFING.
002944  1               				;RETURNS PNTR TOP VAR IN VARPNT.
002944  1  A5 C9 A4 CA  	LDWD	TXTPTR		;SAVE TEXT PNTR.
002948  1  85 9A 84 9B  	STWD	VARTXT
00294C  1  A6 92 A4 93  	LDXY	INPPTR
002950  1  86 C9 84 CA  	STXY	TXTPTR
002954  1  20 C8 00     	JSR	CHRGOT		;GET IT AND SET Z IF TERM.
002957  1  D0 1B        	BNE	DATBK1
002959  1  24 15        	BIT	INPFLG
00295B  1               .IF	GETCMD <> 0
00295B  1  50 0B        	BVC	QDATA
00295D  1  20 86 75     	JSR	CZGETL		;DON'T WANT INCHR. JUST ONE.
002960  1               .IF	REALIO-4 = 0
002960  1               	AND	#127
002960  1               .ENDIF
002960  1  85 1D        	STA	BUF		;MAKE IT FIRST CHARACTER.
002962  1  A2 1C A0 00  	LDXYI	BUF-1		;POINT JUST BEFORE IT.
002966  1  F0 08        .IF	BUFPAG = 0
002968  1               	BEQA	DATBK
002968  1               .ENDIF
002968  1               .IF	BUFPAG <> 0
002968  1               	BNEA	DATBK		;GO PROCESS.
002968  1               .ENDIF
002968  1               .ENDIF
002968  1  30 71        QDATA:	BMI	DATLOP		;SEARCH FOR ANOTHER DATA STATEMENT.
00296A  1               .IF	EXTIO <> 0
00296A  1               	LDA	CHANNL
00296A  1               	BNE	GETNTH
00296A  1               .ENDIF
00296A  1  20 BA 28     	JSR	OUTQST
00296D  1  20 28 29     GETNTH: JSR	QINLIN		;GET ANOTHER LINE.
002970  1  86 C9 84 CA  DATBK:	STXY	TXTPTR		;SET FOR "CHRGET".
002974  1  20 C2 00     DATBK1: JSR	CHRGET
002977  1  24 11        	BIT	VALTYP		;GET VALUE TYPE.
002979  1  10 31        	BPL	NUMINS		;INPUT A NUMBER IF NUMERIC.
00297B  1               .IF	GETCMD <> 0
00297B  1  24 15        	BIT	INPFLG		;GET?
00297D  1  50 09        	BVC	SETQUT		;NO, GO SET QUOTE.
00297F  1  E8           	INX
002980  1  86 C9        	STX	TXTPTR
002982  1  A9 00        	LDA	#0		;ZERO TERMINATORS.
002984  1  85 0D F0 0C  	STA	CHARAC
002988  1               	BEQA	RESETC
002988  1               .ENDIF
002988  1  85 0D        SETQUT: STA	CHARAC		;ASSUME QUOTED STRING.
00298A  1  C9 22        	CMP	#34		;TERMINATORS OK?
00298C  1  F0 07        	BEQ	NOWGET		;YES.
00298E  1  A9 3A        	LDA	#':'		;SET TERMINATORS TO ":" AND
002990  1  85 0D        	STA	CHARAC
002992  1  A9 2C        	LDA	#44		;COMMA.
002994  1  18           RESETC: CLC
002995  1  85 0E        NOWGET: STA	ENDCHR
002997  1  A5 C9 A4 CA  	LDWD	TXTPTR
00299B  1  69 00        	ADC	#0		;C IS SET PROPERLY ABOVE.
00299D  1  90 01        	BCC	NOWGE1
00299F  1  C8           	INY
0029A0  1  20 09 31     NOWGE1: JSR	STRLT2		;MAKE A STRING DESCRIPTOR FOR THE VALUE
0029A3  1               				;AND COPY IF NECESSARY.
0029A3  1  20 60 34     	JSR	ST2TXT		;SET TEXT POINTER.
0029A6  1  20 AC 27     	JSR	INPCOM		;DO ASSIGNMENT.
0029A9  1  4C B4 29     	JMP	STRDN2
0029AC  1  20 71 39     NUMINS: JSR	FIN
0029AF  1               .IF	INTPRC = 0
0029AF  1               	JSR	MOVVF
0029AF  1               .ENDIF
0029AF  1               .IF	INTPRC <> 0
0029AF  1  A5 12        	LDA	INTFLG		;SET CODES ON FLAG.
0029B1  1  20 94 27     	JSR	QINTGR		;GO DECIDE ON FLOAT.
0029B4  1               .ENDIF
0029B4  1  20 C8 00     STRDN2: JSR	CHRGOT		;READ LAST CHARACTER.
0029B7  1  F0 07        	BEQ	TRMOK		;":" OR EOL IS OK.
0029B9  1  C9 2C        	CMP	#44		;A COMMA?
0029BB  1  F0 03 4C D3  	JNE	TRMNOK
0029BF  1  28           
0029C0  1  A5 C9 A4 CA  TRMOK:	LDWD	TXTPTR
0029C4  1  85 92 84 93  	STWD	INPPTR		;SAVE FOR MORE READS.
0029C8  1  A5 9A A4 9B  	LDWD	VARTXT
0029CC  1  85 C9 84 CA  	STWD	TXTPTR		;POINT TO VARIABLE LIST.
0029D0  1  20 C8 00     	JSR	CHRGOT		;LOOK AT LAST VARIABLE LIST CHARACTER.
0029D3  1  F0 2C        	BEQ	VAREND		;THAT'S THE END OF THE LIST.
0029D5  1  20 03 2C     	JSR	CHKCOM		;NOT END. CHECK FOR COMMA.
0029D8  1  4C 3D 29     	JMP	INLOOP
0029DB  1               ;
0029DB  1               ; SUBROUTINE TO FIND DATA
0029DB  1               ; THE SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA TO
0029DB  1               ; SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
0029DB  1               ; IS COMPARED WITH "DATATK". EACH NEW LINE NUMBER
0029DB  1               ; IS STORED IN "DATLIN" SO THAT IF AN ERROR OCCURS
0029DB  1               ; WHILE READING DATA THE ERROR MESSAGE CAN GIVE THE LINE
0029DB  1               ; NUMBER OF THE ILL-FORMATTED DATA.
0029DB  1               ;
0029DB  1  20 D8 26     DATLOP: JSR	DATAN		;SKIP SOME TEXT.
0029DE  1  C8           	INY
0029DF  1  AA           	TAX			;END OF LINE?
0029E0  1  D0 12        	BNE	NOWLIN		;SHO AIN'T.
0029E2  1  A2 06        	LDX	#ERROD		;YES = "NO DATA" ERROR.
0029E4  1  C8           	INY
0029E5  1  B1 C9        	LDADY	TXTPTR
0029E7  1  F0 69        	BEQ	ERRGO5
0029E9  1  C8           	INY
0029EA  1  B1 C9        	LDADY	TXTPTR		;GET HIGH BYTE OF LINE NUMBER.
0029EC  1  85 8E        	STA	DATLIN
0029EE  1  C8           	INY
0029EF  1  B1 C9        	LDADY	TXTPTR		;GET LOW BYTE.
0029F1  1  C8           	INY
0029F2  1  85 8F        	STA	DATLIN+1
0029F4  1  B1 C9        NOWLIN: LDADY	TXTPTR		;HOW IS IT?
0029F6  1  AA           	TAX
0029F7  1  20 CD 26     	JSR	ADDON		;ADD [Y] TO [TXTPTR].
0029FA  1  E0 83        	CPX	#DATATK		;IS IT A "DATA" STATEMENT.
0029FC  1  D0 DD        	BNE	DATLOP		;NOT QUITE RIGHT. KEEP LOOKING.
0029FE  1  4C 74 29     	JMP	DATBK1		;THIS IS THE ONE !
002A01  1  A5 92 A4 93  VAREND: LDWD	INPPTR		;PUT AWAY A NEW DATA PNTR MAYBE.
002A05  1  A6 15        	LDX	INPFLG
002A07  1  10 03        	BPL	VARY0
002A09  1  4C F8 25     	JMP	RESFIN
002A0C  1  A0 00        VARY0:	LDY	#0
002A0E  1  B1 92        	LDADY	INPPTR		;LAST DATA CHR COULD HAVE BEEN
002A10  1               				;COMMA OR COLON BUT SHOULD BE NULL.
002A10  1  F0 07        	BEQ	INPRTS		;IT IS NULL.
002A12  1               .IF	EXTIO <> 0
002A12  1               	LDA	CHANNL		;IF NOT TERMINAL, NO TYPE.
002A12  1               	BNE	INPRTS
002A12  1               .ENDIF
002A12  1  A9 1A A0 2A  	LDWDI	EXIGNT
002A16  1  4C 9A 28     	JMP	STROUT		;TYPE "?EXTRA IGNORED"
002A19  1  60           INPRTS: RTS			;DO NEXT STATEMENT.
002A1A  1  3F 45 58 54  EXIGNT: DT"?EXTRA IGNORED"
002A1E  1  52 41 20 49  
002A22  1  47 4E 4F 52  
002A28  1  0D 0A        	ACRLF
002A2A  1  00           .BYTE	0
002A2B  1  3F 52 45 44  TRYAGN: DT"?REDO FROM START"
002A2F  1  4F 20 46 52  
002A33  1  4F 4D 20 53  
002A3B  1  0D 0A        	ACRLF
002A3D  1  00           .BYTE	0
002A3E  1               ; PAGE
002A3E  1               ; SUBTTL	THE NEXT CODE IS THE "NEXT CODE"
002A3E  1               ;
002A3E  1               ; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
002A3E  1               ;
002A3E  1               ; LOW ADDRESS
002A3E  1               ;	TOKEN (FORTK) 1 BYTE
002A3E  1               ;	A POINTER TO THE LOOP VARIABLE 2 BYTES
002A3E  1               ;	THE STEP 4+ADDPRC BYTES
002A3E  1               ;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
002A3E  1               ;	THE UPPER VALUE (PACKED) 4+ADDPRC BYTES
002A3E  1               ;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
002A3E  1               ;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
002A3E  1               ; HIGH ADDRESS
002A3E  1               ;
002A3E  1               ; TOTAL 16+2*ADDPRC BYTES.
002A3E  1               ;
002A3E  1  D0 04        NEXT:	BNE	GETFOR
002A40  1  A0 00 F0 03  	LDY	#0		;WITHOUT ARG CALL "FNDFOR" WITH
002A44  1               	BEQA	STXFOR		;[FORPNT]=0.
002A44  1  20 22 2D     GETFOR: JSR	PTRGET		;GET A POINTER TO LOOP VARIABLE
002A47  1  85 98 84 99  STXFOR: STWD	FORPNT		;INTO "FORPNT".
002A4B  1  20 A1 21     	JSR	FNDFOR		;FIND THE MATCHING ENTRY IF ANY.
002A4E  1  F0 04        	BEQ	HAVFOR
002A50  1  A2 00        	LDX	#ERRNF		;"NEXT WITHOUT FOR".
002A52  1  F0 66        ERRGO5: BEQ	ERRGO4
002A54  1  9A           HAVFOR: TXS			;SETUP STACK. CHOP FIRST.
002A55  1  8A           	TXA
002A56  1  18           	CLC
002A57  1  69 04        	ADC	#4		;POINT TO INCREMENT
002A59  1  48           	PHA			;SAVE THIS POINTER TO RESTORE TO [A]
002A5A  1  69 06        	ADC	#5+ADDPRC	;POINT TO UPPER LIMIT
002A5C  1  85 73        	STA	INDEX2		;SAVE AS INDEX
002A5E  1  68           	PLA			;RESTORE POINTER TO INCREMENT
002A5F  1  A0 01        	LDY	#1		;SET HI ADDR OF THING TO MOVE.
002A61  1  20 20 38     	JSR	MOVFM		;GET QUANTITY INTO THE FAC.
002A64  1  BA           	TSX
002A65  1  BD 09 01     	LDA	257+7+ADDPRC,X  ;SET SIGN CORRECTLY.
002A68  1  85 B5        	STA	FACSGN
002A6A  1  A5 98 A4 99  	LDWD	FORPNT
002A6E  1  20 E5 34     	JSR	FADD		;ADD INC TO LOOP VARIABLE.
002A71  1  20 4E 38     	JSR	MOVVF		;PACK THE FAC INTO MEMORY.
002A74  1  A0 01        	LDY	#1
002A76  1  20 DB 38     	JSR	FCOMPN		;COMPARE FAC WITH UPPER VALUE.
002A79  1  BA           	TSX
002A7A  1  38           	SEC
002A7B  1  FD 09 01     	SBC	257+7+ADDPRC,X  ;SUBTRACT SIGN OF INC FROM SIGN OF
002A7E  1               				;OF (CURRENT VALUE-FINAL VALUE).
002A7E  1  F0 17        	BEQ	LOOPDN		;IF SIGN (FINAL-CURRENT)-SIGN STEP=0
002A80  1               				;THEN LOOP IS DONE.
002A80  1  BD 0F 01     	LDA	2*ADDPRC+12+257,X
002A83  1  85 88        	STA	CURLIN		;STORE LINE NUMBER OF "FOR" STATEMENT.
002A85  1  BD 10 01     	LDA	257+13+(2*ADDPRC),X
002A88  1  85 89        	STA	CURLIN+1
002A8A  1  BD 12 01     	LDA	2*ADDPRC+15+257,X
002A8D  1  85 C9        	STA	TXTPTR		;STORE TEXT PNTR INTO "FOR" STATEMENT.
002A8F  1  BD 11 01     	LDA	2*ADDPRC+14+257,X
002A92  1  85 CA        	STA	TXTPTR+1
002A94  1  4C 88 25     NEWSGO: JMP	NEWSTT		;PROCESS NEXT STATEMENT.
002A97  1  8A           LOOPDN: TXA
002A98  1  69 11        	ADC	#2*ADDPRC+15		;ADDS 16 WITH CARRY.
002A9A  1  AA           	TAX
002A9B  1  9A           	TXS			;NEW STACK PNTR.
002A9C  1  20 C8 00     	JSR	CHRGOT
002A9F  1  C9 2C        	CMP	#44		;COMMA AT END?
002AA1  1  D0 F1        	BNE	NEWSGO
002AA3  1  20 C2 00     	JSR	CHRGET
002AA6  1  20 44 2A     	JSR	GETFOR		;DO NEXT BUT DON'T ALLOW BLANK VARIABLE
002AA9  1               				;PNTR. [VARPNT] IS THE STK PNTR WHICH
002AA9  1               				;NEVER MATCHES ANY POINTER.
002AA9  1               				;JSR TO PUT ON DUMMY NEWSTT ADDR.
002AA9  1               ; SUBTTL FORMULA EVALUATION CODE.
002AA9  1               ;
002AA9  1               ; THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
002AA9  1               ; [C] IS NOT PRESERVED.
002AA9  1               ;
002AA9  1  20 BD 2A     FRMNUM: JSR	FRMEVL
002AAC  1  18 24        CHKNUM: CLC
002AAE  1               	SKIP1
002AAE  1  38           CHKSTR: SEC			;SET CARRY.
002AAF  1  24 11        CHKVAL: BIT	VALTYP		;WILL NOT F UP "VALTYP".
002AB1  1  30 03        	BMI	DOCSTR
002AB3  1  B0 03        	BCS	CHKERR
002AB5  1  60           CHKOK:	RTS
002AB6  1  B0 FD        DOCSTR: BCS	CHKOK
002AB8  1  A2 18        CHKERR: LDX	#ERRTM
002ABA  1  4C 4E 22     ERRGO4: JMP	ERROR
002ABD  1               ;
002ABD  1               ; THE FORMULA EVALUATOR STARTS WITH
002ABD  1               ; [TXTPTR] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
002ABD  1               ; AT THE END [TXTPTR] POINTS TO THE TERMINATOR.
002ABD  1               ; THE RESULT IS LEFT IN THE FAC.
002ABD  1               ; ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
002ABD  1               ;
002ABD  1               ; THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
002ABD  1               ; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
002ABD  1               ; EACH OPERATOR.
002ABD  1               ; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
002ABD  1               ;	THE ADDRESS OF THE OPERATOR ROUTINE.
002ABD  1               ;	THE FLOATING POINT TEMPORARY RESULT.
002ABD  1               ;	THE PRECEDENCE OF THE OPERATOR.
002ABD  1               ;
002ABD  1  A6 C9        FRMEVL: LDX	TXTPTR
002ABF  1  D0 02        	BNE	FRMEV1
002AC1  1  C6 CA        	DEC	TXTPTR+1
002AC3  1  C6 C9        FRMEV1: DEC	TXTPTR
002AC5  1  A2 00 24     	LDX	#0		;INITIAL DUMMY PRECEDENCE IS 0.
002AC8  1               	SKIP1
002AC8  1  48           LPOPER: PHA			;SAVE LOW PRECEDENCE. (MASK.)
002AC9  1  8A           	TXA
002ACA  1  48           	PHA			;SAVE HIGH PRECEDENCE.
002ACB  1  A9 01        	LDA	#1
002ACD  1  20 12 22     	JSR	GETSTK		;MAKE SURE THERE IS ROOM FOR
002AD0  1               				;RECURSIVE CALLS.
002AD0  1  20 A2 2B     	JSR	EVAL		;EVALUATE SOMETHING.
002AD3  1  A9 00 85 9C  	CLR	OPMASK		;PREPARE TO BUILD MASK MAYBE.
002AD7  1  20 C8 00     TSTOP:	JSR	CHRGOT		;REGET LAST CHARACTER.
002ADA  1  38           LOPREL: SEC			;PREP TO SUBTRACT.
002ADB  1  E9 AA        	SBC	#GREATK		;IS CURRENT CHARACTER A RELATION?
002ADD  1  90 17        	BCC	ENDREL		;NO. RELATIONS ALL THROUGH.
002ADF  1  C9 03        	CMP	#LESSTK-GREATK+1 ;REALLY RELATIONAL?
002AE1  1  B0 13        	BCS	ENDREL		;NO -- JUST BIG.
002AE3  1  C9 01        	CMP	#1		;RESET CARRY FOR ZERO ONLY.
002AE5  1  2A           	ROL	A 		;0 TO 1, 1 TO 2, 2 TO 4.
002AE6  1  49 01        	EOR	#1
002AE8  1  45 9C        	EOR	OPMASK		;BRING IN THE OLD BITS.
002AEA  1  C5 9C        	CMP	OPMASK		;MAKE SURE THE NEW MASK IS BIGGER.
002AEC  1  90 61        	BCC	SNERR5		;SYNTAX ERROR. BECAUSE TWO OF THE SAME.
002AEE  1  85 9C        	STA	OPMASK		;SAVE MASK.
002AF0  1  20 C2 00     	JSR	CHRGET
002AF3  1  4C DA 2A     	JMP	LOPREL		;GET THE NEXT CANDIDATE.
002AF6  1  A6 9C        ENDREL: LDX	OPMASK		;WERE THERE ANY?
002AF8  1  D0 2C        	BNE	FINREL		;YES, HANDLE AS SPECIAL OP.
002AFA  1  B0 7B        	BCS	QOP		;NOT AN OPERATOR.
002AFC  1  69 07        	ADC	#GREATK-PLUSTK
002AFE  1  90 77        	BCC	QOP		;NOT AN OPERATOR.
002B00  1  65 11        	ADC	VALTYP		;[C]=1.
002B02  1  D0 03 4C BA  	JEQ	CAT		;ONLY IF [A]=0 AND [VALTYP]=-1 (A STR).
002B06  1  32           
002B07  1  69 FF        	ADC	#$FF		;GET BACK ORIGINAL [A].
002B09  1  85 71        	STA	INDEX1
002B0B  1  0A           	ASL	A 		;MULTIPLY BY 2.
002B0C  1  65 71        	ADC	INDEX1		;BY THREE.
002B0E  1  A8           	TAY			;SET UP FOR LATER.
002B0F  1  68           QPREC:	PLA			;GET PREVIOUS PRECEDENCE.
002B10  1  D9 66 20     	CMP	OPTAB,Y		;IS OLD PRECEDENCE GREATER OR EQUAL?
002B13  1  B0 67        	BCS	QCHNUM		;YES, GO OPERATE.
002B15  1  20 AC 2A     	JSR	CHKNUM		;CAN'T BE STRING HERE.
002B18  1  48           DOPREC: PHA			;SAVE OLD PRECEDENCE.
002B19  1  20 3F 2B     NEGPRC: JSR	DOPRE1		;SET A RETURN ADDRESS FOR OP.
002B1C  1  68           	PLA			;PULL OFF PREVIOUS PRECEDENCE.
002B1D  1  A4 9A        	LDY	OPPTR		;GET POINTER TO OP.
002B1F  1  10 17        	BPL	QPREC1		;THAT'S A REAL OPERATOR.
002B21  1  AA           	TAX			;DONE ?
002B22  1  F0 56        	BEQ	QOPGO		;DONE !
002B24  1  D0 5F        	BNE	PULSTK
002B26  1  46 11        FINREL: LSR	VALTYP		;GET VALUE TYPE INTO "C".
002B28  1  8A           	TXA
002B29  1  2A           	ROL	A 		;PUT VALTYP INTO LOW ORDER BIT OF MASK.
002B2A  1  A6 C9        	LDX	TXTPTR		;DECREMENT TEXT POINTER.
002B2C  1  D0 02        	BNE	FINRE2
002B2E  1  C6 CA        	DEC	TXTPTR+1
002B30  1  C6 C9        FINRE2: DEC	TXTPTR
002B32  1  A0 1B        	LDY	#PTDORL-OPTAB	;MAKE [YREG] POINT AT OPERATOR ENTRY.
002B34  1  85 9C        	STA	OPMASK		;SAVE THE OPERATION MASK.
002B36  1  D0 D7        	BNE	QPREC		;SAVE IT ALL. BR ALWAYS.
002B38  1               				;NOTE B7(VALTYP)=0 SO CHKNUM CALL IS OK.
002B38  1  D9 66 20     QPREC1: CMP	OPTAB,Y		;LAST PRECEDENCE IS GREATER?
002B3B  1  B0 48        	BCS	PULSTK		;YES, GO OPERATE.
002B3D  1  90 D9        	BCC	DOPREC		;NO SAVE ARGUMENT AND GET OTHER OPERAND.
002B3F  1  B9 68 20     DOPRE1: LDA	OPTAB+2,Y
002B42  1  48           	PHA			;DISP ADDR GOES ONTO STACK.
002B43  1  B9 67 20     	LDA	OPTAB+1,Y
002B46  1  48           	PHA
002B47  1  20 52 2B     	JSR	PUSHF1		;SAVE FAC ON STACK UNPACKED.
002B4A  1  A5 9C        	LDA	OPMASK		;[ACCA] MAY BE MASK FOR REL.
002B4C  1  4C C8 2A     	JMP	LPOPER
002B4F  1  4C 0E 2C     SNERR5: JMP	SNERR		;GO TO AN ERROR.
002B52  1  A5 B5        PUSHF1: LDA	FACSGN
002B54  1  BE 66 20     	LDX	OPTAB,Y 	;GET HIGH PRECEDENCE.
002B57  1  A8           PUSHF:	TAY			;GET POINTER INTO STACK.
002B58  1  68           	PLA
002B59  1  85 71        	STA	INDEX1
002B5B  1  E6 71        	INC	INDEX1
002B5D  1  68           	PLA
002B5E  1  85 72        	STA	INDEX1+1
002B60  1  98           	TYA
002B61  1               				;STORE FAC ON STACK UNPACKED.
002B61  1  48           	PHA			;START WITH SIGN SET UP.
002B62  1  20 99 38     FORPSH: JSR	ROUND		;PUT ROUNDED FAC ON STACK.
002B65  1  A5 B4        	LDA	FACLO		;ENTRY POINT TO SKIP STORING SIGN.
002B67  1  48           	PHA
002B68  1  A5 B3        	LDA	FACMO
002B6A  1  48           	PHA
002B6B  1               .IF	ADDPRC <> 0
002B6B  1  A5 B2        	LDA	FACMOH
002B6D  1  48           	PHA
002B6E  1               .ENDIF
002B6E  1  A5 B1        	LDA	FACHO
002B70  1  48           	PHA
002B71  1  A5 B0        	LDA	FACEXP
002B73  1  48           	PHA
002B74  1  6C 71 00     	JMPD	INDEX1		;RETURN.
002B77  1  A0 FF        QOP:	LDY	#255
002B79  1  68           	PLA			;GET HIGH PRECEDENCE OF LAST OP.
002B7A  1  F0 23        QOPGO:	BEQ	QOPRTS		;DONE !
002B7C  1  C9 64        QCHNUM: CMP	#100		;RELATIONAL OPERATOR?
002B7E  1  F0 03        	BEQ	UNPSTK		;YES, DON'T CHECK OPERAND.
002B80  1  20 AC 2A     	JSR	CHKNUM		;MUST BE NUMBER.
002B83  1  84 9A        UNPSTK: STY	OPPTR		;SAVE OPERATOR'S POINTER FOR NEXT TIME.
002B85  1  68           PULSTK: PLA			;GET MASK FOR REL OP IF IT IS ONE.
002B86  1  4A           	LSR	A 		;SETUP [C] FOR DOREL'S "CHKVAL".
002B87  1  85 16        	STA	DOMASK		;SAVE FOR "DOCMP".
002B89  1  68           	PLA			;UNPACK STACK INTO ARG.
002B8A  1  85 B8        	STA	ARGEXP
002B8C  1  68           	PLA
002B8D  1  85 B9        	STA	ARGHO
002B8F  1               .IF	ADDPRC <> 0
002B8F  1  68           	PLA
002B90  1  85 BA        	STA	ARGMOH
002B92  1               .ENDIF
002B92  1  68           	PLA
002B93  1  85 BB        	STA	ARGMO
002B95  1  68           	PLA
002B96  1  85 BC        	STA	ARGLO
002B98  1  68           	PLA
002B99  1  85 BD        	STA	ARGSGN
002B9B  1  45 B5        	EOR	FACSGN		;GET PROBABLE RESULT SIGN.
002B9D  1  85 BE        	STA	ARISGN		;ARITHMETIC SIGN. USED BY
002B9F  1               				;ADD, SUB, MULT, DIV.
002B9F  1  A5 B0        QOPRTS: LDA	FACEXP		;GET IT AND SET CODES.
002BA1  1  60           UNPRTS: RTS			;RETURN.
002BA2  1               
002BA2  1  A9 00 85 11  EVAL:	CLR	VALTYP		;ASSUME VALUE WILL BE NUMERIC.
002BA6  1  20 C2 00     EVAL0:	JSR	CHRGET		;GET A CHARACTER.
002BA9  1  B0 03        	BCS	EVAL2
002BAB  1  4C 71 39     EVAL1:	JMP	FIN		;IT IS A NUMBER.
002BAE  1  20 AC 2D     EVAL2:	JSR	ISLETC		;VARIABLE NAME?
002BB1  1  B0 67        	BCS	ISVAR		;YES.
002BB3  1               .IF	REALIO-3 = 0
002BB3  1               	CMP	#PI
002BB3  1               	BNE	QDOT
002BB3  1               	LDWDI	PIVAL
002BB3  1               	JSR	MOVFM		;PUT VALUE IN FOR PI.
002BB3  1               	JMP	CHRGET
002BB3  1               PIVAL:	.BYTE $82
002BB3  1               .BYTE	$49
002BB3  1               .BYTE	$F
002BB3  1               .BYTE	$DA
002BB3  1               .BYTE	$A1
002BB3  1               .ENDIF
002BB3  1  C9 2E        QDOT:	CMP	#'.'		;LEADING CHARACTER OF CONSTANT?
002BB5  1  F0 F4        	BEQ	EVAL1
002BB7  1  C9 A4        	CMP	#MINUTK		;NEGATION?
002BB9  1  F0 58        	BEQ	DOMIN		;SHO IS.
002BBB  1  C9 A3        	CMP	#PLUSTK
002BBD  1  F0 E7        	BEQ	EVAL0
002BBF  1  C9 22        	CMP	#34		;A QUOTE? A STRING?
002BC1  1  D0 0F        	BNE	EVAL3
002BC3  1  A5 C9 A4 CA  STRTXT: LDWD	TXTPTR
002BC7  1  69 00        	ADC	#0		;TO INC, ADD C=1.
002BC9  1  90 01        	BCC	STRTX2
002BCB  1  C8           	INY
002BCC  1  20 03 31     STRTX2: JSR	STRLIT		;YES. GO PROCESS IT.
002BCF  1  4C 60 34     	JMP	ST2TXT
002BD2  1  C9 A1        EVAL3:	CMP	#NOTTK		;CHECK FOR "NOT" OPERATOR.
002BD4  1  D0 13        	BNE	EVAL4
002BD6  1  A0 18        	LDY	#NOTTAB-OPTAB		;"NOT" HAS PRECEDENCE 90.
002BD8  1  D0 3B        	BNE	GONPRC		;GO DO ITS EVALUATION.
002BDA  1  20 3C 2E     NOTOP:	JSR	AYINT		;INTEGERIZE.
002BDD  1  A5 B4        	LDA	FACLO		;GET THE ARGUMENT.
002BDF  1  49 FF        	EOR	#255
002BE1  1  A8           	TAY
002BE2  1  A5 B3        	LDA	FACMO
002BE4  1  49 FF        	EOR	#255
002BE6  1  4C 0F 30     	JMP	GIVAYF		;FLOAT [Y,A] AS RESULT IN FAC.
002BE9  1               				;AND RETURN.
002BE9  1  C9 9E        EVAL4:	CMP	#FNTK		;USER-DEFINED FUNCTION?
002BEB  1  D0 03 4C 70  	JEQ	FNDOER
002BEF  1  30           
002BF0  1  C9 AD        	CMP	#ONEFUN		;A FUNCTION NAME?
002BF2  1  90 03        	BCC	PARCHK		;FUNCTIONS ARE THE HIGHEST NUMBERED
002BF4  1  4C 3E 2C     	JMP	ISFUN		;CHARACTERS SO NO NEED TO CHECK
002BF7  1               				;AN UPPER-BOUND.
002BF7  1  20 00 2C     PARCHK: JSR	CHKOPN		;ONLY POSSIBILITY LEFT IS
002BFA  1  20 BD 2A     	JSR	FRMEVL		;A FORMULA IN PARENTHESIS.
002BFD  1               				;RECURSIVELY EVALUATE THE FORMULA.
002BFD  1  A9 29 2C     CHKCLS: LDA	#41		;CHECK FOR A RIGHT PARENTHESE
002C00  1               	SKIP2
002C00  1  A9 28 2C     CHKOPN: LDA	#40
002C03  1               	SKIP2
002C03  1  A9 2C        CHKCOM: LDA	#44
002C05  1               ;
002C05  1               ; "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
002C05  1               ; IS THE SPECIFIC THING LOADED INTO ACCA JUST BEFORE THE CALL TO
002C05  1               ; "SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
002C05  1               ; OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
002C05  1               ;
002C05  1               ; [A]=NEW CHAR AND TXTPTR IS ADVANCED BY "CHRGET".
002C05  1               ;
002C05  1  A0 00        SYNCHR: LDY	#0
002C07  1  D1 C9        	CMPDY	TXTPTR		;CHARACTERS EQUAL?
002C09  1  D0 03        	BNE	SNERR
002C0B  1  4C C2 00     CHRGO5: JMP	CHRGET
002C0E  1  A2 02        SNERR:	LDX	#ERRSN		;"SYNTAX ERROR"
002C10  1  4C 4E 22     	JMP	ERROR
002C13  1  A0 15        DOMIN:	LDY	#NEGTAB-OPTAB	;A PRECEDENCE BELOW "^".
002C15  1  68           GONPRC: PLA			;GET RID OF RTS ADDR.
002C16  1  68           	PLA
002C17  1  4C 19 2B     	JMP	NEGPRC		;EVALUTE FOR NEGATION.
002C1A  1               
002C1A  1  20 22 2D     ISVAR:	JSR	PTRGET		;GET A PNTR TO VARIABLE.
002C1D  1  85 B3 84 B4  ISVRET: STWD	FACMO
002C21  1               .IF	(TIME|EXTIO) <> 0
002C21  1               	LDWD	VARNAM		;CHECK TIME,TIME$,STATUS.
002C21  1               .ENDIF
002C21  1  A6 11        	LDX	VALTYP
002C23  1  F0 05        	BEQ	GOOO		;THE STRING IS SET UP.
002C25  1  A2 00        	LDX	#0
002C27  1  86 BF        	STX	FACOV
002C29  1               .IF	TIME <> 0
002C29  1               	BIT	FACLO		;AN ARRAY?
002C29  1               	BPL	STRRTS		;YES.
002C29  1               	CMP	#'T'		;TI$?
002C29  1               	BNE	STRRTS
002C29  1               	CPY	#'I'+128
002C29  1               	BNE	STRRTS
002C29  1               	JSR	GETTIM		;YES. PUT TIME IN FACMOH-LO.
002C29  1               	STY	TENEXP		;Y=0.
002C29  1               	DEY
002C29  1               	STY	FBUFPT
002C29  1               	LDY	#6		;SIX	DIGITS TO PRINT.
002C29  1               	STY	DECCNT
002C29  1               	LDY	#FDCEND-FOUTBL
002C29  1               	JSR	FOUTIM		;CONVERT TO ASCII.
002C29  1               	JMP	TIMSTR
002C29  1               .ENDIF
002C29  1  60           STRRTS: RTS
002C2A  1               GOOO:
002C2A  1               .IF	INTPRC <> 0
002C2A  1  A6 12        	LDX	INTFLG
002C2C  1  10 0D        	BPL	GOOOOO
002C2E  1  A0 00        	LDY	#0
002C30  1  B1 B3        	LDADY	FACMO		;FETCH HIGH.
002C32  1  AA           	TAX
002C33  1  C8           	INY
002C34  1  B1 B3        	LDADY	FACMO
002C36  1  A8           	TAY			;PUT LOW IN Y.
002C37  1  8A           	TXA			;GET HIGH IN A.
002C38  1  4C 0F 30     	JMP	GIVAYF		;FLOAT AND RETURN.
002C3B  1               .ENDIF
002C3B  1               GOOOOO:
002C3B  1               .IF	TIME <> 0
002C3B  1               	BIT	FACLO		;AN ARRAY?
002C3B  1               	BPL	GOMOVF		;YES.
002C3B  1               	CMP	#'T'
002C3B  1               	BNE	QSTATV
002C3B  1               	CPY	#'I'
002C3B  1               	BNE	GOMOVF
002C3B  1               	JSR	GETTIM
002C3B  1               	TYA			;FOR FLOATB.
002C3B  1               	LDX	#160		;SET EXPONNENT.
002C3B  1               	JMP	FLOATB
002C3B  1               GETTIM: LDWDI	CQTIMR-2
002C3B  1               	SEI			;TURN OF INT SYS.
002C3B  1               	JSR	MOVFM
002C3B  1               	CLI			;BACK ON.
002C3B  1               	STY	FACHO		;ZERO HIGHEST.
002C3B  1               	RTS
002C3B  1               .ENDIF
002C3B  1               QSTATV:
002C3B  1               .IF	EXTIO <> 0
002C3B  1               	CMP	#'S'
002C3B  1               	BNE	GOMOVF
002C3B  1               	CPY	#'T'
002C3B  1               	BNE	GOMOVF
002C3B  1               	LDA	CQSTAT
002C3B  1               	JMP	FLOAT
002C3B  1               GOMOVF:
002C3B  1               .ENDIF
002C3B  1               .IF	(TIME|EXTIO) <> 0
002C3B  1               	LDWD	FACMO
002C3B  1               .ENDIF
002C3B  1  4C 20 38     	JMP	MOVFM		;MOVE ACTUAL VALUE IN.
002C3E  1               				;AND RETURN.
002C3E  1               
002C3E  1  0A           ISFUN:	ASL	A 		;MULTIPLY BY TWO.
002C3F  1  48           	PHA
002C40  1  AA           	TAX
002C41  1  20 C2 00     	JSR	CHRGET		;SET UP FOR SYNCHK.
002C44  1  E0 81        	CPX	#2*LASNUM-256+1	;IS IT PAST "LASNUM"?
002C46  1  90 20        	BCC	OKNORM		;NO, MUST BE NORMAL FUNCTION.
002C48  1               ;
002C48  1               ; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
002C48  1               ; THE RETURN ADDRESS OF THESE FUNCTIONS IS "CHKNUM"
002C48  1               ; WHICH ASCERTAINS THAT [VALTYP]=0  (NUMERIC).
002C48  1               ; NORMAL FUNCTIONS THAT RETURN STRING RESULTS
002C48  1               ; (E.G., CHR$) MUST POP OFF THAT RETURN ADDR AND
002C48  1               ; RETURN DIRECTLY TO "FRMEVL".
002C48  1               ;
002C48  1               ; THE SO-CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT,
002C48  1               ; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
002C48  1               ; MUST BE A NUMBER BETWEEN 0 AND 255.
002C48  1               ; THE CLOSED PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
002C48  1               ; TO "FRMEVL" WITH THE TEXT PNTR POINTING BEYOND THE ")".
002C48  1               ; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
002C48  1               ; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE
002C48  1               ; INTEGER ARGUMENT.
002C48  1               ;
002C48  1  20 00 2C     	JSR	CHKOPN		;CHECK FOR AN OPEN PARENTHESE
002C4B  1  20 BD 2A     	JSR	FRMEVL		;EAT OPEN PAREN AND FIRST ARG.
002C4E  1  20 03 2C     	JSR	CHKCOM		;TWO ARGS SO COMMA MUST DELIMIT.
002C51  1  20 AE 2A     	JSR	CHKSTR		;MAKE SURE FIRST WAS STRING.
002C54  1  68           	PLA			;GET FUNCTION NUMBER.
002C55  1  AA           	TAX
002C56  1  A5 B4 48 A5  	PSHWD	FACMO		;SAVE POINTER AT STRING DESCRIPTOR
002C5A  1  B3 48        
002C5C  1  8A           	TXA
002C5D  1  48           	PHA			;RESAVE FUNCTION NUMBER.
002C5E  1               				;THIS MUST BE ON STACK SINCE RECURSIVE.
002C5E  1  20 1B 34     	JSR	GETBYT		;[X]=VALUE OF FORMULA.
002C61  1  68           	PLA			;GET FUNCTION NUMBER.
002C62  1  A8           	TAY
002C63  1  8A           	TXA
002C64  1  48           	PHA
002C65  1  4C 6D 2C     	JMP	FINGO		;DISPATCH TO FUNCTION.
002C68  1  20 F7 2B     OKNORM: JSR	PARCHK		;READ A FORMULA SURROUNDED BY PARENS.
002C6B  1  68           	PLA			;GET DISPATCH FUNCTION.
002C6C  1  A8           	TAY
002C6D  1               ;	.OUT	.SPRINTF("FUNDSP=%d ONEFUN=%d", FUNDSP, ONEFUN)	;LGB - test point
002C6D  1  B9 DE 1F     FINGO:	LDA	FUNDSP-2*ONEFUN+256,Y 	;MODIFY DISPATCH ADDRESS.
002C70  1  85 A4        	STA	JMPER+1
002C72  1  B9 DF 1F     	LDA	FUNDSP-2*ONEFUN+257,Y
002C75  1  85 A5        	STA	JMPER+2
002C77  1  20 A3 00     	JSR	JMPER		;DISPATCH!
002C7A  1               				;STRING FUNCTIONS REMOVE THIS RET ADDR.
002C7A  1  4C AC 2A     	JMP	CHKNUM		;CHECK IT FOR NUMERICNESS AND RETURN.
002C7D  1               
002C7D  1  A0 FF 2C     OROP:	LDY	#255		;MUST ALWAYS COMPLEMENT..
002C80  1               	SKIP2
002C80  1  A0 00        ANDOP:	LDY	#0
002C82  1  84 0F        	STY	COUNT		;OPERATOR.
002C84  1  20 3C 2E     	JSR	AYINT		;[FACMO&LO]=INT VALUE AND CHECK SIZE.
002C87  1  A5 B3        	LDA	FACMO		;USE DEMORGAN'S LAW ON HIGH
002C89  1  45 0F        	EOR	COUNT
002C8B  1  85 0D        	STA	INTEGR
002C8D  1  A5 B4        	LDA	FACLO		;AND LOW.
002C8F  1  45 0F        	EOR	COUNT
002C91  1  85 0E        	STA	INTEGR+1
002C93  1  20 7A 38     	JSR	MOVFA
002C96  1  20 3C 2E     	JSR	AYINT		;[FACMO&LO]=INT OF ARG.
002C99  1  A5 B4        	LDA	FACLO
002C9B  1  45 0F        	EOR	COUNT
002C9D  1  25 0E        	AND	INTEGR+1
002C9F  1  45 0F        	EOR	COUNT		;FINISH OUT DEMORGAN.
002CA1  1  A8           	TAY			;SAVE HIGH.
002CA2  1  A5 B3        	LDA	FACMO
002CA4  1  45 0F        	EOR	COUNT
002CA6  1  25 0D        	AND	INTEGR
002CA8  1  45 0F        	EOR	COUNT
002CAA  1  4C 0F 30     	JMP	GIVAYF		;FLOAT [A.Y] AND RET TO USER.
002CAD  1               
002CAD  1               ;
002CAD  1               ; TIME TO PERFORM A RELATIONAL OPERATOR.
002CAD  1               ; [DOMASK] CONTAINS THE BITS AS TO WHICH RELATIONAL
002CAD  1               ; OPERATOR IT WAS. CARRY BIT ON=STRING COMPARE.
002CAD  1               ;
002CAD  1  20 AF 2A     DOREL:	JSR	CHKVAL		;CHECK FOR MATCH.
002CB0  1  B0 13        	BCS	STRCMP		;IT IS A STRING.
002CB2  1  A5 BD        	LDA	ARGSGN		;PACK ARG FOR FCOMP.
002CB4  1  09 7F        	ORA	#127
002CB6  1  25 B9        	AND	ARGHO
002CB8  1  85 B9        	STA	ARGHO
002CBA  1  A9 B8 A0 00  	LDWDI	ARGEXP
002CBE  1  20 D9 38     	JSR	FCOMP
002CC1  1  AA           	TAX
002CC2  1  4C F8 2C     	JMP	QCOMP
002CC5  1  A9 00 85 11  STRCMP: CLR	VALTYP		;RESULT WILL BE NUMERIC.
002CC9  1  C6 9C        	DEC	OPMASK		;TURN OFF VALTYP WHICH WAS STRING.
002CCB  1  20 23 33     	JSR	FREFAC		;FREE THE FACLO STRING.
002CCE  1  85 B0        	STA	DSCTMP		;SAVE FOR LATER.
002CD0  1  86 B1 84 B2  	STXY	DSCTMP+1
002CD4  1  A5 BB A4 BC  	LDWD	ARGMO		;GET POINTER TO OTHER STRING.
002CD8  1  20 27 33     	JSR	FRETMP		;FREES FIRST DESC POINTER.
002CDB  1  86 BB 84 BC  	STXY	ARGMO
002CDF  1  AA           	TAX			;COPY COUNT INTO X.
002CE0  1  38           	SEC
002CE1  1  E5 B0        	SBC	DSCTMP		;WHICH IS GREATER. IF 0, ALL SET UP.
002CE3  1  F0 08        	BEQ	STASGN		;JUST PUT SIGN OF DIFFERENCE AWAY.
002CE5  1  A9 01        	LDA	#1
002CE7  1  90 04        	BCC	STASGN		;SIGN IS POSITIVE.
002CE9  1  A6 B0        	LDX	DSCTMP		;LENGTH OF FAC IS SHORTER.
002CEB  1  A9 FF        	LDA	#$FF		;GET A MINUS 1 FOR NEGATIVES.
002CED  1  85 B5        STASGN: STA	FACSGN		;KEEP FOR LATER.
002CEF  1  A0 FF        	LDY	#255		;SET POINTER TO FIRST STRING. (ARG.)
002CF1  1  E8           	INX			;TO LOOP PROPERLY.
002CF2  1  C8           NXTCMP: INY
002CF3  1  CA           	DEX			;ANY CHARACTERS LEFT TO COMPARE?
002CF4  1  D0 07        	BNE	GETCMP		;NOT DONE YET.
002CF6  1  A6 B5        	LDX	FACSGN		;USE SIGN OF LENGTH DIFFERENCE
002CF8  1               				;SINCE ALL CHARACTERS ARE THE SAME.
002CF8  1  30 0F        QCOMP:	BMI	DOCMP		;C IS ALWAYS SET THEN.
002CFA  1  18           	CLC
002CFB  1  90 0C        	BCC	DOCMP		;ALWAYS BRANCH.
002CFD  1  B1 BB        GETCMP: LDADY	ARGMO		;GET NEXT CHAR TO COMPARE.
002CFF  1  D1 B1        	CMPDY	DSCTMP+1	;SAME?
002D01  1  F0 EF        	BEQ	NXTCMP		;YEP. TRY FURTHER.
002D03  1  A2 FF        	LDX	#$FF		;SET A POSITIVE DIFFERENCE.
002D05  1  B0 02        	BCS	DOCMP		;PUT STACK BACK TOGETHER.
002D07  1  A2 01        	LDX	#1		;SET A NEGATIVE DIFFERENCE.
002D09  1  E8           DOCMP:	INX			;-1 TO 1, 0 TO 2, 1 TO 4.
002D0A  1  8A           	TXA
002D0B  1  2A           	ROL	A
002D0C  1  25 16        	AND	DOMASK
002D0E  1  F0 02        	BEQ	GOFLOT
002D10  1  A9 FF        	LDA	#$FF		;MAP 0 TO 0. ALL OTHERS TO -1.
002D12  1  4C BA 38     GOFLOT: JMP	FLOAT		;FLOAT THE ONE-BYTE RESULT INTO FAC.
002D15  1               
002D15  1               ; PAGE
002D15  1               ; SUBTTL	DIMENSION AND VARIABLE SEARCHING.
002D15  1               ;
002D15  1               ; THE "DIM" CODE SETS [DIMFLG] AND THEN FALLS INTO THE VARIABLE SEARCH
002D15  1               ; ROUTINE, WHICH LOOKS AT DIMFLG AT THREE DIFFERENT POINTS.
002D15  1               ;	1) IF AN ENTRY IS FOUND, "DIMFLG" BEING ON INDICATES
002D15  1               ;		A "DOUBLY" DIMENSIONED VARIABLE.
002D15  1               ;	2) WHEN A NEW ENTRY IS BEING BUILT "DIMFLG" BEING ON
002D15  1               ;		INDICTAES THE INDICES SHOULD BE USED FOR THE
002D15  1               ;		SIZE OF EACH INDEX. OTHERWISE THE DEFAULT OF TEN
002D15  1               ;		IS USED.
002D15  1               ;	3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF "DIMFLG" IS OFF
002D15  1               ;		WILL INDEXING BE DONE.
002D15  1               ;
002D15  1  20 03 2C     DIM3:	JSR	CHKCOM		;MUST BE A COMMA
002D18  1  AA           DIM:	TAX			;SET [ACCX] NONZERO.
002D19  1               				;[ACCA] MUST BE NONZERO TO WORK RIGHT.
002D19  1  20 27 2D     DIM1:	JSR	PTRGT1
002D1C  1  20 C8 00     DIMCON: JSR	CHRGOT		;GET LAST CHARACTER.
002D1F  1  D0 F4        	BNE	DIM3
002D21  1  60           	RTS
002D22  1               ;
002D22  1               ; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
002D22  1               ; AND  PUT A POINTER TO ITS VALUE IN VARPNT. [TXTPTR]
002D22  1               ; POINTS TO THE TERMINATING CHARCTER.. NOT THAT EVALUATING SUBSCRIPTS
002D22  1               ; IN A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO "PTRGET" SO AT
002D22  1               ; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
002D22  1               ;
002D22  1  A2 00        PTRGET: LDX	#0		;MAKE [ACCX]=0.
002D24  1  20 C8 00     	JSR	CHRGOT		;RETRIEVE LAST CHARACTER.
002D27  1  86 10        PTRGT1: STX	DIMFLG		;STORE FLAG AWAY.
002D29  1  85 94        PTRGT2: STA	VARNAM
002D2B  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER
002D2E  1               				;MAYBE WITH FUNCTION BIT OFF.
002D2E  1  20 AC 2D     	JSR	ISLETC		;CHECK FOR LETTER.
002D31  1  B0 03        	BCS	PTRGT3		;MUST HAVE A LETTER.
002D33  1  4C 0E 2C     INTERR: JMP	SNERR
002D36  1  A2 00        PTRGT3: LDX	#0		;ASSUME NO SECOND CHARACTER.
002D38  1  86 11        	STX	VALTYP		;DEFAULT IS NUMERIC.
002D3A  1               .IF	INTPRC <> 0
002D3A  1  86 12        	STX	INTFLG		;ASSUME FLOATING.
002D3C  1               .ENDIF
002D3C  1  20 C2 00     	JSR	CHRGET		;GET FOLLOWING CHARACTER.
002D3F  1  90 05        	BCC	ISSEC		;CARRY RESET BY CHRGET IF NUMERIC.
002D41  1  20 AC 2D     	JSR	ISLETC		;SET CARRY IF NOT ALPHABETIC.
002D44  1  90 0B        	BCC	NOSEC		;ALLOW ALPHABETICS.
002D46  1  AA           ISSEC:	TAX			;IT IS A NUMBER -- SAVE IN ACCX.
002D47  1  20 C2 00     EATEM:	JSR	CHRGET		;LOOK AT NEXT CHARACTER.
002D4A  1  90 FB        	BCC	EATEM		;SKIP NUMERICS.
002D4C  1  20 AC 2D     	JSR	ISLETC
002D4F  1  B0 F6        	BCS	EATEM		;SKIP ALPHABETICS.
002D51  1  C9 24        NOSEC:	CMP	#'$'		;IS IT A STRING?
002D53  1  D0 06        	BNE	NOTSTR		;IF NOT, [VALTYP]=0.
002D55  1  A9 FF        	LDA	#$FF		;SET [VALTYP]=255 (STRING !).
002D57  1  85 11        	STA	VALTYP
002D59  1  D0 10        .IF	INTPRC <> 0
002D5B  1               	BNEA	TURNON		;ALWAYS GOES.
002D5B  1  C9 25        NOTSTR: CMP	#'%'		;INTEGER VARIABLE?
002D5D  1  D0 13        	BNE	STRNAM		;NO.
002D5F  1  A5 14        	LDA	SUBFLG
002D61  1  D0 D0        	BNE	INTERR
002D63  1  A9 80        	LDA	#128
002D65  1  85 12        	STA	INTFLG		;SET FLAG.
002D67  1  05 94        	ORA	VARNAM		;TURN ON BOTH HIGH BITS.
002D69  1  85 94        	STA	VARNAM
002D6B  1               .ENDIF
002D6B  1  8A           TURNON: TXA
002D6C  1  09 80        	ORA	#128		;TURN ON MSB OF SECOND CHARACTER.
002D6E  1  AA           	TAX
002D6F  1  20 C2 00     	JSR	CHRGET		;GET CHARACTER AFTER $.
002D72  1               .IF	INTPRC = 0
002D72  1               NOTSTR:
002D72  1               .ENDIF
002D72  1  86 95        STRNAM: STX	VARNAM+1	;STORE AWAY SECOND CHARACTER.
002D74  1  38           	SEC
002D75  1  05 14        	ORA	SUBFLG		;ADD FLAG WHETHER TO ALLOW ARRAYS.
002D77  1  E9 28        	SBC	#40		;(CHECK FOR "(") WON'T MATCH IF SUBFLG SET.
002D79  1  D0 03 4C 4E  	JEQ	ISARY		;IT IS!
002D7D  1  2E           
002D7E  1  A9 00 85 14  	CLR	SUBFLG		;ALLOW SUBSCRIPTS AGAIN.
002D82  1  A5 7C        	LDA	VARTAB		;PLACE TO START SEARCH.
002D84  1  A6 7D        	LDX	VARTAB+1
002D86  1  A0 00        	LDY	#0
002D88  1  86 AF        STXFND: STX	LOWTR+1
002D8A  1  85 AE        LOPFND: STA	LOWTR
002D8C  1  E4 7F        	CPX	ARYTAB+1	;AT END OF TABLE YET?
002D8E  1  D0 04        	BNE	LOPFN
002D90  1  C5 7E        	CMP	ARYTAB
002D92  1  F0 22        	BEQ	NOTFNS		;YES. WE COULDN'T FIND IT.
002D94  1  A5 94        LOPFN:	LDA	VARNAM
002D96  1  D1 AE        	CMPDY	LOWTR		;COMPARE HIGH ORDERS.
002D98  1  D0 08        	BNE	NOTIT		;NO COMPARISON.
002D9A  1  A5 95        	LDA	VARNAM+1
002D9C  1  C8           	INY
002D9D  1  D1 AE        	CMPDY	LOWTR		;AND THE LOW PART?
002D9F  1  F0 6A        	BEQ	FINPTR		;THAT'S IT ! THAT'S IT !
002DA1  1  88           	DEY
002DA2  1  18           NOTIT:	CLC
002DA3  1  A5 AE        	LDA	LOWTR
002DA5  1  69 07        	ADC	#6+ADDPRC	;MAKES NO DIF AMONG TYPES.
002DA7  1  90 E1        	BCC	LOPFND
002DA9  1  E8 D0 DC     	INX
002DAC  1               	BNEA	STXFND		;ALWAYS BRANCHES.
002DAC  1               
002DAC  1               ;
002DAC  1               ; TEST FOR A LETTER.	/ CARRY OFF= NOT A LETTER.
002DAC  1               ;			  CARRY ON= A LETTER.
002DAC  1               ;
002DAC  1  C9 41        ISLETC: CMP	#'A'
002DAE  1  90 05        	BCC	ISLRTS		;IF LESS THAN "A", RET.
002DB0  1  E9 5B        	SBC	#'Z'+1
002DB2  1  38           	SEC
002DB3  1  E9 A5        	SBC	#256-'Z'-1	;RESET CARRY IF [A] .GT. "Z".
002DB5  1  60           ISLRTS: RTS			;RETURN TO CALLER.
002DB6  1               
002DB6  1  68           NOTFNS: PLA			;CHECK WHO'S CALLING.
002DB7  1  48           	PHA			;RESTORE IT.
002DB8  1  C9 1C        	CMP	#ISVRET-1-(ISVRET-1)/256*256	;IS EVAL CALLING?
002DBA  1  D0 0D        	BNE	NOTEVL		;NO, CARRY ON.
002DBC  1               .IF	REALIO-3 <> 0
002DBC  1  BA           	TSX
002DBD  1  BD 02 01     	LDA	258,X
002DC0  1  C9 2C        	CMP	#(ISVRET-1)/256
002DC2  1  D0 05        	BNE	NOTEVL
002DC4  1               .ENDIF
002DC4  1  A9 8D A0 3B  LDZR:	LDWDI	ZERO		;SET UP PNTR TO SIMULATED ZERO.
002DC8  1  60           	RTS			;FOR STRINGS OR NUMERIC.
002DC9  1               				;AND FOR INTEGERS TOO.
002DC9  1               NOTEVL:
002DC9  1               .IF	(TIME|EXTIO) <> 0
002DC9  1               	LDWD	VARNAM
002DC9  1               .ENDIF
002DC9  1               .IF	TIME <> 0
002DC9  1               	CMP	#'T'
002DC9  1               	BNE	QSTAVR
002DC9  1               	CPY	#'I'+128
002DC9  1               	BEQ	LDZR
002DC9  1               	CPY	#'I'
002DC9  1               	BNE	QSTAVR
002DC9  1               .ENDIF
002DC9  1               .IF	(EXTIO|TIME) <> 0
002DC9  1               GOBADV: JMP	SNERR
002DC9  1               .ENDIF
002DC9  1               QSTAVR:
002DC9  1               .IF	EXTIO <> 0
002DC9  1               	CMP	#'S'
002DC9  1               	BNE	VAROK
002DC9  1               	CPY	#'T'
002DC9  1               	BEQ	GOBADV
002DC9  1               .ENDIF
002DC9  1  A5 7E A4 7F  VAROK:	LDWD	ARYTAB
002DCD  1  85 AE 84 AF  	STWD	LOWTR		;LOWEST THING TO MOVE.
002DD1  1  A5 80 A4 81  	LDWD	STREND		;GET HIGHEST ADDR TO MOVE.
002DD5  1  85 A9 84 AA  	STWD	HIGHTR
002DD9  1  18           	CLC
002DDA  1  69 07        	ADC	#6+ADDPRC
002DDC  1  90 01        	BCC	NOTEVE
002DDE  1  C8           	INY
002DDF  1  85 A7 84 A8  NOTEVE: STWD	HIGHDS		;PLACE TO STUFF IT.
002DE3  1  20 CF 21     	JSR	BLTU		;MOVE IT ALL.
002DE6  1               				;NOTE [Y,A] HAS [HIGHDS] FOR REASON.
002DE6  1  A5 A7 A4 A8  	LDWD	HIGHDS		;AND SET UP
002DEA  1  C8           	INY
002DEB  1  85 7E 84 7F  	STWD	ARYTAB		;NEW START OF ARRAY TABLE.
002DEF  1  A0 00        	LDY	#0		;GET ADDR OF VARIABLE ENTRY.
002DF1  1  A5 94        	LDA	VARNAM
002DF3  1  91 AE        	STADY	LOWTR
002DF5  1  C8           	INY
002DF6  1  A5 95        	LDA	VARNAM+1
002DF8  1  91 AE        	STADY	LOWTR		;STORE NAME OF VARIABLE.
002DFA  1  A9 00        	LDA	#0
002DFC  1  C8           	INY
002DFD  1  91 AE        	STADY	LOWTR
002DFF  1  C8           	INY
002E00  1  91 AE        	STADY	LOWTR
002E02  1  C8           	INY
002E03  1  91 AE        	STADY	LOWTR
002E05  1  C8           	INY
002E06  1  91 AE        	STADY	LOWTR		;FOURTH ZERO FOR DEF FUNC.
002E08  1               .IF	ADDPRC <> 0
002E08  1  C8           	INY
002E09  1  91 AE        	STADY	LOWTR
002E0B  1               .ENDIF
002E0B  1  A5 AE        FINPTR: LDA	LOWTR
002E0D  1  18           	CLC
002E0E  1  69 02        	ADC	#2
002E10  1  A4 AF        	LDY	LOWTR+1
002E12  1  90 01        	BCC	FINNOW
002E14  1  C8           	INY
002E15  1  85 96 84 97  FINNOW: STWD	VARPNT		;THIS IS IT.
002E19  1  60           	RTS
002E1A  1               ; PAGE
002E1A  1               ; SUBTTL	MULTIPLE DIMENSION CODE.
002E1A  1  A5 0F        FMAPTR: LDA	COUNT
002E1C  1  0A           	ASL	A
002E1D  1  69 05        	ADC	#5		;POINT TO ENTRIES. C CLR'D BY ASL.
002E1F  1  65 AE        	ADC	LOWTR
002E21  1  A4 AF        	LDY	LOWTR+1
002E23  1  90 01        	BCC	JSRGM
002E25  1  C8           	INY
002E26  1  85 A7 84 A8  JSRGM:	STWD	ARYPNT
002E2A  1  60           	RTS
002E2B  1               
002E2B  1  90 80 00 00  N32768: .BYTE	144,128,0,0	;-32768.	;LGB was "EXP" here
002E2F  1               
002E2F  1               ;
002E2F  1               ; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
002E2F  1               ; TURNS IT INTO A POSITIVE INTEGER
002E2F  1               ; LEAVING THE RESULT IN FACMO&LO. NEGATIVE ARGUMENTS
002E2F  1               ; ARE NOT ALLOWED.
002E2F  1               ;
002E2F  1  20 C2 00     INTIDX: JSR	CHRGET
002E32  1  20 BD 2A     	JSR	FRMEVL		;GET A NUMBER
002E35  1  20 AC 2A     POSINT: JSR	CHKNUM
002E38  1  A5 B5        	LDA	FACSGN
002E3A  1  30 0D        	BMI	NONONO		;IF NEGATIVE, BLOW HIM OUT.
002E3C  1  A5 B0        AYINT:	LDA	FACEXP
002E3E  1  C9 90        	CMP	#144		;FAC .GT. 32767?
002E40  1  90 09        	BCC	QINTGO
002E42  1  A9 2B A0 2E  	LDWDI	N32768		;GET ADDR OF -32768.
002E46  1  20 D9 38     	JSR	FCOMP		;SEE IF FAC=[[Y,A]].
002E49  1  D0 7A        NONONO: BNE	FCERR		;NO, FAC IS TOO BIG.
002E4B  1  4C 19 39     QINTGO: JMP	QINT		;GO TO QINT AND SHOVE IT.
002E4E  1               ;
002E4E  1               ; FORMAT OF ARRAYS IN CORE.
002E4E  1               ;
002E4E  1               ; DESCRIPTOR:
002E4E  1               ;	LOWBYTE = FIRST CHARACTER.
002E4E  1               ;	HIGHBYTE = SECOND CHARACTER (200 BIT IS STRING FLAG).
002E4E  1               ; LENGTH OF ARRAY IN CORE IN BYTES (INCLUDES EVERYTHING).
002E4E  1               ; NUMBER OF DIMENSIONS.
002E4E  1               ; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
002E4E  1               ; (2 BYTES EACH) OF THE MAX INDICE+1
002E4E  1               ; THE VALUES
002E4E  1               ;
002E4E  1  A5 10        ISARY:	LDA	DIMFLG
002E50  1               .IF	INTPRC <> 0
002E50  1  05 12        	ORA	INTFLG
002E52  1               .ENDIF
002E52  1  48           	PHA			;SAVE [DIMFLG] FOR RECURSION.
002E53  1  A5 11        	LDA	VALTYP
002E55  1  48           	PHA			;SAVE [VALTYP] FOR RECURSION.
002E56  1  A0 00        	LDY	#0		;SET NUMBER OF DIMENSIONS TO ZERO.
002E58  1  98           INDLOP: TYA			;SAVE NUMBER OF DIMS.
002E59  1  48           	PHA
002E5A  1  A5 95 48 A5  	PSHWD	VARNAM		;SAVE LOOKS.
002E5E  1  94 48        
002E60  1  20 2F 2E     	JSR	INTIDX		;EVALUATE INDICE INTO FACMO&LO.
002E63  1  68 85 94 68  	PULWD	VARNAM		;GET BACK ALL... WE'RE HOME.
002E67  1  85 95        
002E69  1  68           	PLA			;(# OF DIMS).
002E6A  1  A8           	TAY
002E6B  1  BA           	TSX
002E6C  1  BD 02 01     	LDA	258,X
002E6F  1  48           	PHA			;PUSH DIMFLG AND VALTYP FURTHER.
002E70  1  BD 01 01     	LDA	257,X
002E73  1  48           	PHA
002E74  1  A5 B3        	LDA	INDICE		;PUT INDICE ONTO STACK.
002E76  1  9D 02 01     	STA	258,X 		;UNDER DIMFLG AND VALTYP.
002E79  1  A5 B4        	LDA	INDICE+1
002E7B  1  9D 01 01     	STA	257,X
002E7E  1  C8           	INY			;INCREMENT # OF DIMS.
002E7F  1  20 C8 00     	JSR	CHRGOT		;GET TERMINATING CHARACTER.
002E82  1  C9 2C        	CMP	#44		;A COMMA?
002E84  1  F0 D2        	BEQ	INDLOP		;YES.
002E86  1  84 0F        	STY	COUNT		;SAVE COUNT OF DIMS.
002E88  1  20 FD 2B     	JSR	CHKCLS		;MUST BE CLOSED PAREN.
002E8B  1  68           	PLA
002E8C  1  85 11        	STA	VALTYP		;GET VALTYP AND
002E8E  1  68           	PLA
002E8F  1               .IF	INTPRC <> 0
002E8F  1  85 12        	STA	INTFLG
002E91  1  29 7F        	AND	#127
002E93  1               .ENDIF
002E93  1  85 10        	STA	DIMFLG		;DIMFLG OFF STACK.
002E95  1  A6 7E        	LDX	ARYTAB		;PLACE TO START SEARCH.
002E97  1  A5 7F        	LDA	ARYTAB+1
002E99  1  86 AE        LOPFDA: STX	LOWTR
002E9B  1  85 AF        	STA	LOWTR+1
002E9D  1  C5 81        	CMP	STREND+1	;END OF ARRAYS?
002E9F  1  D0 04        	BNE	LOPFDV
002EA1  1  E4 80        	CPX	STREND
002EA3  1  F0 39        	BEQ	NOTFDD		;A FINE THING! NO ARRAY!.
002EA5  1  A0 00        LOPFDV: LDY	#0
002EA7  1  B1 AE        	LDADY	LOWTR
002EA9  1  C8           	INY
002EAA  1  C5 94        	CMP	VARNAM		;COMPARE HIGH ORDERS.
002EAC  1  D0 06        	BNE	NMARY1		;NO WAY IS IT THIS. GET OUT OF HERE.
002EAE  1  A5 95        	LDA	VARNAM+1
002EB0  1  D1 AE        	CMPDY	LOWTR		;LOW ORDERS?
002EB2  1  F0 16        	BEQ	GOTARY		;WELL, HERE IT IS !!
002EB4  1  C8           NMARY1: INY
002EB5  1  B1 AE        	LDADY	LOWTR		;GET LENGTH.
002EB7  1  18           	CLC
002EB8  1  65 AE        	ADC	LOWTR
002EBA  1  AA           	TAX
002EBB  1  C8           	INY
002EBC  1  B1 AE        	LDADY	LOWTR
002EBE  1  65 AF        	ADC	LOWTR+1
002EC0  1  90 D7        	BCC	LOPFDA		;ALWAYS BRANCHES.
002EC2  1  A2 10 2C     BSERR:	LDX	#ERRBS		;GET BAD SUB ERROR NUMBER.
002EC5  1               	SKIP2
002EC5  1  A2 08        FCERR:	LDX	#ERRFC		;TOO BIG. "FUNCTION CALL" ERROR.
002EC7  1  4C 4E 22     ERRGO3: JMP	ERROR
002ECA  1  A2 12        GOTARY: LDX	#ERRDD		;PERHAPS A "RE-DIMENSION" ERROR
002ECC  1  A5 10        	LDA	DIMFLG		;TEST THE DIMFLG
002ECE  1  D0 F7        	BNE	ERRGO3
002ED0  1  20 1A 2E     	JSR	FMAPTR
002ED3  1  A5 0F        	LDA	COUNT		;GET NUMBER OF DIMS INPUT.
002ED5  1  A0 04        	LDY	#4
002ED7  1  D1 AE        	CMPDY	LOWTR		;# OF DIMS THE SAME?
002ED9  1  D0 E7        	BNE	BSERR		;SAME SO GO GET DEFINITION.
002EDB  1  4C 68 2F     	JMP	GETDEF
002EDE  1               
002EDE  1               ;
002EDE  1               ; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE.
002EDE  1               ;
002EDE  1               ; BUILDING AN ENTRY.
002EDE  1               ;
002EDE  1               ;	PUT DOWN THE DESCRIPTOR.
002EDE  1               ;	SETUP NUMBER OF DIMENSIONS.
002EDE  1               ;	MAKE SURE THERE IS ROOM FOR THE NEW ENTRY.
002EDE  1               ;	REMEMBER "VARPNT".
002EDE  1               ;	TALLY=4.
002EDE  1               ;	SKIP 2 LOCS FOR LATER FILL IN OF SIZE.
002EDE  1               ; LOOP: GET AN INDICE
002EDE  1               ;	PUT DOWN NUMBER+1 AND INCREMENT VARPTR.
002EDE  1               ;	TALLY=TALLY*NUMBER+1.
002EDE  1               ;	DECREMENT NUMBER-DIMS.
002EDE  1               ;	BNE LOOP
002EDE  1               ;	CALL "REASON" WITH [Y,A] REFLECTING LAST LOC OF VARIABLE.
002EDE  1               ;	UPDATE STREND.
002EDE  1               ;	ZERO ALL.
002EDE  1               ;	MAKE TALLY INCLUDE MAXDIMS AND DESCRIPTOR.
002EDE  1               ;	PUT DOWN TALLY.
002EDE  1               ;	IF CALLED BY DIMENSION, RETURN.
002EDE  1               ;	OTHERWISE INDEX INTO THE VARIABLE AS IF IT
002EDE  1               ;	 WERE FOUND ON THE INITIAL SEARCH.
002EDE  1               ;
002EDE  1  20 1A 2E     NOTFDD: JSR	FMAPTR		;FORM ARYPNT.
002EE1  1  20 1F 22     	JSR	REASON
002EE4  1  A9 00        	LDA	#0
002EE6  1  A8           	TAY
002EE7  1  85 C1        	STA	CURTOL+1
002EE9  1               .IF	ADDPRC = 0
002EE9  1               	LDX	#4
002EE9  1               .ENDIF
002EE9  1               .IF	ADDPRC <> 0
002EE9  1  A2 05        	LDX	#5
002EEB  1               .ENDIF
002EEB  1  A5 94        	LDA	VARNAM		;THIS CODE ONLY WORKS FOR INTPRC=1
002EED  1  91 AE        	STADY	LOWTR		;IF ADDPRC=1.
002EEF  1               .IF	ADDPRC <> 0
002EEF  1  10 01        	BPL	NOTFLT
002EF1  1  CA           	DEX
002EF2  1               .ENDIF
002EF2  1  C8           NOTFLT: INY
002EF3  1  A5 95        	LDA	VARNAM+1
002EF5  1  91 AE        	STADY	LOWTR
002EF7  1  10 02        	BPL	STOMLT
002EF9  1  CA           	DEX
002EFA  1               .IF	ADDPRC <> 0
002EFA  1  CA           	DEX
002EFB  1               .ENDIF
002EFB  1  86 C0        STOMLT: STX	CURTOL
002EFD  1  A5 0F        	LDA	COUNT
002EFF  1  C8 C8 C8     	REPEAT	3,{INY}
002F02  1  91 AE        	STADY	LOWTR		;SAVE NUMBER OF DIMENSIONS.
002F04  1  A2 0B        LOPPTA: LDX	#11		;DEFAULT SIZE.
002F06  1  A9 00        	LDA	#0
002F08  1  24 10        	BIT	DIMFLG
002F0A  1  50 08        	BVC	NOTDIM		;NOT IN A DIM STATEMENT.
002F0C  1  68           	PLA			;GET LOW ORDER OF INDICE.
002F0D  1  18           	CLC
002F0E  1  69 01        	ADC	#1
002F10  1  AA           	TAX
002F11  1  68           	PLA			;GET HIGH PART OF INDICE.
002F12  1  69 00        	ADC	#0
002F14  1  C8           NOTDIM: INY
002F15  1  91 AE        	STADY	LOWTR		;STORE HIGH PART OF INDICE.
002F17  1  C8           	INY
002F18  1  8A           	TXA
002F19  1  91 AE        	STADY	LOWTR		;STORE LOW ORDER OF INDICE.
002F1B  1  20 CA 2F     	JSR	UMULT		;[X,A]=[CURTOL]*[LOWTR,Y]
002F1E  1  86 C0        	STX	CURTOL		;SAVE NEW TALLY.
002F20  1  85 C1        	STA	CURTOL+1
002F22  1  A4 71        	LDY	INDEX
002F24  1  C6 0F        	DEC	COUNT		;ANY MORE INDICES LEFT?
002F26  1  D0 DC        	BNE	LOPPTA		;YES.
002F28  1  65 A8        	ADC	ARYPNT+1
002F2A  1  B0 5D        	BCS	OMERR1		;OVERFLOW.
002F2C  1  85 A8        	STA	ARYPNT+1	;COMPUTE WHERE TO ZERO.
002F2E  1  A8           	TAY
002F2F  1  8A           	TXA
002F30  1  65 A7        	ADC	ARYPNT
002F32  1  90 03        	BCC	GREASE
002F34  1  C8           	INY
002F35  1  F0 52        	BEQ	OMERR1
002F37  1  20 1F 22     GREASE: JSR	REASON		;GET ROOM.
002F3A  1  85 80 84 81  	STWD	STREND		;NEW END OF STORAGE.
002F3E  1  A9 00        	LDA	#0		;STORING [ACCA] IS FASTER THAN CLEAR.
002F40  1  E6 C1        	INC	CURTOL+1
002F42  1  A4 C0        	LDY	CURTOL
002F44  1  F0 05        	BEQ	DECCUR
002F46  1  88           ZERITA: DEY
002F47  1  91 A7        	STADY	ARYPNT
002F49  1  D0 FB        	BNE	ZERITA		;NO. CONTINUE.
002F4B  1  C6 A8        DECCUR: DEC	ARYPNT+1
002F4D  1  C6 C1        	DEC	CURTOL+1
002F4F  1  D0 F5        	BNE	ZERITA		;DO ANOTHER BLOCK.
002F51  1  E6 A8        	INC	ARYPNT+1	;BUMP BACK UP. WILL USE LATER.
002F53  1  38           	SEC
002F54  1  A5 80        	LDA	STREND		;RESTORE [ACCA].
002F56  1  E5 AE        	SBC	LOWTR		;DETERMINE LENGTH.
002F58  1  A0 02        	LDY	#2
002F5A  1  91 AE        	STADY	LOWTR		;LOW.
002F5C  1  A5 81        	LDA	STREND+1
002F5E  1  C8           	INY
002F5F  1  E5 AF        	SBC	LOWTR+1
002F61  1  91 AE        	STADY	LOWTR		;HIGH.
002F63  1  A5 10        	LDA	DIMFLG
002F65  1  D0 62        	BNE	DIMRTS		;BYE.
002F67  1  C8           	INY
002F68  1               ;
002F68  1               ; AT THIS POINT [LOWTR,Y] POINTS BEYOND THE SIZE TO THE NUMBER OF
002F68  1               ; DIMENSIONS. STRATEGY:
002F68  1               ;	NUMDIM=NUMBER OF DIMENSIONS.
002F68  1               ;	CURTOL=0.
002F68  1               ; INLPNM:GET A NEW INDICE.
002F68  1               ;	MAKE SURE INDICE IS NOT TOO BIG.
002F68  1               ;	MULTIPLY CURTOL BY CURMAX.
002F68  1               ;	ADD INDICE TO CURTOL.
002F68  1               ;	NUMDIM=NUMDIM-1.
002F68  1               ;	BNE	INLPNM.
002F68  1               ;	USE [CURTOL]*4 AS OFFSET.
002F68  1               ;
002F68  1  B1 AE        GETDEF: LDADY	LOWTR
002F6A  1  85 0F        	STA	COUNT		;SAVE A COUNTER.
002F6C  1  A9 00        	LDA	#0		;ZERO [CURTOL].
002F6E  1  85 C0        	STA	CURTOL
002F70  1  85 C1        INLPNM: STA	CURTOL+1
002F72  1  C8           	INY
002F73  1  68           	PLA			;GET LOW INDICE.
002F74  1  AA           	TAX
002F75  1  85 B3        	STA	INDICE
002F77  1  68           	PLA			;AND THE HIGH PART
002F78  1  85 B4        	STA	INDICE+1
002F7A  1  D1 AE        	CMPDY	LOWTR		;COMPARE WITH MAX INDICE.
002F7C  1  90 0E        	BCC	INLPN2
002F7E  1  D0 06        	BNE	BSERR7		;IF GREATER, "BAD SUBSCRIPT" ERROR.
002F80  1  C8           	INY
002F81  1  8A           	TXA
002F82  1  D1 AE        	CMPDY	LOWTR
002F84  1  90 07        	BCC	INLPN1
002F86  1  4C C2 2E     BSERR7: JMP	BSERR
002F89  1  4C 4C 22     OMERR1: JMP	OMERR
002F8C  1  C8           INLPN2: INY
002F8D  1  A5 C1        INLPN1: LDA	CURTOL+1	;DON'T MULTIPLY IF CURTOL=0.
002F8F  1  05 C0        	ORA	CURTOL
002F91  1  18           	CLC			;PREPARE TO GET INDICE BACK.
002F92  1  F0 0A        	BEQ	ADDIND		;GET HIGH PART OF INDICE BACK.
002F94  1  20 CA 2F     	JSR	UMULT		;MULTIPLY [CURTOL] BY [LOWTR,Y,Y+1].
002F97  1  8A           	TXA
002F98  1  65 B3        	ADC	INDICE		;ADD IN [INDICE].
002F9A  1  AA           	TAX
002F9B  1  98           	TYA
002F9C  1  A4 71        	LDY	INDEX1
002F9E  1  65 B4        ADDIND: ADC	INDICE+1
002FA0  1  86 C0        	STX	CURTOL
002FA2  1  C6 0F        	DEC	COUNT		;ANY MORE?
002FA4  1  D0 CA        	BNE	INLPNM		;YES.
002FA6  1  85 C1        	STA	CURTOL+1	;FIX ARRAY BUG ****
002FA8  1               .IF	ADDPRC = 0
002FA8  1               	LDX	#4
002FA8  1               .ENDIF
002FA8  1               .IF	ADDPRC <> 0
002FA8  1  A2 05        	LDX	#5		;THIS CODE ONLY WORKS FOR INTPRC=1
002FAA  1  A5 94        	LDA	VARNAM		;IF ADDPRC=1.
002FAC  1  10 01        	BPL	NOTFL1
002FAE  1  CA           	DEX
002FAF  1               .ENDIF
002FAF  1  A5 95        NOTFL1: LDA	VARNAM+1
002FB1  1  10 02        	BPL	STOML1
002FB3  1  CA           	DEX
002FB4  1               .IF	ADDPRC <> 0
002FB4  1  CA           	DEX
002FB5  1               .ENDIF
002FB5  1  86 77        STOML1: STX	ADDEND
002FB7  1  A9 00        	LDA	#0
002FB9  1  20 D3 2F     	JSR	UMULTD		;ON RTS, A&Y=HI . X=LO.
002FBC  1  8A           	TXA
002FBD  1  65 A7        	ADC	ARYPNT
002FBF  1  85 96        	STA	VARPNT
002FC1  1  98           	TYA
002FC2  1  65 A8        	ADC	ARYPNT+1
002FC4  1  85 97        	STA	VARPNT+1
002FC6  1  A8           	TAY
002FC7  1  A5 96        	LDA	VARPNT
002FC9  1  60           DIMRTS: RTS			;RETURN TO CALLER.
002FCA  1               ; SUBTTL	INTEGER ARITHMETIC ROUTINES.
002FCA  1               	;TWO BYTE UNSIGNED INTEGER MULTIPLY.
002FCA  1               	;THIS IS FOR MULTIPLY DIMENSIONED ARRAYS.
002FCA  1               	; [X,Y]=[X,A]=[CURTOL]*[LOWTR,Y,Y+1].
002FCA  1  84 71        UMULT:	STY	INDEX
002FCC  1  B1 AE        	LDADY	LOWTR
002FCE  1  85 77        	STA	ADDEND		;LOW, THEN HIGH.
002FD0  1  88           	DEY
002FD1  1  B1 AE        	LDADY	LOWTR		;PUT [LOWTR,Y,Y+1] IN FASTER MEMORY.
002FD3  1  85 78        UMULTD: STA	ADDEND+1
002FD5  1  A9 10        	LDA	#16
002FD7  1  85 AC        	STA	DECCNT
002FD9  1  A2 00        	LDX	#0		;CLR THE ACCS.
002FDB  1  A0 00        	LDY	#0		;RESULT INITIALLY ZERO.
002FDD  1  8A           UMULTC: TXA
002FDE  1  0A           	ASL	A 		;MULTIPLY BY TWO.
002FDF  1  AA           	TAX
002FE0  1  98           	TYA
002FE1  1  2A           	ROL	A
002FE2  1  A8           	TAY
002FE3  1  B0 A4        	BCS	OMERR1		;TWO MUCH !
002FE5  1  06 C0        	ASL	CURTOL
002FE7  1  26 C1        	ROL	CURTOL+1
002FE9  1  90 0B        	BCC	UMLCNT		;NOTHING IN THIS POSITION TO MULTIPLY.
002FEB  1  18           	CLC
002FEC  1  8A           	TXA
002FED  1  65 77        	ADC	ADDEND
002FEF  1  AA           	TAX
002FF0  1  98           	TYA
002FF1  1  65 78        	ADC	ADDEND+1
002FF3  1  A8           	TAY
002FF4  1  B0 93        	BCS	OMERR1		;MAN, JUST TOO MUCH !
002FF6  1  C6 AC        UMLCNT: DEC	DECCNT		;DONE?
002FF8  1  D0 E3        	BNE	UMULTC		;KEEP IT UP.
002FFA  1  60           UMLRTS: RTS			;YES, ALL DONE.
002FFB  1               ; PAGE
002FFB  1               ; SUBTTL	FRE FUNCTION AND INTEGER TO FLOATING ROUTINES.
002FFB  1  A5 11        FRE:	LDA	VALTYP
002FFD  1  F0 03        	BEQ	NOFREF
002FFF  1  20 23 33     	JSR	FREFAC
003002  1  20 9E 31     NOFREF: JSR	GARBA2
003005  1  38           	SEC
003006  1  A5 82        	LDA	FRETOP		;WE WANT
003008  1  E5 80        	SBC	STREND		;[FRETOP]-[STREND].
00300A  1  A8           	TAY
00300B  1  A5 83        	LDA	FRETOP+1
00300D  1  E5 81        	SBC	STREND+1
00300F  1               
00300F  1  A2 00        GIVAYF: LDX	#0
003011  1  86 11        	STX	VALTYP
003013  1  85 B1 84 B2  	STWD	FACHO
003017  1  A2 90        	LDX	#144		;SET EXPONENT TO 2^16.
003019  1  4C C2 38     	JMP	FLOATS		;TURN IT TO A FLOATING PNT #.
00301C  1               
00301C  1  A4 18        POS:	LDY	TRMPOS		;GET POSITION.
00301E  1  A9 00 F0 ED  SNGFLT: LDA	#0
003022  1               	BEQA	GIVAYF		;FLOAT IT.
003022  1               ; PAGE
003022  1               ; SUBTTL	SIMPLE-USER-DEFINED-FUNCTION CODE.
003022  1               ;
003022  1               ; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
003022  1               ; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
003022  1               ;	DEF FNA(X)=X^2+X-2
003022  1               ; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS.
003022  1               ;
003022  1               ; IDEA: CREATE A SIMPLE VARIABLE ENTRY
003022  1               ; WHOSE FIRST CHARACTER HAS THE 200 BIT SET.
003022  1               ; THE VALUE WILL BE:
003022  1               ;
003022  1               ;	A TEXT PNTR TO THE FORMULA.
003022  1               ;	A PNTR TO THE ARGUMENT VARIABLE.
003022  1               ;
003022  1               ; FUNCTION NAMES CAN BE LIKE "FNA4".
003022  1               ;
003022  1               ;
003022  1               ; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE.
003022  1               ; AND COMPLAIN IF SO.
003022  1               ;
003022  1  A6 89        ERRDIR: LDX	CURLIN+1	;DIR MODE HAS [CURLIN]=0,255
003024  1  E8           	INX			;SO NOW, IS RESULT ZERO?
003025  1  D0 A2        	BNE	DIMRTS		;YES.
003027  1  A2 16 2C     	LDX	#ERRID		;INPUT DIRECT ERROR CODE.
00302A  1               	SKIP2
00302A  1  A2 20        ERRGUF: LDX	#ERRUF		;USER DEFINED FUNCTION NEVER DEFINED
00302C  1  4C 4E 22     ERRGO1: JMP	ERROR
00302F  1               
00302F  1  20 5D 30     DEF:	JSR	GETFNM		;GET A PNTR TO THE FUNCTION.
003032  1  20 22 30     	JSR	ERRDIR
003035  1  20 00 2C     	JSR	CHKOPN		;MUST HAVE "(".
003038  1  A9 80        	LDA	#128
00303A  1  85 14        	STA	SUBFLG		;PROHIBIT SUBSCRIPTED VARIABLES.
00303C  1  20 22 2D     	JSR	PTRGET		;GET PNTR TO ARGUMENT.
00303F  1  20 AC 2A     	JSR	CHKNUM		;IS IT A NUMBER?
003042  1  20 FD 2B     	JSR	CHKCLS		;MUST HAVE ")"
003045  1  A9 AB 20 05  	SYNCHK	EQULTK		;MUST HAVE "=".
003049  1  2C           
00304A  1               .IF	ADDPRC <> 0
00304A  1  48           	PHA			;PUT CRAZY BYTE ON.
00304B  1               .ENDIF
00304B  1  A5 97 48 A5  	PSHWD	VARPNT
00304F  1  96 48        
003051  1  A5 CA 48 A5  	PSHWD	TXTPTR
003055  1  C9 48        
003057  1  20 CA 26     	JSR	DATA
00305A  1  4C CB 30     	JMP	DEFFIN
00305D  1               ;
00305D  1               ; SUBROUTINE TO GET A PNTR TO A FUNCTION NAME.
00305D  1               ;
00305D  1  A9 9E 20 05  GETFNM: SYNCHK	FNTK		;MUST START WITH FN.
003061  1  2C           
003062  1  09 80        	ORA	#128		;PUT FUNCTION BIT ON.
003064  1  85 14        	STA	SUBFLG
003066  1  20 29 2D     	JSR	PTRGT2		;GET POINTER TO FUNCTION OR CREATE ANEW.
003069  1  85 9D 84 9E  	STWD	DEFPNT
00306D  1  4C AC 2A     	JMP	CHKNUM		;MAKE SURE IT'S NOT A STRING AND RETURN.
003070  1               
003070  1  20 5D 30     FNDOER: JSR	GETFNM		;GET THE FUNCTION'S NAME.
003073  1  A5 9E 48 A5  	PSHWD	DEFPNT
003077  1  9D 48        
003079  1  20 F7 2B     	JSR	PARCHK		;EVALUATE PARAMETER.
00307C  1  20 AC 2A     	JSR	CHKNUM
00307F  1  68 85 9D 68  	PULWD	DEFPNT
003083  1  85 9E        
003085  1  A0 02        	LDY	#2
003087  1  B1 9D        	LDADY	DEFPNT		;GET POINTER TO VARIABLE.
003089  1  85 96        	STA	VARPNT		;SAVE VARIABLE POINTER.
00308B  1  AA           	TAX
00308C  1  C8           	INY
00308D  1  B1 9D        	LDADY	DEFPNT
00308F  1  F0 99        	BEQ	ERRGUF
003091  1  85 97        	STA	VARPNT+1
003093  1               .IF	ADDPRC <> 0
003093  1  C8           	INY			;SINCE DEF USES ONLY 4.
003094  1               .ENDIF
003094  1  B1 96        DEFSTF: LDADY	VARPNT
003096  1  48           	PHA			;PUSH IT ALL ON STACK.
003097  1  88           	DEY			;SINCE WE ARE RECURSING MAYBE.
003098  1  10 FA        	BPL	DEFSTF
00309A  1  A4 97        	LDY	VARPNT+1
00309C  1  20 52 38     	JSR	MOVMF		;PUT CURRENT FAC INTO OUR ARG VARIABLE.
00309F  1  A5 CA 48 A5  	PSHWD	TXTPTR		;SAVE TEXT POINTER.
0030A3  1  C9 48        
0030A5  1  B1 9D        	LDADY	DEFPNT		;PNTR TO FUNCTION.
0030A7  1  85 C9        	STA	TXTPTR
0030A9  1  C8           	INY
0030AA  1  B1 9D        	LDADY	DEFPNT
0030AC  1  85 CA        	STA	TXTPTR+1
0030AE  1  A5 97 48 A5  	PSHWD	VARPNT		;SAVE VARIABLE POINTER.
0030B2  1  96 48        
0030B4  1  20 A9 2A     	JSR	FRMNUM		;EVALUATE FORMULA AND CHECK NUMERIC.
0030B7  1  68 85 9D 68  	PULWD	DEFPNT
0030BB  1  85 9E        
0030BD  1  20 C8 00     	JSR	CHRGOT
0030C0  1  F0 03 4C 0E  	JNE	SNERR		;IT DIDN'T TERMINATE. HUH?
0030C4  1  2C           
0030C5  1  68 85 C9 68  	PULWD	TXTPTR		;RESTORE TEXT PNTR.
0030C9  1  85 CA        
0030CB  1  A0 00        DEFFIN: LDY	#0
0030CD  1  68           	PLA			;GET OLD ARG VALUE OFF STACK
0030CE  1  91 9D        	STADY	DEFPNT		;AND PUT IT BACK IN VARIABLE.
0030D0  1  68           	PLA
0030D1  1  C8           	INY
0030D2  1  91 9D        	STADY	DEFPNT
0030D4  1  68           	PLA
0030D5  1  C8           	INY
0030D6  1  91 9D        	STADY	DEFPNT
0030D8  1  68           	PLA
0030D9  1  C8           	INY
0030DA  1  91 9D        	STADY	DEFPNT
0030DC  1               .IF	ADDPRC <> 0
0030DC  1  68           	PLA
0030DD  1  C8           	INY
0030DE  1  91 9D        	STADY	DEFPNT
0030E0  1               .ENDIF
0030E0  1  60           DEFRTS: RTS
0030E1  1               ; 	PAGE
0030E1  1               ; SUBTTL	STRING FUNCTIONS.
0030E1  1               ;
0030E1  1               ; THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING
0030E1  1               ; WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
0030E1  1               ; WOULD HAVE GIVEN.
0030E1  1               ;
0030E1  1  20 AC 2A     STR:	JSR	CHKNUM		;ARG HAS TO BE NUMERIC.
0030E4  1  A0 00        	LDY	#0
0030E6  1  20 5D 3A     	JSR	FOUTC		;DO ITS OUTPUT.
0030E9  1  68           	PLA
0030EA  1  68           	PLA
0030EB  1  A9 FF A0 00  TIMSTR: LDWDI	LOFBUF
0030EF  1  F0 12        
0030F1  1               	BEQA	STRLIT		;SCAN IT AND TURN IT INTO A STRING.
0030F1  1               ;
0030F1  1               ; "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND
0030F1  1               ; CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
0030F1  1               ;
0030F1  1  A6 B3 A4 B4  STRINI: LDXY	FACMO		;GET FACMO TO STORE IN DSCPNT.
0030F5  1  86 9F 84 A0  	STXY	DSCPNT		;RETAIN THE DESCRIPTOR POINTER.
0030F9  1  20 6C 31     STRSPA: JSR	GETSPA		;GET STRING SPACE.
0030FC  1  86 B1 84 B2  	STXY	DSCTMP+1	;SAVE LOCATION.
003100  1  85 B0        	STA	DSCTMP		;SAVE LENGTH.
003102  1  60           	RTS			;ALL DONE.
003103  1               ;
003103  1               ; "STRLT2" TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
003103  1               ; IS POINTED TO BY [Y,A] AND BUILDS A DESCRIPTOR FOR IT.
003103  1               ; THE DESCRIPTOR IS INITIALLY BUILT IN "DSCTMP", BUT "PUTNEW"
003103  1               ; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
003103  1               ; AT THE TEMPORARY IN FACMO&LO. THE CHARACTERS OTHER THAN
003103  1               ; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN "CHARAC"
003103  1               ; AND "ENDCHR". IF THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
003103  1               ; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE JSR. ON RETURN
003103  1               ; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
003103  1               ; BY [STRNG2].
003103  1               ;
003103  1  A2 22        STRLIT: LDX	#34		;ASSUME STRING ENDS ON QUOTE.
003105  1  86 0D        	STX	CHARAC
003107  1  86 0E        	STX	ENDCHR
003109  1  85 BE 84 BF  STRLT2: STWD	STRNG1		;SAVE POINTER TO STRING.
00310D  1  85 B1 84 B2  	STWD	DSCTMP+1	;IN CASE NO STRCPY.
003111  1  A0 FF        	LDY	#255		;INITIALIZE CHARACTER COUNT.
003113  1  C8           STRGET: INY
003114  1  B1 BE        	LDADY	STRNG1		;GET CHARACTER.
003116  1  F0 0C        	BEQ	STRFI1		;IF ZERO.
003118  1  C5 0D        	CMP	CHARAC		;THIS TERMINATOR?
00311A  1  F0 04        	BEQ	STRFIN		;YES.
00311C  1  C5 0E        	CMP	ENDCHR
00311E  1  D0 F3        	BNE	STRGET		;LOOK FURTHER.
003120  1  C9 22        STRFIN: CMP	#34		;QUOTE?
003122  1  F0 01        	BEQ	STRFI2
003124  1  18           STRFI1: CLC			;NO, BACK UP.
003125  1  84 B0        STRFI2: STY	DSCTMP		;RETAIN COUNT.
003127  1  98           	TYA
003128  1  65 BE        	ADC	STRNG1		;WISHING TO SET [TXTPTR].
00312A  1  85 C0        	STA	STRNG2
00312C  1  A6 BF        	LDX	STRNG1+1
00312E  1  90 01        	BCC	STRST2
003130  1  E8           	INX
003131  1  86 C1        STRST2: STX	STRNG2+1
003133  1  A5 BF        	LDA	STRNG1+1	;IF PAGE 0, COPY SINCE IT IS EITHER
003135  1               				;A STRING CONSTANT IN BUF OR A STR$
003135  1               				;RESULT IN LOFBUF
003135  1               .IF	BUFPAG <> 0
003135  1               	BEQ	STRCP
003135  1               	CMP	#BUFPAG
003135  1               .ENDIF
003135  1  D0 0B        	BNE	PUTNEW
003137  1  98           STRCP:	TYA
003138  1  20 F1 30     	JSR	STRINI
00313B  1  A6 BE A4 BF  	LDXY	STRNG1
00313F  1  20 05 33     	JSR	MOVSTR		;MOVE STRING.
003142  1               ;
003142  1               ; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP.
003142  1               ; SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT.
003142  1               ; PUT A POINTER TO THE DESCRIPTOR IN FACMO&LO AND FLAG THE
003142  1               ; RESULT AS TYPE STRING.
003142  1               ;
003142  1  A6 65        PUTNEW: LDX	TEMPPT		;POINTER TO FIRST FREE TEMP.
003144  1  E0 71        	CPX	#TEMPST+STRSIZ*NUMTMP
003146  1  D0 05        	BNE	PUTNW1
003148  1  A2 1C        	LDX	#ERRST		;STRING TEMPORARY ERROR.
00314A  1  4C 4E 22     ERRGO2: JMP	ERROR		;GO TELL HIM.
00314D  1  A5 B0        PUTNW1: LDA	DSCTMP
00314F  1  95 00        	STA	0,X
003151  1  A5 B1        	LDA	DSCTMP+1
003153  1  95 01        	STA	1,X
003155  1  A5 B2        	LDA	DSCTMP+2
003157  1  95 02        	STA	2,X
003159  1  A0 00        	LDY	#0
00315B  1  86 B3 84 B4  	STXY	FACMO
00315F  1  84 BF        	STY	FACOV
003161  1  88           	DEY
003162  1  84 11        	STY	VALTYP		;TYPE IS "STRING".
003164  1  86 66        	STX	LASTPT		;SET POINTER TO LAST-USED TEMP.
003166  1  E8           	INX
003167  1  E8           	INX
003168  1  E8           	INX			;POINT FURTHER.
003169  1  86 65        	STX	TEMPPT		;SAVE POINTER TO NEXT TEMP IF ANY.
00316B  1  60           	RTS			;ALL DONE.
00316C  1               
00316C  1               ;
00316C  1               ; GETSPA - GET SPACE FOR CHARACTER STRING.
00316C  1               ; MAY FORCE GARBAGE COLLECTION.
00316C  1               ;
00316C  1               ; # OF CHARACTERS (BYTES) IN ACCA.
00316C  1               ; RETURNS WITH POINTER IN [Y,X]. OTHERWISE (IF CAN'T GET
00316C  1               ; SPACE) BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
00316C  1               ; ALSO PRESERVES [ACCA] AND SETS [FRESPC]=[Y,X]=PNTR AT SPACE.
00316C  1               ;
00316C  1  46 13        GETSPA: LSR	GARBFL		;SIGNAL NO GARBAGE COLLECTION YET.
00316E  1  48           TRYAG2: PHA			;SAVE FOR LATER.
00316F  1  49 FF        	EOR	#255
003171  1  38           	SEC			;ADD ONE TO COMPLETE NEGATION.
003172  1  65 82        	ADC	FRETOP
003174  1  A4 83        	LDY	FRETOP+1
003176  1  B0 01        	BCS	TRYAG3
003178  1  88           	DEY
003179  1  C4 81        TRYAG3: CPY	STREND+1	;COMPARE HIGH ORDERS.
00317B  1  90 11        	BCC	GARBAG		;MAKE ROOM FOR MORE.
00317D  1  D0 04        	BNE	STRFRE		;SAVE NEW FRETOP.
00317F  1  C5 80        	CMP	STREND		;COMPARE LOW ORDERS.
003181  1  90 0B        	BCC	GARBAG		;CLEAN UP.
003183  1  85 82 84 83  STRFRE: STWD	FRETOP		;SAVE NEW [FRETOP].
003187  1  85 84 84 85  	STWD	FRESPC		;PUT IT THERE OLD MAN.
00318B  1  AA           	TAX			;PRESERVE A IN X.
00318C  1  68           	PLA			;GET COUNT BACK IN ACCA.
00318D  1  60           	RTS			;ALL DONE.
00318E  1  A2 0C        GARBAG: LDX	#ERROM		;"OUT OF STRING SPACE"
003190  1  A5 13        	LDA	GARBFL
003192  1  30 B6        	BMI	ERRGO2
003194  1  20 9E 31     	JSR	GARBA2
003197  1  A9 80        	LDA	#128
003199  1  85 13        	STA	GARBFL
00319B  1  68           	PLA			;GET BACK STRING LENGTH.
00319C  1  D0 D0        	BNE	TRYAG2		;ALWAYS BRANCHES.
00319E  1               GARBA2:				;START FROM TOP DOWN.
00319E  1               .IF	(REALIO|DISKO) = 0
00319E  1  A9 07        	LDA	#7		;TYPE "BELL".
0031A0  1  20 BC 28     	JSR	OUTDO
0031A3  1               .ENDIF
0031A3  1  A6 86        	LDX	MEMSIZ
0031A5  1  A5 87        	LDA	MEMSIZ+1
0031A7  1  86 82        FNDVAR: STX	FRETOP		;LIKE SO.
0031A9  1  85 83        	STA	FRETOP+1
0031AB  1  A0 00        	LDY	#0
0031AD  1  84 9E        	STY	GRBPNT+1
0031AF  1  84 9D        	STY	GRBPNT		;BOTH BYTES SET TO ZERO (FIX BUG)
0031B1  1  A5 80 A6 81  	LDWX	STREND
0031B5  1  85 AE 86 AF  	STWX	GRBTOP
0031B9  1  A9 68 A2 00  	LDWXI	TEMPST
0031BD  1  85 71 86 72  	STWX	INDEX1
0031C1  1  C5 65        TVAR:	CMP	TEMPPT		;DONE WITH TEMPS?
0031C3  1  F0 05        	BEQ	SVARS		;YEP.
0031C5  1  20 44 32     	JSR	DVAR
0031C8  1  F0 F7        	BEQ	TVAR		;LOOP.
0031CA  1  A9 07        SVARS:	LDA	#6+ADDPRC
0031CC  1  85 A2        	STA	FOUR6
0031CE  1  A5 7C A6 7D  	LDWX	VARTAB		;GET START OF SIMPLE VARIABLES.
0031D2  1  85 71 86 72  	STWX	INDEX1
0031D6  1  E4 7F        SVAR:	CPX	ARYTAB+1	;DONE WITH SIMPLE VARIABLES?
0031D8  1  D0 04        	BNE	SVARGO		;NO.
0031DA  1  C5 7E        	CMP	ARYTAB
0031DC  1  F0 05        	BEQ	ARYVAR		;YEP.
0031DE  1  20 3A 32     SVARGO: JSR	DVARS		;DO IT , AGAIN.
0031E1  1  F0 F3        	BEQ	SVAR		;LOOP.
0031E3  1  85 A7 86 A8  ARYVAR: STWX	ARYPNT		;SAVE FOR ADDITION.
0031E7  1  A9 03        	LDA	#STRSIZ
0031E9  1  85 A2        	STA	FOUR6
0031EB  1  A5 A7 A6 A8  ARYVA2: LDWX	ARYPNT		;GET THE POINTER TO VARIABLE.
0031EF  1  E4 81        ARYVA3: CPX	STREND+1	;DONE WITH ARRAYS?
0031F1  1  D0 07        	BNE	ARYVGO		;NO.
0031F3  1  C5 80        	CMP	STREND
0031F5  1  D0 03 4C 83  	JEQ	GRBPAS		;YES, GO FINISH UP.
0031F9  1  32           
0031FA  1  85 71 86 72  ARYVGO: STWX	INDEX1
0031FE  1  A0 00        	LDY	#1-ADDPRC
003200  1               .IF	ADDPRC <> 0
003200  1  B1 71        	LDADY	INDEX1
003202  1  AA           	TAX
003203  1  C8           	INY
003204  1               .ENDIF
003204  1  B1 71        	LDADY	INDEX1
003206  1  08           	PHP
003207  1  C8           	INY
003208  1  B1 71        	LDADY	INDEX1
00320A  1  65 A7        	ADC	ARYPNT
00320C  1  85 A7        	STA	ARYPNT		;FORM POINTER TO NEXT ARRAY VAR.
00320E  1  C8           	INY
00320F  1  B1 71        	LDADY	INDEX1
003211  1  65 A8        	ADC	ARYPNT+1
003213  1  85 A8        	STA	ARYPNT+1
003215  1  28           	PLP
003216  1  10 D3        	BPL	ARYVA2
003218  1               .IF	ADDPRC <> 0
003218  1  8A           	TXA
003219  1  30 D0        	BMI	ARYVA2
00321B  1               .ENDIF
00321B  1  C8           	INY
00321C  1  B1 71        	LDADY	INDEX1
00321E  1  A0 00        	LDY	#0		;RESET INDEX Y.
003220  1  0A           	ASL	A
003221  1  69 05        	ADC	#5		;CARRY IS OFF AND OFF AFTER ADD.
003223  1  65 71        	ADC	INDEX1
003225  1  85 71        	STA	INDEX1
003227  1  90 02        	BCC	ARYGET
003229  1  E6 72        	INC	INDEX1+1
00322B  1  A6 72        ARYGET: LDX	INDEX1+1
00322D  1  E4 A8        ARYSTR: CPX	ARYPNT+1	;END OF THE ARRAY?
00322F  1  D0 04        	BNE	GOGO
003231  1  C5 A7        	CMP	ARYPNT
003233  1  F0 BA        	BEQ	ARYVA3		;YES.
003235  1  20 44 32     GOGO:	JSR	DVAR
003238  1  F0 F3        	BEQ	ARYSTR		;CYCLE.
00323A  1               DVARS:
00323A  1               .IF	INTPRC <> 0
00323A  1  B1 71        	LDADY	INDEX1
00323C  1  30 35        	BMI	DVARTS
00323E  1               .ENDIF
00323E  1  C8           	INY
00323F  1  B1 71        	LDADY	INDEX1
003241  1  10 30        	BPL	DVARTS
003243  1  C8           	INY
003244  1  B1 71        DVAR:	LDADY	INDEX1		;IS LENGTH=0?
003246  1  F0 2B        	BEQ	DVARTS		;YES, RETURN.
003248  1  C8           	INY
003249  1  B1 71        	LDADY	INDEX1		;GET LOW(ADR).
00324B  1  AA           	TAX
00324C  1  C8           	INY
00324D  1  B1 71        	LDADY	INDEX1
00324F  1  C5 83        	CMP	FRETOP+1	;COMPARE HIGHS.
003251  1  90 06        	BCC	DVAR2		;IF THIS STRING'S PNTR .GE. [FRETOP]
003253  1  D0 1E        	BNE	DVARTS		;NO NEED TO MESS WITH IT FURTHER.
003255  1  E4 82        	CPX	FRETOP		;COMPARE LOWS.
003257  1  B0 1A        	BCS	DVARTS
003259  1  C5 AF        DVAR2:	CMP	GRBTOP+1
00325B  1  90 16        	BCC	DVARTS		;IF THIS STRING IS BELOW PREVIOUS,
00325D  1               				;FORGET IT.
00325D  1  D0 04        	BNE	DVAR3
00325F  1  E4 AE        	CPX	GRBTOP		;COMPARE LOW ORDERS.
003261  1  90 10        	BCC	DVARTS		;[X,A] .LE. [GRBTOP].
003263  1  86 AE        DVAR3:	STX	GRBTOP
003265  1  85 AF        	STA	GRBTOP+1
003267  1  A5 71 A6 72  	LDWX	INDEX1
00326B  1  85 9D 86 9E  	STWX	GRBPNT
00326F  1  A5 A2        	LDA	FOUR6
003271  1  85 A4        	STA	SIZE
003273  1  A5 A2        DVARTS: LDA	FOUR6
003275  1  18           	CLC
003276  1  65 71        	ADC	INDEX1
003278  1  85 71        	STA	INDEX1
00327A  1  90 02        	BCC	GRBRTS
00327C  1  E6 72        	INC	INDEX1+1
00327E  1  A6 72        GRBRTS: LDX	INDEX1+1
003280  1  A0 00        	LDY	#0
003282  1  60           	RTS			;DONE.
003283  1               ;
003283  1               ; HERE WHEN MADE ONE COMPLETE PASS THROUGH STRING VARIABLES.
003283  1               ;
003283  1  A5 9E        GRBPAS: LDA	GRBPNT+1	;VARIABLE POINTER.
003285  1  05 9D        	ORA	GRBPNT
003287  1  F0 F5        	BEQ	GRBRTS		;ALL DONE.
003289  1  A5 A4        	LDA	SIZE
00328B  1  29 04        	AND	#4		;LEAVES C OFF.
00328D  1  4A           	LSR	A
00328E  1  A8           	TAY
00328F  1  85 A4        	STA	SIZE
003291  1  B1 9D        	LDADY	GRBPNT
003293  1               				;NOTE: GRBTOP=LOWTR SO NO NEED TO SET LOWTR.
003293  1  65 AE        	ADC	LOWTR
003295  1  85 A9        	STA	HIGHTR
003297  1  A5 AF        	LDA	LOWTR+1
003299  1  69 00        	ADC	#0
00329B  1  85 AA        	STA	HIGHTR+1
00329D  1  A5 82 A6 83  	LDWX	FRETOP
0032A1  1  85 A7 86 A8  	STWX	HIGHDS		;WHERE IT ALL GOES.
0032A5  1  20 D6 21     	JSR	BLTUC
0032A8  1  A4 A4        	LDY	SIZE
0032AA  1  C8           	INY
0032AB  1  A5 A7        	LDA	HIGHDS		;GET POSITION OF START OF RESULT.
0032AD  1  91 9D        	STADY	GRBPNT
0032AF  1  AA           	TAX
0032B0  1  E6 A8        	INC	HIGHDS+1
0032B2  1  A5 A8        	LDA	HIGHDS+1
0032B4  1  C8           	INY
0032B5  1  91 9D        	STADY	GRBPNT		;CHANGE ADDR OF STRING IN VAR.
0032B7  1  4C A7 31     	JMP	FNDVAR		;GO TO FNDVAR WITH SOMETHING FOR
0032BA  1               				;[FRETOP].
0032BA  1               ;
0032BA  1               ; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS.
0032BA  1               ; THE FAC CONTAINS THE FIRST ONE AT THIS POINT.
0032BA  1               ; [TXTPTR] POINTS TO THE + SIGN.
0032BA  1               ;
0032BA  1  A5 B4        CAT:	LDA	FACLO		;PSH HIGH ORDER ONTO STACK.
0032BC  1  48           	PHA
0032BD  1  A5 B3        	LDA	FACMO		;AND THE LOW.
0032BF  1  48           	PHA
0032C0  1  20 A2 2B     	JSR	EVAL		;CAN COME BACK HERE SINCE
0032C3  1               				;OPERATOR IS KNOWN.
0032C3  1  20 AE 2A     	JSR	CHKSTR		;RESULT MUST BE STRING.
0032C6  1  68           	PLA
0032C7  1  85 BE        	STA	STRNG1		;GET HIGH ORDER OF OLD DESC.
0032C9  1  68           	PLA
0032CA  1  85 BF        	STA	STRNG1+1
0032CC  1  A0 00        	LDY	#0
0032CE  1  B1 BE        	LDADY	STRNG1		;GET LENGTH OF OLD STRING.
0032D0  1  18           	CLC
0032D1  1  71 B3        	ADCDY	FACMO
0032D3  1  90 05        	BCC	SIZEOK		;RESULT IS LESS THAN 256.
0032D5  1  A2 1A        	LDX	#ERRLS		;ERROR "LONG STRING".
0032D7  1  4C 4E 22     	JMP	ERROR
0032DA  1  20 F1 30     SIZEOK: JSR	STRINI		;INITIALIZE STRING.
0032DD  1  20 F7 32     	JSR	MOVINS		;MOVE IT.
0032E0  1  A5 9F A4 A0  	LDWD	DSCPNT		;GET POINTER TO SECOND.
0032E4  1  20 27 33     	JSR	FRETMP		;FREE IT.
0032E7  1  20 09 33     	JSR	MOVDO
0032EA  1  A5 BE A4 BF  	LDWD	STRNG1
0032EE  1  20 27 33     	JSR	FRETMP
0032F1  1  20 42 31     	JSR	PUTNEW
0032F4  1  4C D7 2A     	JMP	TSTOP		;"CAT" REENTERS FORM EVAL AT TSTOP.
0032F7  1               
0032F7  1  A0 00        MOVINS: LDY	#0		;GET ADDR OF STRING.
0032F9  1  B1 BE        	LDADY	STRNG1
0032FB  1  48           	PHA
0032FC  1  C8           	INY
0032FD  1  B1 BE        	LDADY	STRNG1
0032FF  1  AA           	TAX
003300  1  C8           	INY
003301  1  B1 BE        	LDADY	STRNG1
003303  1  A8           	TAY
003304  1  68           	PLA
003305  1  86 71 84 72  MOVSTR: STXY	INDEX
003309  1  A8           MOVDO:	TAY
00330A  1  F0 0A        	BEQ	MVDONE
00330C  1  48           	PHA
00330D  1  88           MOVLP:	DEY
00330E  1  B1 71        	LDADY	INDEX
003310  1  91 84        	STADY	FRESPC
003312  1  98           QMOVE:	TYA
003313  1  D0 F8        	BNE	MOVLP
003315  1  68           	PLA
003316  1  18           MVDONE: CLC
003317  1  65 84        	ADC	FRESPC
003319  1  85 84        	STA	FRESPC
00331B  1  90 02        	BCC	MVSTRT
00331D  1  E6 85        	INC	FRESPC+1
00331F  1  60           MVSTRT: RTS
003320  1               ;
003320  1               ; "FRETMP" IS PASSED A STRING DESCRIPTOR PNTR IN [Y,A].
003320  1               ; A CHECK IS MADE TO SEE IF THE STRING DESCRIPTOR POINTS TO THE LAST
003320  1               ; TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
003320  1               ; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF [TEMPPT].
003320  1               ; IF A TEMP IS FREED UP, A FURTHER CHECK SEES IF THE STRING DATA THAT
003320  1               ; THAT STRING TEMP PNT'D TO IS THE LOWEST PART OF STRING SPACE IN USE.
003320  1               ; IF SO, [FRETOP] IS UPDATED TO REFLECT THE FACT THE FACT THAT THE SPACE
003320  1               ; IS NO LONGER IN USE.
003320  1               ; THE ADDR OF THE ACTUAL STRING IS RETURNED IN [Y,X] AND
003320  1               ; ITS LENGTH IN ACCA.
003320  1               ;
003320  1  20 AE 2A     FRESTR: JSR	CHKSTR		;MAKE SURE ITS A STRING.
003323  1  A5 B3 A4 B4  FREFAC: LDWD	FACMO		;FREE UP STR PNT'D TO BY FAC.
003327  1  85 71 84 72  FRETMP: STWD	INDEX		;GET LENGTH FOR LATER.
00332B  1  20 58 33     	JSR	FRETMS		;FREE UP THE TEMPORARY DESC.
00332E  1  08           	PHP			;SAVE CODES.
00332F  1  A0 00        	LDY	#0		;PREP TO GET STUFF.
003331  1  B1 71        	LDADY	INDEX		;GET COUNT AND
003333  1  48           	PHA			;SAVE IT.
003334  1  C8           	INY
003335  1  B1 71        	LDADY	INDEX
003337  1  AA           	TAX			;SAVE LOW ORDER.
003338  1  C8           	INY
003339  1  B1 71        	LDADY	INDEX
00333B  1  A8           	TAY			;SAVE HIGH ORDER.
00333C  1  68           	PLA
00333D  1  28           	PLP			;RETURN STATUS.
00333E  1  D0 13        	BNE	FRETRT
003340  1  C4 83        	CPY	FRETOP+1	;STRING IS LAST ONE IN?
003342  1  D0 0F        	BNE	FRETRT
003344  1  E4 82        	CPX	FRETOP
003346  1  D0 0B        	BNE	FRETRT
003348  1  48           	PHA
003349  1  18           	CLC
00334A  1  65 82        	ADC	FRETOP
00334C  1  85 82        	STA	FRETOP
00334E  1  90 02        	BCC	FREPLA
003350  1  E6 83        	INC	FRETOP+1
003352  1  68           FREPLA: PLA			;GET COUNT BACK.
003353  1  86 71 84 72  FRETRT: STXY	INDEX		;SAVE FOR LATER USE.
003357  1  60           	RTS
003358  1  C4 67        FRETMS: CPY	LASTPT+1	;LAST ENTRY TO TEMP?
00335A  1  D0 0C        	BNE	FRERTS
00335C  1  C5 66        	CMP	LASTPT
00335E  1  D0 08        	BNE	FRERTS
003360  1  85 65        	STA	TEMPPT
003362  1  E9 03        	SBC	#STRSIZ		;POINT TO LAST ONE.
003364  1  85 66        	STA	LASTPT		;UPDATE TEMP PNTR.
003366  1  A0 00        	LDY	#0		;ALSO CLEARS ZFLG SO WE DO REST OF FRETMP.
003368  1  60           FRERTS: RTS			;ALL DONE.
003369  1               ;
003369  1               ; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
003369  1               ; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARGUMENT (#)
003369  1               ; WHICH MUST BE .LT. 255.
003369  1               ;
003369  1  20 1E 34     CHR:	JSR	CONINT		;GET INTEGER IN RANGE.
00336C  1  8A           	TXA
00336D  1  48           	PHA
00336E  1  A9 01        	LDA	#1		;ONE-CHARACTER STRING.
003370  1  20 F9 30     	JSR	STRSPA		;GET SPACE FOR STRING.
003373  1  68           	PLA
003374  1  A0 00        	LDY	#0
003376  1  91 B1        	STADY	DSCTMP+1
003378  1  68           	PLA			;GET RID OF "CHKNUM" RETURN ADDR.
003379  1  68           	PLA
00337A  1  4C 42 31     RLZRET: JMP	PUTNEW		;SETUP FAC TO POINT TO DESC.
00337D  1               ;
00337D  1               ; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
00337D  1               ; IT TAKES THE LEFTMOST # CHARACTERS OF THE STRING.
00337D  1               ; IF # .GT. THE LEN OF THE STRING, IT RETURNS THE WHOLE STRING.
00337D  1               ;
00337D  1  20 DE 33     LEFT:	JSR	PREAM		;TEST PARAMETERS.
003380  1  D1 9F        	CMPDY	DSCPNT
003382  1  98           	TYA
003383  1  90 04        RLEFT:	BCC	RLEFT1
003385  1  B1 9F        	LDADY	DSCPNT
003387  1  AA           	TAX			;PUT LENGTH INTO X.
003388  1  98           	TYA			;ZERO A, THE OFFSET.
003389  1  48           RLEFT1: PHA			;SAVE OFFSET.
00338A  1  8A           RLEFT2: TXA
00338B  1  48           RLEFT3: PHA			;SAVE LENGTH.
00338C  1  20 F9 30     	JSR	STRSPA		;GET SPACE.
00338F  1  A5 9F A4 A0  	LDWD	DSCPNT
003393  1  20 27 33     	JSR	FRETMP
003396  1  68           	PLA
003397  1  A8           	TAY
003398  1  68           	PLA
003399  1  18           	CLC
00339A  1  65 71        	ADC	INDEX		;COMPUTE WHERE TO COPY.
00339C  1  85 71        	STA	INDEX
00339E  1  90 02        	BCC	PULMOR
0033A0  1  E6 72        	INC	INDEX+1
0033A2  1  98           PULMOR: TYA
0033A3  1  20 09 33     	JSR	MOVDO		;GO MOVE IT.
0033A6  1  4C 42 31     	JMP	PUTNEW
0033A9  1  20 DE 33     RIGHT:	JSR	PREAM
0033AC  1  18           	CLC			;[LENGTH DES'D]-[LENGTH]-1.
0033AD  1  F1 9F        	SBCDY	DSCPNT
0033AF  1  49 FF        	EOR	#255		;NEGATE.
0033B1  1  4C 83 33     	JMP	RLEFT
0033B4  1               ;
0033B4  1               ; MID ($,#) RETURNS STRING WITH CHARS FROM # POSITION
0033B4  1               ; ONWARD. IF # .GT. LEN ($) THEN RETURN NULL STRING.
0033B4  1               ; MID ($,#,#) RETURNS STRING WITH CHARACTERS FROM
0033B4  1               ; # POSITION FOR #2 CHARACTERS. IF #2 GOES PAST END OF STRING
0033B4  1               ; RETURN AS MUCH AS POSSIBLE.
0033B4  1               ;
0033B4  1  A9 FF        MID:	LDA	#255		;DEFAULT.
0033B6  1  85 B4        	STA	FACLO		;SAVE FOR LATER COMPARE.
0033B8  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER.
0033BB  1  C9 29        	CMP	#41		;IS IT A RIGHT PAREN )?
0033BD  1  F0 06        	BEQ	MID2		;NO THIRD PARAM.
0033BF  1  20 03 2C     	JSR	CHKCOM		;MUST HAVE COMMA.
0033C2  1  20 1B 34     	JSR	GETBYT		;GET THE LENGTH INTO "FACLO".
0033C5  1  20 DE 33     MID2:	JSR	PREAM		;CHECK IT OUT.
0033C8  1  F0 4B        	BEQ	GOFUC		;THERE IS NO POSTION 0
0033CA  1  CA           	DEX			;COMPUTE OFFSET.
0033CB  1  8A           	TXA
0033CC  1  48           	PHA			;PRSERVE AWHILE.
0033CD  1  18           	CLC
0033CE  1  A2 00        	LDX	#0
0033D0  1  F1 9F        	SBCDY	DSCPNT		;GET LENGTH OF WHAT'S LEFT.
0033D2  1  B0 B6        	BCS	RLEFT2		;GIVE NULL STRING.
0033D4  1  49 FF        	EOR	#255		;IN SUB C WAS 0 SO JUST COMPLEMENT.
0033D6  1  C5 B4        	CMP	FACLO		;GREATER THAN WHAT'S DESIRED?
0033D8  1  90 B1        	BCC	RLEFT3		;NO, COPY THAT MUCH.
0033DA  1  A5 B4        	LDA	FACLO		;GET LENGTH OF WHAT'S DESIRED.
0033DC  1  B0 AD        	BCS	RLEFT3		;COPY IT.
0033DE  1               
0033DE  1               ;
0033DE  1               ; USED BY RIGHT$, LEFT$, MID$ FOR PARAMETER CHECKING AND SETUP.
0033DE  1               ;
0033DE  1  20 FD 2B     PREAM:	JSR	CHKCLS		;PARAM LIST SHOULD END.
0033E1  1  68           	PLA			;GET THE RETURN ADDRESS INTO
0033E2  1  A8           	TAY			;[JMPER+1,Y]
0033E3  1  68           	PLA
0033E4  1  85 A4        	STA	JMPER+1
0033E6  1  68           	PLA			;GET RID OF FINGO'S JSR RET ADDR.
0033E7  1  68           	PLA
0033E8  1  68           	PLA			;GET LENGTH.
0033E9  1  AA           	TAX
0033EA  1  68 85 9F 68  	PULWD	DSCPNT
0033EE  1  85 A0        
0033F0  1  A5 A4        	LDA	JMPER+1		;PUT RETURN ADDRESS BACK ON
0033F2  1  48           	PHA
0033F3  1  98           	TYA
0033F4  1  48           	PHA
0033F5  1  A0 00        	LDY	#0
0033F7  1  8A           	TXA
0033F8  1  60           	RTS
0033F9  1               ;
0033F9  1               ; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE STRING
0033F9  1               ; PASSED AS AN ARGUMENT.
0033F9  1               ;
0033F9  1  20 FF 33     LEN:	JSR	LEN1
0033FC  1  4C 1E 30     	JMP	SNGFLT
0033FF  1  20 20 33     LEN1:	JSR	FRESTR		;FREE UP STRING.
003402  1  A2 00        	LDX	#0
003404  1  86 11        	STX	VALTYP		;FORCE NUMERIC.
003406  1  A8           	TAY			;SET CODES ON LENGTH.
003407  1  60           	RTS			;DONE.
003408  1               ;
003408  1               ; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS
003408  1               ; AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT.
003408  1               ;
003408  1  20 FF 33     ASC:	JSR	LEN1
00340B  1  F0 08        	BEQ	GOFUC		;NULL STRING, BAD ARG.
00340D  1  A0 00        	LDY	#0
00340F  1  B1 71        	LDADY	INDEX1		;GET CHARACTER.
003411  1  A8           	TAY
003412  1  4C 1E 30     	JMP	SNGFLT
003415  1  4C C5 2E     GOFUC:	JMP	FCERR		;YES.
003418  1               
003418  1  20 C2 00     GTBYTC: JSR	CHRGET
00341B  1  20 A9 2A     GETBYT: JSR	FRMNUM		;READ FORMULA INTO FAC.
00341E  1  20 35 2E     CONINT: JSR	POSINT		;CONVERT THE FAC TO A SINGLE BYTE INT.
003421  1  A6 B3        	LDX	FACMO
003423  1  D0 F0        	BNE	GOFUC		;RESULT MUST BE .LE. 255.
003425  1  A6 B4        	LDX	FACLO
003427  1  4C C8 00     CHRGO2: JMP	CHRGOT		;SET CONDITION CODES ON TERMINATOR.
00342A  1               ;
00342A  1               ; THE "VAL" FUNCTION TAKES A STRING AND TURNS IT INTO
00342A  1               ; A NUMBER BY INTERPRETING THE ASCII DIGITS ETCQ
00342A  1               ; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
00342A  1               ; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL IS MERELY
00342A  1               ; A CALL TO FLOATING POINT INPUT ("FIN").
00342A  1               ;
00342A  1  20 FF 33     VAL:	JSR	LEN1		;DO SETUP. SET RESULT=NUMERIC.
00342D  1  D0 03 4C 75  	JEQ	ZEROFC		;ZERO THE FAC ON A NULL STRING
003431  1  35           
003432  1  A6 C9 A4 CA  	LDXY	TXTPTR
003436  1  86 C0 84 C1  	STXY	STRNG2		;SAVE FOR LATER.
00343A  1  A6 71        	LDX	INDEX1
00343C  1  86 C9        	STX	TXTPTR
00343E  1  18           	CLC
00343F  1  65 71        	ADC	INDEX1
003441  1  85 73        	STA	INDEX2
003443  1  A6 72        	LDX	INDEX1+1
003445  1  86 CA        	STX	TXTPTR+1
003447  1  90 01        	BCC	VAL2		;NO CARRY, NO INC.
003449  1  E8           	INX
00344A  1  86 74        VAL2:	STX	INDEX2+1
00344C  1  A0 00        	LDY	#0
00344E  1  B1 73        	LDADY	INDEX2		;PRESERVE CHARACTER.
003450  1  48           	PHA
003451  1  A9 00        	LDA	#0		;SET A TERMINATOR.
003453  1  91 73        	STADY	INDEX2
003455  1  20 C8 00     	JSR	CHRGOT		;GET CHARACTER PNT'D TO AND SET FLAGS.
003458  1  20 71 39     	JSR	FIN
00345B  1  68           	PLA			;GET PRES'D CHARACTER.
00345C  1  A0 00        	LDY	#0
00345E  1  91 73        	STADY	INDEX2		;STUFF IT BACK.
003460  1  A6 C0 A4 C1  ST2TXT: LDXY	STRNG2
003464  1  86 C9 84 CA  	STXY	TXTPTR
003468  1  60           VALRTS: RTS			;ALL DONE WITH STRINGS.
003469  1               ; PAGE
003469  1               ; SUBTTL	PEEK, POKE, AND FNWAIT.
003469  1               
003469  1  20 A9 2A     GETNUM: JSR	FRMNUM		;GET ADDRESS.
00346C  1  20 75 34     	JSR	GETADR		;GET THAT LOCATION.
00346F  1  20 03 2C     COMBYT: JSR	CHKCOM		;CHECK FOR A COMMA.
003472  1  4C 1B 34     	JMP	GETBYT		;GET SOMETHING TO STORE AND RETURN.
003475  1  A5 B5        GETADR: LDA	FACSGN		;EXAMINE SIGN.
003477  1  30 9C        	BMI	GOFUC		;FUNCTION CALL ERROR.
003479  1  A5 B0        	LDA	FACEXP		;EXAMINE EXPONENT.
00347B  1  C9 91        	CMP	#145
00347D  1  B0 96        	BCS	GOFUC		;FUNCTION CALL ERROR.
00347F  1  20 19 39     	JSR	QINT		;INTEGERIZE IT.
003482  1  A5 B3 A4 B4  	LDWD	FACMO
003486  1  84 1B        	STY	POKER
003488  1  85 1C        	STA	POKER+1
00348A  1  60           	RTS			;IT'S DONE !.
00348B  1               
00348B  1  A5 1C 48 A5  PEEK:	PSHWD	POKER
00348F  1  1B 48        
003491  1  20 75 34     	JSR	GETADR
003494  1  A0 00        	LDY	#0
003496  1               .IF	REALIO-3 = 0
003496  1               	CMP	#ROMLOC/256	;IF WITHIN BASIC,
003496  1               	BCC	GETCON
003496  1               	CMP	#LASTWR/256
003496  1               	BCC	DOSGFL		;GIVE HIM ZERO FOR AN ANSWER.
003496  1               .ENDIF
003496  1  B1 1B        GETCON: LDADY	POKER		;GET THAT BYTE.
003498  1  A8           	TAY
003499  1  68 85 1B 68  DOSGFL: PULWD	POKER
00349D  1  85 1C        
00349F  1  4C 1E 30     	JMP	SNGFLT		;FLOAT IT.
0034A2  1               
0034A2  1  20 69 34     POKE:	JSR	GETNUM
0034A5  1  8A           	TXA
0034A6  1  A0 00        	LDY	#0
0034A8  1  91 1B        	STADY	POKER		;STORE VALUE AWAY.
0034AA  1  60           	RTS			;SCANNED  EVERYTHING.
0034AB  1               
0034AB  1               ; THE WAIT LOCATION,MASK1,MASK2 STATEMENT WAITS UNTIL THE CONTENTS
0034AB  1               ; OF LOCATION IS NONZERO WHEN XORED WITH MASK2
0034AB  1               ; AND THEN ANDED WITH MASK1. IF MASK2 IS NOT PRESENT, IT
0034AB  1               ; IS ASSUMED TO BE ZERO.
0034AB  1               
0034AB  1  20 69 34     FNWAIT: JSR	GETNUM
0034AE  1  86 98        	STX	ANDMSK
0034B0  1  A2 00        	LDX	#0
0034B2  1  20 C8 00     	JSR	CHRGOT
0034B5  1  F0 03        	BEQ	ZSTORDO
0034B7  1  20 6F 34     	JSR	COMBYT		;GET MASK2.
0034BA  1  86 99        STORDO: STX	EORMSK
0034BC  1  A0 00        	LDY	#0
0034BE  1  B1 1B        WAITER: LDADY	POKER
0034C0  1  45 99        	EOR	EORMSK
0034C2  1  25 98        	AND	ANDMSK
0034C4  1  F0 F8        	BEQ	WAITER
0034C6  1  60           ZERRTS: RTS			;GOT A NONZERO.
0034C7  1               ; SUBTTL FLOATING POINT MATH PACKAGE CONFIGURATION.
0034C7  1               
0034C7  1               ; RADIX	8			;!!!! ALERT !!!!
0034C7  1               				;THROUGHOUT THE MATH PACKAGE.
0034C7  1               
0034C7  1               ; THE FLOATING POINT FORMAT IS AS FOLLOWS:
0034C7  1               ;
0034C7  1               ; THE SIGN IS THE FIRST BIT OF THE MANTISSA.
0034C7  1               ; THE MANTISSA IS 24 BITS LONG.
0034C7  1               ; THE BINARY POINT IS TO THE LEFT OF THE MSB.
0034C7  1               ; NUMBER = MANTISSA * 2 ^ EXPONENT.
0034C7  1               ; THE MANTISSA IS POSITIVE WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS.
0034C7  1               ; THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT.
0034C7  1               ; THE EXPONENT IS STORED IN EXCESS 200, I.E. WITH A BIAS OF +200.
0034C7  1               ; SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT.
0034C7  1               ; AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO.
0034C7  1               ; THE OTHER BYTES MAY NOT BE ASSUMED TO BE ZERO.
0034C7  1               ; TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING,
0034C7  1               ; 	TO SHIFT RIGHT, EXP:=EXP+1
0034C7  1               ; 	TO SHIFT LEFT,	EXP:=EXP-1
0034C7  1               ;
0034C7  1               ; IN MEMORY THE NUMBER LOOKS LIKE THIS:
0034C7  1               ; 	[THE EXPONENT AS A SIGNED NUMBER +200]
0034C7  1               ; 	[THE SIGN BIT IN 7, BITS 2-8 OF MANTISSA ARE IN BITS 6-0].
0034C7  1               ; 		(REMEMBER BIT 1 OF MANTISSA IS ALWAYS A ONE.)
0034C7  1               ; 	[BITS 9-16 OF THE MANTISSA]
0034C7  1               ; 	[BITS 17-24] OF THE MANTISSA]
0034C7  1               ;
0034C7  1               ; ARITHMETIC ROUTINE CALLING CONVENTIONS:
0034C7  1               ;
0034C7  1               ; FOR ONE ARGUMENT FUNCTIONS:
0034C7  1               ; 	THE ARGUMENT IS IN THE FAC.
0034C7  1               ; 	THE RESULT IS LEFT IN THE FAC.
0034C7  1               ; FOR TWO ARGUMENT OPERATIONS:
0034C7  1               ; 	THE FIRST ARGUMENT IS IN ARG (ARGEXP,HO,MO,LO AND ARGSGN).
0034C7  1               ; 	THE SECOND ARGUMENT IS IN THE FAC.
0034C7  1               ; 	THE RESULT IS LEFT IN THE FAC.
0034C7  1               ;
0034C7  1               ; THE "T" ENTRY POINTS TO THE TWO-ARGUMENT OPERATIONS HAVE BOTH ARGUMENTS
0034C7  1               ; SETUP IN THE RESPECTIVE REGISTERS. BEFORE CALLING ARG MAY HAVE BEEN
0034C7  1               ; POPPED OFF THE STACK AND INTO ARG, FOR EXAMPLE.
0034C7  1               ; THE OTHER ENTRY POINT ASSUMES [Y,A] POINTS TO THE ARGUMENT
0034C7  1               ; SOMEWHERE IN MEMORY. IT IS UNPACKED INTO ARG BY "CONUPK".
0034C7  1               ;
0034C7  1               ; ON THE STACK, THE SGN IS PUSHED ON FIRST, THE LO,MO,HO AND FINALLY EXP.
0034C7  1               ; NOTE ALL THINGS ARE KEPT UNPACKED IN ARG, FAC AND ON THE STACK.
0034C7  1               ;
0034C7  1               ; IT IS ONLY WHEN SOMETHING IS STORED AWAY THAT IT IS PACKED TO FOUR
0034C7  1               ; BYTES. THE UNPACKED FORMAT HAS A SGN BYTE REFLECTING THE SIGN OF THE
0034C7  1               ; NUMBER (POSITIVE=0, NEGATIVE=-1) A HO,MO AND LO WITH THE HIGH BIT
0034C7  1               ; OF THE HO TURNED ON. THE EXP IS THE SAME AS STORED FORMAT.
0034C7  1               ; THIS IS DONE FOR SPEED OF OPERATION.
0034C7  1               
0034C7  1               ; PAGE
0034C7  1               ; SUBTTL	FLOATING POINT ADDITION AND SUBTRACTION.
0034C7  1  A9 8B A0 3B  FADDH:	LDWDI	FHALF		;ENTRY TO ADD 1/2.
0034CB  1  4C E5 34     	JMP	FADD		;UNPACK AND GO ADD IT.
0034CE  1  20 0A 37     FSUB:	JSR	CONUPK		;UNPACK ARGUMENT INTO ARG.
0034D1  1  A5 B5        FSUBT:	LDA	FACSGN
0034D3  1  49 FF        	EOR	#$FF		;COMPLEMENT IT.
0034D5  1  85 B5        	STA	FACSGN
0034D7  1  45 BD        	EOR	ARGSGN		;COMPLEMENT ARISGN.
0034D9  1  85 BE        	STA	ARISGN
0034DB  1  A5 B0        	LDA	FACEXP		;SET CODES ON FACEXP.
0034DD  1  4C E8 34     	JMP	FADDT		;[Y]=ARGEXP..
0034E0  1               ;	XLIST ; LGB
0034E0  1               ;.XCREF	; LGB
0034E0  1               .IF	REALIO-3  <> 0
0034E0  1               	ZSTORDO=STORDO
0034E0  1               .ENDIF
0034E0  1               .IF	REALIO-3 = 0
0034E0  1               ZSTORDO:			; LGB: probably again the 6 char max name problem, give alternative name for CA65
0034E0  1               ZSTORD:	LDA	POKER		; LGB: was: ZSTORD:!
0034E0  1               	CMP	#$66
0034E0  1               	BNE	STORDO
0034E0  1               	LDA	POKER+1
0034E0  1               	SBC	#$19
0034E0  1               	BNE	STORDO
0034E0  1               	STA	POKER
0034E0  1               	TAY
0034E0  1               	LDA	#$80
0034E0  1               	STA	POKER+1
0034E0  1               MRCHKR: LDX	#$A
0034E0  1               ;LGB IF1,<
0034E0  1               ;LGB MRCHR: LDA	60000,X,>	;
0034E0  1               ;LGB IF2,<
0034E0  1               MRCHR:	LDA	SINCON+$1E,X
0034E0  1               	AND	#$3F
0034E0  1               	STADY	POKER
0034E0  1               	INY
0034E0  1               	BNE	PKINC
0034E0  1               	INC	POKER+1
0034E0  1               PKINC:	DEX
0034E0  1               	BNE	MRCHR
0034E0  1               	DEC	ANDMSK
0034E0  1               	BNE	MRCHKR
0034E0  1               	RTS
0034E0  1               ; LGB IF2,<PURGE ZSTORD>	;
0034E0  1               .ENDIF
0034E0  1               ;.CREF	; LGB
0034E0  1               ;LIST ; LGB
0034E0  1  20 17 36     FADD5:	JSR	SHIFTR		;DO A LONG SHIFT.
0034E3  1  90 3C        	BCC	FADD4		;CONTINUE WITH ADDITION.
0034E5  1  20 0A 37     FADD:	JSR	CONUPK
0034E8  1  D0 03 4C 7A  FADDT:	JEQ	MOVFA		;IF FAC=0, RESULT IS IN ARG.
0034EC  1  38           
0034ED  1  A6 BF        	LDX	FACOV
0034EF  1  86 A5        	STX	OLDOV
0034F1  1  A2 B8        	LDX	#ARGEXP		;DEFAULT IS SHIFT ARGUMENT.
0034F3  1  A5 B8        	LDA	ARGEXP		;IF ARG=0, FAC IS RESULT.
0034F5  1  A8           FADDC:	TAY			;ALSO COPY ACCA INTO ACCY.
0034F6  1  F0 CE        	BEQ	ZERRTS		;RETURN.
0034F8  1  38           	SEC
0034F9  1  E5 B0        	SBC	FACEXP
0034FB  1  F0 24        	BEQ	FADD4		;NO SHIFTING.
0034FD  1  90 12        	BCC	FADDA		;BR IF ARGEXP.LT.FACEXP.
0034FF  1  84 B0        	STY	FACEXP		;RESULTING EXPONENT.
003501  1  A4 BD        	LDY	ARGSGN		;SINCE ARG IS BIGGER, IT'S
003503  1  84 B5        	STY	FACSGN		;SIGN IS SIGN OF RESULT.
003505  1  49 FF        	EOR	#$FF		;SHIFT A NEGATIVE NUMBER OF PLACES.
003507  1  69 00        	ADC	#0		;COMPLETE NEGATION. W/ C=1.
003509  1  A0 00        	LDY	#0		;ZERO OLDOV.
00350B  1  84 A5        	STY	OLDOV
00350D  1  A2 B0        	LDX	#FAC		;SHIFT THE FAC INSTEAD.
00350F  1  D0 04        	BNE	FADD1
003511  1  A0 00        FADDA:	LDY	#0
003513  1  84 BF        	STY	FACOV
003515  1  C9 F9        FADD1:	CMP	#256-7		;FOR SPEED AND NECESSITY.  GETS
003517  1               				;MOST LIKELY CASE TO SHIFTR FASTEST
003517  1               				;AND ALLOWS SHIFTING OF NEG NUMS
003517  1               				;BY "QINT".
003517  1  30 C7        	BMI	FADD5		;SHIFT BIG.
003519  1  A8           	TAY
00351A  1  A5 BF        	LDA	FACOV		;SET FACOV.
00351C  1  56 01        	LSR	1,X 		;GETS 0 IN MOST SIG BIT.
00351E  1  20 2E 36     	JSR	ROLSHF		;DO THE ROLLING.
003521  1  24 BE        FADD4:	BIT	ARISGN		;GET RESULTING SIGN.
003523  1  10 57        	BPL	FADD2		;IF POSITIVE, ADD.
003525  1               				;CARRY IS CLEAR.
003525  1  A0 B0        FADD3:	LDY	#FACEXP
003527  1  E0 B8        	CPX	#ARGEXP		;FAC IS BIGGER.
003529  1  F0 02        	BEQ	SUBIT
00352B  1  A0 B8        	LDY	#ARGEXP		;ARG IS BIGGER.
00352D  1  38           SUBIT:	SEC
00352E  1  49 FF        	EOR	#$FF
003530  1  65 A5        	ADC	OLDOV
003532  1  85 BF        	STA	FACOV
003534  1  B9 04 00     	LDA	3+ADDPRC,Y
003537  1  F5 04        	SBC	3+ADDPRC,X
003539  1  85 B4        	STA	FACLO
00353B  1  B9 03 00     	LDA	2+ADDPRC,Y
00353E  1  F5 03        	SBC	2+ADDPRC,X
003540  1  85 B3        	STA	FACMO
003542  1               .IF	ADDPRC <> 0
003542  1  B9 02 00     	LDA	2,Y
003545  1  F5 02        	SBC	2,X
003547  1  85 B2        	STA	FACMOH
003549  1               .ENDIF
003549  1  B9 01 00     	LDA	1,Y
00354C  1  F5 01        	SBC	1,X
00354E  1  85 B1        	STA	FACHO
003550  1  B0 03        FADFLT: BCS	NORMAL		;HERE IF SIGNS DIFFER. IF CARRY,
003552  1               				;FAC IS SET OK.
003552  1  20 C5 35     	JSR	NEGFAC		;NEGATE [FAC].
003555  1  A0 00        NORMAL: LDY	#0
003557  1  98           	TYA
003558  1  18           	CLC
003559  1  A6 B1        NORM3:	LDX	FACHO
00355B  1  D0 4A        	BNE	NORM1
00355D  1  A6 B2        	LDX	FACHO+1		;SHIFT 8 BITS AT A TIME FOR SPEED.
00355F  1  86 B1        	STX	FACHO
003561  1               .IF	ADDPRC <> 0
003561  1  A6 B3        	LDX	FACMOH+1
003563  1  86 B2        	STX	FACMOH
003565  1               .ENDIF
003565  1  A6 B4        	LDX	FACMO+1
003567  1  86 B3        	STX	FACMO
003569  1  A6 BF        	LDX	FACOV
00356B  1  86 B4        	STX	FACLO
00356D  1  84 BF        	STY	FACOV
00356F  1  69 08        	ADC	#$8
003571  1  C9 20        	CMP	#$8*ADDPRC+$18
003573  1  D0 E4        	BNE	NORM3
003575  1  A9 00        ZEROFC: LDA	#0		;NOT NEED BY NORMAL BUT BY OTHERS.
003577  1  85 B0        ZEROF1: STA	FACEXP		;NUMBER MUST BE ZERO.
003579  1  85 B5        ZEROML: STA	FACSGN		;MAKE SIGN POSITIVE.
00357B  1  60           	RTS			;ALL DONE.
00357C  1  65 A5        FADD2:	ADC	OLDOV
00357E  1  85 BF        	STA	FACOV
003580  1  A5 B4        	LDA	FACLO
003582  1  65 BC        	ADC	ARGLO
003584  1  85 B4        	STA	FACLO
003586  1  A5 B3        	LDA	FACMO
003588  1  65 BB        	ADC	ARGMO
00358A  1  85 B3        	STA	FACMO
00358C  1               .IF	ADDPRC <> 0
00358C  1  A5 B2        	LDA	FACMOH
00358E  1  65 BA        	ADC	ARGMOH
003590  1  85 B2        	STA	FACMOH
003592  1               .ENDIF
003592  1  A5 B1        	LDA	FACHO
003594  1  65 B9        	ADC	ARGHO
003596  1  85 B1        	STA	FACHO
003598  1  4C B4 35     	JMP	SQUEEZ		;GO ROUND IF SIGNS SAME.
00359B  1               
00359B  1  69 01        NORM2:	ADC	#1		;DECREMENT SHIFT COUNT.
00359D  1  06 BF        	ASL	FACOV		;SHIFT ALL LEFT ONE BIT.
00359F  1  26 B4        	ROL	FACLO
0035A1  1  26 B3        	ROL	FACMO
0035A3  1               .IF	ADDPRC <> 0
0035A3  1  26 B2        	ROL	FACMOH
0035A5  1               .ENDIF
0035A5  1  26 B1        	ROL	FACHO
0035A7  1  10 F2        NORM1:	BPL	NORM2		;IF MSB=0 SHIFT AGAIN.
0035A9  1  38           	SEC
0035AA  1  E5 B0        	SBC	FACEXP
0035AC  1  B0 C7        	BCS	ZEROFC
0035AE  1  49 FF        	EOR	#$FF
0035B0  1  69 01        	ADC	#1		;COMPLEMENT.
0035B2  1  85 B0        	STA	FACEXP
0035B4  1  90 0E        SQUEEZ: BCC	RNDRTS		;BITS TO SHIFT?
0035B6  1  E6 B0        RNDSHF: INC	FACEXP
0035B8  1  F0 42        	BEQ	OVERR
0035BA  1  66 B1        	ROR	FACHO
0035BC  1               .IF	ADDPRC <> 0
0035BC  1  66 B2        	ROR	FACMOH
0035BE  1               .ENDIF
0035BE  1  66 B3        	ROR	FACMO
0035C0  1  66 B4        	ROR	FACLO
0035C2  1  66 BF        	ROR	FACOV
0035C4  1  60           RNDRTS: RTS			;ALL DONE ADDING.
0035C5  1               
0035C5  1  A5 B5 49 FF  NEGFAC: COM	FACSGN		;COMPLEMENT FAC	 ENTIRELY.
0035C9  1  85 B5        
0035CB  1  A5 B1 49 FF  NEGFCH: COM	FACHO		;COMPLEMENT JUST THE NUMBER.
0035CF  1  85 B1        
0035D1  1               .IF	ADDPRC <> 0
0035D1  1  A5 B2 49 FF  	COM	FACMOH
0035D5  1  85 B2        
0035D7  1               .ENDIF
0035D7  1  A5 B3 49 FF  	COM	FACMO
0035DB  1  85 B3        
0035DD  1  A5 B4 49 FF  	COM	FACLO
0035E1  1  85 B4        
0035E3  1  A5 BF 49 FF  	COM	FACOV
0035E7  1  85 BF        
0035E9  1  E6 BF        	INC	FACOV
0035EB  1  D0 0E        	BNE	INCFRT
0035ED  1  E6 B4        INCFAC: INC	FACLO
0035EF  1  D0 0A        	BNE	INCFRT
0035F1  1  E6 B3        	INC	FACMO
0035F3  1  D0 06        	BNE	INCFRT		;IF NO CARRY, RETURN.
0035F5  1               .IF	ADDPRC <> 0
0035F5  1  E6 B2        	INC	FACMOH
0035F7  1  D0 02        	BNE	INCFRT
0035F9  1               .ENDIF
0035F9  1  E6 B1        	INC	FACHO		;CARRY INCREMENT.
0035FB  1  60           INCFRT: RTS
0035FC  1               
0035FC  1  A2 0A        OVERR:	LDX	#ERROV
0035FE  1  4C 4E 22     	JMP	ERROR		;TELL USER.
003601  1               ;
003601  1               ; "SHIFTR" SHIFTS [X+1:X+3] [-ACCA]  BITS RIGHT.
003601  1               ; SHIFTS BYTES TO START WITH IF POSSIBLE.
003601  1               ;
003601  1  A2 74        MULSHF: LDX	#RESHO-1		;ENTRY POINT FOR MULTIPLIER.
003603  1  B4 04        SHFTR2: LDY	3+ADDPRC,X 	;SHIFT BYTES FIRST.
003605  1  84 BF        	STY	FACOV
003607  1               .IF	ADDPRC <> 0
003607  1  B4 03        	LDY	3,X
003609  1  94 04        	STY	4,X
00360B  1               .ENDIF
00360B  1  B4 02        	LDY	2,X 		;GET MO.
00360D  1  94 03        	STY	3,X 		;STORE LO.
00360F  1  B4 01        	LDY	1,X 		;GET HO.
003611  1  94 02        	STY	2,X 		;STORE MO.
003613  1  A4 B7        	LDY	BITS
003615  1  94 01        	STY	1,X 		;STORE HO.
003617  1  69 08        SHIFTR: ADC	#$8
003619  1  30 E8        	BMI	SHFTR2
00361B  1  F0 E6        	BEQ	SHFTR2
00361D  1  E9 08        	SBC	#$8		;C CAN BE EITHER 1,0 AND IT WORKS.
00361F  1  A8           	TAY
003620  1  A5 BF        	LDA	FACOV
003622  1  B0 14        	BCS	SHFTRT		;EQUIV TO BEQ HERE.
003624  1               .IF	RORSW <> 0
003624  1  16 01        SHFTR3: ASL	1,X
003626  1  90 02        	BCC	SHFTR4
003628  1  F6 01        	INC	1,X
00362A  1  76 01        SHFTR4: ROR	1,X
00362C  1  76 01        	ROR	1,X		;YES, TWO OF THEM.
00362E  1               .ENDIF
00362E  1               .IF	RORSW = 0
00362E  1               SHFTR3: PHA
00362E  1               	LDA	1,X
00362E  1               	AND	#$80
00362E  1               	LSR	1,X
00362E  1               	ORA	1,X
00362E  1               	STA	1,X
00362E  1               	SKIP1
00362E  1               .ENDIF
00362E  1               ROLSHF:
00362E  1               .IF	RORSW <> 0
00362E  1  76 02        	ROR	2,X
003630  1  76 03        	ROR	3,X
003632  1               .IF	ADDPRC <> 0
003632  1  76 04        	ROR	4,X	;ONE MO TIME.
003634  1               .ENDIF
003634  1               .ENDIF
003634  1               .IF	RORSW = 0
003634  1               	PHA
003634  1               	LDA	#0
003634  1               	BCC	SHFTR5
003634  1               	LDA	#$80
003634  1               SHFTR5: LSR	2,X
003634  1               	ORA	2,X
003634  1               	STA	2,X
003634  1               	LDA	#0
003634  1               	BCC	SHFTR6
003634  1               	LDA	#$80
003634  1               SHFTR6: LSR	3,X
003634  1               	ORA	3,X
003634  1               	STA	3,X
003634  1               .IF	ADDPRC <> 0
003634  1               	LDA	#0
003634  1               	BCC	SHFT6A
003634  1               	LDA	#$80
003634  1               SHFT6A: LSR	4,X
003634  1               	ORA	4,X
003634  1               	STA	4,X
003634  1               .ENDIF
003634  1               .ENDIF
003634  1               .IF	RORSW <> 0
003634  1  6A           	ROR	A 	;ROTATE ARGUMENT 1 BIT RIGHT.
003635  1               .ENDIF
003635  1               .IF	RORSW = 0
003635  1               	PLA
003635  1               	PHP
003635  1               	LSR	A
003635  1               	PLP
003635  1               	BCC	SHFTR7
003635  1               	ORA	#$80
003635  1               .ENDIF
003635  1  C8           SHFTR7: INY
003636  1  D0 EC        	BNE	SHFTR3		;$$$ ( MOST EXPENSIVE ! )
003638  1  18           SHFTRT: CLC			;CLEAR OUTPUT OF FACOV.
003639  1  60           	RTS
00363A  1               ; PAGE
00363A  1               ; SUBTTL	NATURAL LOG FUNCTION.
00363A  1               ;
00363A  1               ; CALCULATION IS BY:
00363A  1               ; LN(F*2^N)=(N+LOG2(F))*LN(2)
00363A  1               ; AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F).
00363A  1               ;  CONSTANTS USED BY LOG:
00363A  1  81           FONE:	.BYTE $81	; 1.0
00363B  1  00           .BYTE	0
00363C  1  00           .BYTE	0
00363D  1  00           .BYTE	0
00363E  1               .IF	ADDPRC <> 0
00363E  1  00           .BYTE	0
00363F  1               .ENDIF
00363F  1               .IF	ADDPRC = 0
00363F  1               LOGCN2: .BYTE 2	; DEGREE-1
00363F  1               .BYTE	$80	; 0.59897437
00363F  1               .BYTE	$19
00363F  1               .BYTE	$56
00363F  1               .BYTE	$62
00363F  1               .BYTE	$80	; 0.96147080
00363F  1               .BYTE	$76
00363F  1               .BYTE	$22
00363F  1               .BYTE	$F3
00363F  1               .BYTE	$82	; 2.88539129
00363F  1               .BYTE	$38
00363F  1               .BYTE	$AA
00363F  1               .BYTE	$40
00363F  1               .ENDIF
00363F  1               
00363F  1               .IF	ADDPRC <> 0
00363F  1  03           LOGCN2: .BYTE 3	;DEGREE-1
003640  1  7F           .BYTE	$7F	;.43425594188
003641  1  5E           .BYTE	$5E
003642  1  56           .BYTE	$56
003643  1  CB           .BYTE	$CB
003644  1  79           .BYTE	$79
003645  1  80           .BYTE	$80	; .57658454134
003646  1  13           .BYTE	$13
003647  1  9B           .BYTE	$9B
003648  1  0B           .BYTE	$B
003649  1  64           .BYTE	$64
00364A  1  80           .BYTE	$80	; .96180075921
00364B  1  76           .BYTE	$76
00364C  1  38           .BYTE	$38
00364D  1  93           .BYTE	$93
00364E  1  16           .BYTE	$16
00364F  1  82           .BYTE	$82	; 2.8853900728
003650  1  38           .BYTE	$38
003651  1  AA           .BYTE	$AA
003652  1  3B           .BYTE	$3B
003653  1  20           .BYTE	$20
003654  1               .ENDIF
003654  1  80           SQRHLF: .BYTE $80	; SQR(0.5)
003655  1  35           .BYTE	$35
003656  1  04           .BYTE	4
003657  1  F3           .BYTE	$F3
003658  1               .IF	ADDPRC <> 0
003658  1  34           .BYTE	$34
003659  1               .ENDIF
003659  1  81           SQRTWO: .BYTE $81	; SQR(2.0)
00365A  1  35           .BYTE	$35
00365B  1  04           .BYTE	4
00365C  1  F3           .BYTE	$F3
00365D  1               .IF	ADDPRC <> 0
00365D  1  34           .BYTE	$34
00365E  1               .ENDIF
00365E  1  80           NEGHLF: .BYTE $80	; -1/2
00365F  1  80           .BYTE	$80
003660  1  00           .BYTE	0
003661  1  00           .BYTE	0
003662  1               .IF	ADDPRC <> 0
003662  1  00           .BYTE	0
003663  1               .ENDIF
003663  1  80           LOG2:	.BYTE $80	; LN(2)
003664  1  31           .BYTE	$31
003665  1  72           .BYTE	$72
003666  1               .IF	ADDPRC = 0
003666  1               .BYTE	$18
003666  1               .ENDIF
003666  1               .IF	ADDPRC <> 0
003666  1  17           .BYTE	$17
003667  1  F8           .BYTE	$F8
003668  1               .ENDIF
003668  1               
003668  1  20 A9 38     LOG:	JSR	SIGN		;IS IT POSITIVE?
00366B  1  F0 02        	BEQ	LOGERR
00366D  1  10 03        	BPL	LOG1
00366F  1  4C C5 2E     LOGERR: JMP	FCERR		;CAN'T TOLERATE NEG OR ZERO.
003672  1  A5 B0        LOG1:	LDA	FACEXP		;GET EXPONENT INTO ACCA.
003674  1  E9 7F        	SBC	#$7F		;REMOVE BIAS. (CARRY IS OFF)
003676  1  48           	PHA			;SAVE AWHILE.
003677  1  A9 80        	LDA	#$80
003679  1  85 B0        	STA	FACEXP		;RESULT IS FAC IN RANGE [0.5,1].
00367B  1  A9 54 A0 36  	LDWDI	SQRHLF		;GET POINTER TO SQR(0.5).
00367F  1               
00367F  1               ; CALCULATE (F-SQR(.5))/(F+SQR(.5))
00367F  1               
00367F  1  20 E5 34     	JSR	FADD		;ADD TO FAC.
003682  1  A9 59 A0 36  	LDWDI	SQRTWO		;GET SQR(2.).
003686  1  20 8D 37     	JSR	FDIV
003689  1  A9 3A A0 36  	LDWDI	FONE
00368D  1  20 CE 34     	JSR	FSUB
003690  1  A9 3F A0 36  	LDWDI	LOGCN2
003694  1  20 83 3C     	JSR	POLYX		;EVALUATE APPROXIMATION POLYNOMIAL.
003697  1  A9 5E A0 36  	LDWDI	NEGHLF		;ADD IN LAST CONSTANT.
00369B  1  20 E5 34     	JSR	FADD
00369E  1  68           	PLA			;GET EXPONENT BACK.
00369F  1  20 FC 39     	JSR	FINLOG		;ADD IT IN.
0036A2  1  A9 63 A0 36  MULLN2: LDWDI	LOG2		;MULTIPLY RESULT BY LOG(2.0).
0036A6  1               ;	JMP	FMULT		;MULTIPLY TOGETHER.
0036A6  1               ; PAGE
0036A6  1               ; SUBTTL	FLOATING MULTIPLICATION AND DIVISION.
0036A6  1               	;MULTIPLICATION		FAC:=ARG*FAC.
0036A6  1  20 0A 37     FMULT:	JSR	CONUPK		;UNPACK THE CONSTANT INTO ARG FOR USE.
0036A9  1  D0 03 4C 09  FMULTT: JEQ	MULTRT		;IF FAC=0, RETURN. FAC IS SET.
0036AD  1  37           
0036AE  1  20 35 37     	JSR	MULDIV		;FIX UP THE EXPONENTS.
0036B1  1  A9 00        	LDA	#0		;TO CLEAR RESULT.
0036B3  1  85 75        	STA	RESHO
0036B5  1               .IF	ADDPRC <> 0
0036B5  1  85 76        	STA	RESMOH
0036B7  1               .ENDIF
0036B7  1  85 77        	STA	RESMO
0036B9  1  85 78        	STA	RESLO
0036BB  1  A5 BF        	LDA	FACOV
0036BD  1  20 D7 36     	JSR	MLTPLY
0036C0  1  A5 B4        	LDA	FACLO		;MLTPLY ARG BY FACLO.
0036C2  1  20 D7 36     	JSR	MLTPLY
0036C5  1  A5 B3        	LDA	FACMO		;MLTPLY ARG BY FACMO.
0036C7  1  20 D7 36     	JSR	MLTPLY
0036CA  1               .IF	ADDPRC <> 0
0036CA  1  A5 B2        	LDA	FACMOH
0036CC  1  20 D7 36     	JSR	MLTPLY
0036CF  1               .ENDIF
0036CF  1  A5 B1        	LDA	FACHO		;MLTPLY ARG BY FACHO.
0036D1  1  20 DC 36     	JSR	MLTPL1
0036D4  1  4C 0D 38     	JMP	MOVFR		;MOVE RESULT INTO FAC,
0036D7  1               				;NORMALIZE RESULT, AND RETURN.
0036D7  1  D0 03 4C 01  MLTPLY: JEQ	MULSHF		;SHIFT RESULT RIGHT 1 BYTE.
0036DB  1  36           
0036DC  1  4A           MLTPL1: LSR	A
0036DD  1  09 80        	ORA	#$80
0036DF  1  A8           MLTPL2: TAY
0036E0  1  90 19        	BCC	MLTPL3		;IT MULT BIT=0, JUST SHIFT.
0036E2  1  18           	CLC
0036E3  1  A5 78        	LDA	RESLO
0036E5  1  65 BC        	ADC	ARGLO
0036E7  1  85 78        	STA	RESLO
0036E9  1  A5 77        	LDA	RESMO
0036EB  1  65 BB        	ADC	ARGMO
0036ED  1  85 77        	STA	RESMO
0036EF  1               .IF	ADDPRC <> 0
0036EF  1  A5 76        	LDA	RESMOH
0036F1  1  65 BA        	ADC	ARGMOH
0036F3  1  85 76        	STA	RESMOH
0036F5  1               .ENDIF
0036F5  1  A5 75        	LDA	RESHO
0036F7  1  65 B9        	ADC	ARGHO
0036F9  1  85 75        	STA	RESHO
0036FB  1  66 75        MLTPL3: ROR	RESHO
0036FD  1               .IF	ADDPRC <> 0
0036FD  1  66 76        	ROR	RESMOH
0036FF  1               .ENDIF
0036FF  1  66 77        	ROR	RESMO
003701  1  66 78        	ROR	RESLO
003703  1  66 BF        	ROR	FACOV		;SAVE FOR ROUNDING.
003705  1  98           	TYA
003706  1  4A           	LSR	A 		;CLEAR MSB SO WE GET A CLOSER TO 0.
003707  1  D0 D6        	BNE	MLTPL2		;SLOW AS A TURTLE !
003709  1  60           MULTRT: RTS
00370A  1               
00370A  1               	;ROUTINE TO UNPACK MEMORY INTO ARG.
00370A  1  85 71 84 72  CONUPK: STWD	INDEX1
00370E  1  A0 04        	LDY	#3+ADDPRC
003710  1  B1 71        	LDADY	INDEX1
003712  1  85 BC        	STA	ARGLO
003714  1  88           	DEY
003715  1  B1 71        	LDADY	INDEX1
003717  1  85 BB        	STA	ARGMO
003719  1  88           	DEY
00371A  1               .IF	ADDPRC <> 0
00371A  1  B1 71        	LDADY	INDEX1
00371C  1  85 BA        	STA	ARGMOH
00371E  1  88           	DEY
00371F  1               .ENDIF
00371F  1  B1 71        	LDADY	INDEX1
003721  1  85 BD        	STA	ARGSGN
003723  1  45 B5        	EOR	FACSGN
003725  1  85 BE        	STA	ARISGN
003727  1  A5 BD        	LDA	ARGSGN
003729  1  09 80        	ORA	#$80
00372B  1  85 B9        	STA	ARGHO
00372D  1  88           	DEY
00372E  1  B1 71        	LDADY	INDEX1
003730  1  85 B8        	STA	ARGEXP
003732  1  A5 B0        	LDA	FACEXP		;SET CODES OF FACEXP.
003734  1  60           	RTS
003735  1               
003735  1               	;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV.
003735  1  A5 B8        MULDIV: LDA	ARGEXP		;EXP OF ARG=0?
003737  1  F0 1F        MLDEXP: BEQ	ZEREMV		;SO WE GET ZERO EXPONENT.
003739  1  18           	CLC
00373A  1  65 B0        	ADC	FACEXP		;RESULT IS IN ACCA.
00373C  1  90 04        	BCC	TRYOFF		;FIND [C] XOR [N].
00373E  1  30 1D        	BMI	GOOVER		;OVERFLOW IF BITS MATCH.
003740  1  18 2C        	CLC
003742  1               	SKIP2
003742  1  10 14        TRYOFF: BPL	ZEREMV		;UNDERFLOW.
003744  1  69 80        	ADC	#$80		;ADD BIAS.
003746  1  85 B0        	STA	FACEXP
003748  1  D0 03 4C 79  	JEQ	ZEROML		;ZERO THE REST OF IT.
00374C  1  35           
00374D  1  A5 BE        	LDA	ARISGN
00374F  1  85 B5        	STA	FACSGN		;ARISGN IS RESULT'S SIGN.
003751  1  60           	RTS			;DONE.
003752  1  A5 B5        MLDVEX: LDA	FACSGN		;GET SIGN.
003754  1  49 FF        	EOR	#$FF		;COMPLEMENT IT.
003756  1  30 05        	BMI	GOOVER
003758  1  68           ZEREMV: PLA			;GET ADDR OFF STACK.
003759  1  68           	PLA
00375A  1  4C 75 35     	JMP	ZEROFC		;UNDERFLOW.
00375D  1  4C FC 35     GOOVER: JMP	OVERR		;OVERFLOW.
003760  1               
003760  1               	;MULTIPLY FAC BY 10.
003760  1  20 8A 38     MUL10:	JSR	MOVAF		;COPY FAC INTO ARG.
003763  1  AA           	TAX
003764  1  F0 10        	BEQ	MUL10R		;IF [FAC]=0, GOT ANSWER.
003766  1  18           	CLC
003767  1  69 02        	ADC	#2		;AUGMENT EXP BY 2.
003769  1  B0 F2        	BCS	GOOVER		;OVERFLOW.
00376B  1  A2 00        FINML6: LDX	#0
00376D  1  86 BE        	STX	ARISGN		;SIGNS ARE SAME.
00376F  1  20 F5 34     	JSR	FADDC		;ADD TOGETHER.
003772  1  E6 B0        	INC	FACEXP		;MULTIPLY BY TWO.
003774  1  F0 E7        	BEQ	GOOVER		;OVERFLOW.
003776  1  60           MUL10R: RTS
003777  1               
003777  1               	; DIVIDE FAC BY 10.
003777  1  84           TENZC:	.BYTE $84
003778  1  20           .BYTE	$20
003779  1  00           .BYTE	0
00377A  1  00           .BYTE	0
00377B  1               .IF	ADDPRC <> 0
00377B  1  00           .BYTE	0
00377C  1               .ENDIF
00377C  1  20 8A 38     DIV10:	JSR	MOVAF		;MOVE FAC TO ARG.
00377F  1  A9 77 A0 37  	LDWDI	TENZC		;POINT TO CONSTANT OF 10.0
003783  1  A2 00        	LDX	#0		;SIGNS ARE BOTH POSITIVE.
003785  1  86 BE        FDIVF:	STX	ARISGN
003787  1  20 20 38     	JSR	MOVFM		;PUT IT INTO FAC.
00378A  1  4C 90 37     	JMP	FDIVT		;SKIP OVER NEXT TWO BYTES.
00378D  1  20 0A 37     FDIV:	JSR	CONUPK		;UNPACK CONSTANT.
003790  1  F0 76        FDIVT:	BEQ	DV0ERR		;CAN'T DIVIDE BY ZERO !
003792  1               				;(NOT ENOUGH ROOM TO STORE RESULT.)
003792  1  20 99 38     	JSR	ROUND		;TAKE FACOV INTO ACCT IN FAC.
003795  1  A9 00        	LDA	#0		;NEGATE FACEXP.
003797  1  38           	SEC
003798  1  E5 B0        	SBC	FACEXP
00379A  1  85 B0        	STA	FACEXP
00379C  1  20 35 37     	JSR	MULDIV		;FIX UP EXPONENTS.
00379F  1  E6 B0        	INC	FACEXP		;SCALE IT RIGHT.
0037A1  1  F0 BA        	BEQ	GOOVER		;OVERFLOW.
0037A3  1  A2 FC        	LDX	#256-3-ADDPRC	;SETUP PROCEDURE.
0037A5  1  A9 01        	LDA	#1
0037A7  1               DIVIDE:				;THIS IS THE BEST CODE IN THE WHOLE PILE.
0037A7  1  A4 B9        	LDY	ARGHO		;SEE WHAT RELATION HOLDS.
0037A9  1  C4 B1        	CPY	FACHO
0037AB  1  D0 10        	BNE	SAVQUO		;[C]=0,1. N(C=0)=0.
0037AD  1               .IF	ADDPRC <> 0
0037AD  1  A4 BA        	LDY	ARGMOH
0037AF  1  C4 B2        	CPY	FACMOH
0037B1  1  D0 0A        	BNE	SAVQUO
0037B3  1               .ENDIF
0037B3  1  A4 BB        	LDY	ARGMO
0037B5  1  C4 B3        	CPY	FACMO
0037B7  1  D0 04        	BNE	SAVQUO
0037B9  1  A4 BC        	LDY	ARGLO
0037BB  1  C4 B4        	CPY	FACLO
0037BD  1  08           SAVQUO: PHP
0037BE  1  2A           	ROL	A 		;SAVE RESULT.
0037BF  1  90 09        	BCC	QSHFT		;IF NOT DONE, CONTINUE.
0037C1  1  E8           	INX
0037C2  1  95 78        	STA	RESLO,X
0037C4  1  F0 32        	BEQ	LD100
0037C6  1  10 34        	BPL	DIVNRM		;NOTE THIS REQ 1 MO RAM THEN NECESS.
0037C8  1  A9 01        	LDA	#1
0037CA  1  28           QSHFT:	PLP			;RETURN CONDITION CODES.
0037CB  1  B0 0E        	BCS	DIVSUB		;FAC .LE. ARG.
0037CD  1  06 BC        SHFARG: ASL	ARGLO		;SHIFT ARG ONE PLACE LEFT.
0037CF  1  26 BB        	ROL	ARGMO
0037D1  1               .IF	ADDPRC <> 0
0037D1  1  26 BA        	ROL	ARGMOH
0037D3  1               .ENDIF
0037D3  1  26 B9        	ROL	ARGHO
0037D5  1  B0 E6        	BCS	SAVQUO		;SAVE A RESULT OF ONE FOR THIS POSITION
0037D7  1               				;AND DIVIDE.
0037D7  1  30 CE        	BMI	DIVIDE		;IF MSB ON, GO DECIDE WHETHER TO SUB.
0037D9  1  10 E2        	BPL	SAVQUO
0037DB  1  A8           DIVSUB: TAY			;NOTICE C MUST BE ON HERE.
0037DC  1  A5 BC        	LDA	ARGLO
0037DE  1  E5 B4        	SBC	FACLO
0037E0  1  85 BC        	STA	ARGLO
0037E2  1  A5 BB        	LDA	ARGMO
0037E4  1  E5 B3        	SBC	FACMO
0037E6  1  85 BB        	STA	ARGMO
0037E8  1               .IF	ADDPRC <> 0
0037E8  1  A5 BA        	LDA	ARGMOH
0037EA  1  E5 B2        	SBC	FACMOH
0037EC  1  85 BA        	STA	ARGMOH
0037EE  1               .ENDIF
0037EE  1  A5 B9        	LDA	ARGHO
0037F0  1  E5 B1        	SBC	FACHO
0037F2  1  85 B9        	STA	ARGHO
0037F4  1  98           	TYA
0037F5  1  4C CD 37     	JMP	SHFARG
0037F8  1  A9 40        LD100:	LDA	#$40		;ONLY WANT TWO MORE BITS.
0037FA  1  D0 CE        	BNE	QSHFT		;ALWAYS BRANCHES.
0037FC  1  0A 0A 0A 0A  DIVNRM: REPEAT	6,{ASL A}	;GET LAST TWO BITS INTO MSB AND B6.
003800  1  0A 0A        
003802  1  85 BF        	STA	FACOV
003804  1  28           	PLP			;TO GET GARBAGE OFF STACK.
003805  1  4C 0D 38     	JMP	MOVFR		;MOVE RESULT INTO FAC, THEN
003808  1               				;NORMALIZE RESULT AND RETURN.
003808  1  A2 14        DV0ERR: LDX	#ERRDV0
00380A  1  4C 4E 22     	JMP	ERROR
00380D  1               ; PAGE
00380D  1               ; SUBTTL	FLOATING POINT MOVEMENT ROUTINES.
00380D  1               	;MOVE RESULT TO FAC.
00380D  1  A5 75        MOVFR:	LDA	RESHO
00380F  1  85 B1        	STA	FACHO
003811  1               .IF	ADDPRC <> 0
003811  1  A5 76        	LDA	RESMOH
003813  1  85 B2        	STA	FACMOH
003815  1               .ENDIF
003815  1  A5 77        	LDA	RESMO
003817  1  85 B3        	STA	FACMO
003819  1  A5 78        	LDA	RESLO		;MOVE LO AND SGN.
00381B  1  85 B4        	STA	FACLO
00381D  1  4C 55 35     	JMP	NORMAL		;ALL DONE.
003820  1               
003820  1               	;MOVE MEMORY INTO FAC (UNPACKED).
003820  1  85 71 84 72  MOVFM:	STWD	INDEX1
003824  1  A0 04        	LDY	#3+ADDPRC
003826  1  B1 71        	LDADY	INDEX1
003828  1  85 B4        	STA	FACLO
00382A  1  88           	DEY
00382B  1  B1 71        	LDADY	INDEX1
00382D  1  85 B3        	STA	FACMO
00382F  1  88           	DEY
003830  1               .IF	ADDPRC <> 0
003830  1  B1 71        	LDADY	INDEX1
003832  1  85 B2        	STA	FACMOH
003834  1  88           	DEY
003835  1               .ENDIF
003835  1  B1 71        	LDADY	INDEX1
003837  1  85 B5        	STA	FACSGN
003839  1  09 80        	ORA	#$80
00383B  1  85 B1        	STA	FACHO
00383D  1  88           	DEY
00383E  1  B1 71        	LDADY	INDEX1
003840  1  85 B0        	STA	FACEXP		;LEAVE SWITCHES SET ON EXP.
003842  1  84 BF        	STY	FACOV
003844  1  60           	RTS
003845  1               
003845  1               	;MOVE NUMBER FROM FAC TO MEMORY.
003845  1  A2 AB 2C     MOV2F:	LDX	#TEMPF2
003848  1               	SKIP2
003848  1  A2 A6        MOV1F:	LDX	#TEMPF1
00384A  1  A0 00        MOVML:	LDY	#0
00384C  1  F0 04        	BEQ	MOVMF		;ALWAYS BRANCHES.
00384E  1  A6 98 A4 99  MOVVF:	LDXY	FORPNT
003852  1  20 99 38     MOVMF:	JSR	ROUND
003855  1  86 71 84 72  	STXY	INDEX1
003859  1  A0 04        	LDY	#3+ADDPRC
00385B  1  A5 B4        	LDA	FACLO
00385D  1  91 71        	STADY	INDEX
00385F  1  88           	DEY
003860  1  A5 B3        	LDA	FACMO
003862  1  91 71        	STADY	INDEX
003864  1  88           	DEY
003865  1               .IF	ADDPRC <> 0
003865  1  A5 B2        	LDA	FACMOH
003867  1  91 71        	STADY	INDEX
003869  1  88           	DEY
00386A  1               .ENDIF
00386A  1  A5 B5        	LDA	FACSGN		;INCLUDE SIGN IN HO.
00386C  1  09 7F        	ORA	#$7F
00386E  1  25 B1        	AND	FACHO
003870  1  91 71        	STADY	INDEX
003872  1  88           	DEY
003873  1  A5 B0        	LDA	FACEXP
003875  1  91 71        	STADY	INDEX
003877  1  84 BF        	STY	FACOV		;ZERO IT SINCE ROUNDED.
003879  1  60           	RTS			;[Y]=0.
00387A  1               
00387A  1               	;MOVE ARG INTO FAC.
00387A  1  A5 BD        MOVFA:	LDA	ARGSGN
00387C  1  85 B5        MOVFA1: STA	FACSGN
00387E  1  A2 05        	LDX	#4+ADDPRC
003880  1  B5 B7        MOVFAL: LDA	ARGEXP-1,X
003882  1  95 AF        	STA	FACEXP-1,X
003884  1  CA           	DEX
003885  1  D0 F9        	BNE	MOVFAL
003887  1  86 BF        	STX	FACOV
003889  1  60           	RTS
00388A  1               
00388A  1               	;MOVE FAC INTO ARG.
00388A  1  20 99 38     MOVAF:	JSR	ROUND
00388D  1  A2 06        MOVEF:	LDX	#5+ADDPRC
00388F  1  B5 AF        MOVAFL: LDA	FACEXP-1,X
003891  1  95 B7        	STA	ARGEXP-1,X
003893  1  CA           	DEX
003894  1  D0 F9        	BNE	MOVAFL
003896  1  86 BF        	STX	FACOV		;ZERO IT SINCE ROUNDED.
003898  1  60           MOVRTS: RTS
003899  1               
003899  1  A5 B0        ROUND:	LDA	FACEXP		;ZERO?
00389B  1  F0 FB        	BEQ	MOVRTS		;YES. DONE ROUNDING.
00389D  1  06 BF        	ASL	FACOV		;ROUND?
00389F  1  90 F7        	BCC	MOVRTS		;NO. MSB OFF.
0038A1  1  20 ED 35     INCRND: JSR	INCFAC		;YES, ADD ONE TO LSB(FAC).
0038A4  1  D0 F2        	BNE	MOVRTS		;NO CARRY MEANS DONE.
0038A6  1  4C B6 35     	JMP	RNDSHF		;SQUEEZ MSB IN AND RTS.
0038A9  1               				;NOTE [C]=1 SINCE INCFAC DOESNT TOUCH C.
0038A9  1               ; PAGE
0038A9  1               ; SUBTTL	SIGN, SGN, FLOAT, NEG, ABS.
0038A9  1               
0038A9  1               	;PUT SIGN OF FAC IN ACCA.
0038A9  1  A5 B0        SIGN:	LDA	FACEXP
0038AB  1  F0 09        	BEQ	SIGNRT		;IF NUMBER IS ZERO, SO IS RESULT.
0038AD  1  A5 B5        FCSIGN: LDA	FACSGN
0038AF  1  2A           FCOMPS: ROL	A
0038B0  1  A9 FF        	LDA	#$FF		;ASSUME NEGATIVE.
0038B2  1  B0 02        	BCS	SIGNRT
0038B4  1  A9 01        	LDA	#1		;GET +1.
0038B6  1  60           SIGNRT: RTS
0038B7  1               
0038B7  1               	;SGN FUNCTION.
0038B7  1  20 A9 38     SGN:	JSR	SIGN
0038BA  1               
0038BA  1               	;FLOAT THE SIGNED INTEGER IN ACCA.
0038BA  1  85 B1        FLOAT:	STA	FACHO		;PUT [ACCA] IN HIGH ORDER.
0038BC  1  A9 00        	LDA	#0
0038BE  1  85 B2        	STA	FACHO+1
0038C0  1  A2 88        	LDX	#$88		;GET THE EXPONENT.
0038C2  1               
0038C2  1               	;FLOAT THE SIGNED NUMBER IN FAC.
0038C2  1  A5 B1        FLOATS: LDA	FACHO
0038C4  1  49 FF        	EOR	#$FF
0038C6  1  2A           	ROL	A 		;GET COMP OF SIGN IN CARRY.
0038C7  1  A9 00        FLOATC: LDA	#0		;ZERO [ACCA] BUT NOT CARRY.
0038C9  1  85 B4        	STA	FACLO
0038CB  1               .IF	ADDPRC <> 0
0038CB  1  85 B3        	STA	FACMO
0038CD  1               .ENDIF
0038CD  1  86 B0        FLOATB: STX	FACEXP
0038CF  1  85 BF        	STA	FACOV
0038D1  1  85 B5        	STA	FACSGN
0038D3  1  4C 50 35     	JMP	FADFLT
0038D6  1               
0038D6  1               	;ABSOLUTE VALUE OF FAC.
0038D6  1  46 B5        ABS:	LSR	FACSGN
0038D8  1  60           	RTS
0038D9  1               
0038D9  1               ; PAGE
0038D9  1               ; SUBTTL	COMPARE TWO NUMBERS.
0038D9  1               	;A=1 IF ARG .LT. FAC.
0038D9  1               	;A=0 IF ARG=FAC.
0038D9  1               	;A=-1 IF ARG .GT. FAC.
0038D9  1  85 73        FCOMP:	STA	INDEX2
0038DB  1  84 74        FCOMPN: STY	INDEX2+1
0038DD  1  A0 00        	LDY	#0
0038DF  1  B1 73        	LDADY	INDEX2		;HAS ARGEXP.
0038E1  1  C8           	INY			;BUMP PNTR UP.
0038E2  1  AA           	TAX			;SAVE A IN X AND RESET CODES.
0038E3  1  F0 C4        	BEQ	SIGN
0038E5  1  B1 73        	LDADY	INDEX2
0038E7  1  45 B5        	EOR	FACSGN		;SIGNS THE SAME.
0038E9  1  30 C2        	BMI	FCSIGN		;SIGNS DIFFER SO RESULT IS
0038EB  1               				;SIGN OF FAC AGAIN.
0038EB  1  E4 B0        FOUTCP: CPX	FACEXP
0038ED  1  D0 21        	BNE	FCOMPC
0038EF  1  B1 73        	LDADY	INDEX2
0038F1  1  09 80        	ORA	#$80
0038F3  1  C5 B1        	CMP	FACHO
0038F5  1  D0 19        	BNE	FCOMPC
0038F7  1  C8           	INY
0038F8  1               .IF	ADDPRC <> 0
0038F8  1  B1 73        	LDADY	INDEX2
0038FA  1  C5 B2        	CMP	FACMOH
0038FC  1  D0 12        	BNE	FCOMPC
0038FE  1  C8           	INY
0038FF  1               .ENDIF
0038FF  1  B1 73        	LDADY	INDEX2
003901  1  C5 B3        	CMP	FACMO
003903  1  D0 0B        	BNE	FCOMPC
003905  1  C8           	INY
003906  1  A9 7F        	LDA	#$7F
003908  1  C5 BF        	CMP	FACOV
00390A  1  B1 73        	LDADY	INDEX2
00390C  1  E5 B4        	SBC	FACLO		;GET ZERO IF EQUAL.
00390E  1  F0 28        	BEQ	QINTRT
003910  1  A5 B5        FCOMPC: LDA	FACSGN
003912  1  90 02        	BCC	FCOMPD
003914  1  49 FF        	EOR	#$FF
003916  1  4C AF 38     FCOMPD: JMP	FCOMPS		;A PART OF SIGN SETS ACCA UP.
003919  1               
003919  1               ; PAGE
003919  1               ; SUBTTL	GREATEST INTEGER FUNCTION.
003919  1               	;QUICK GREATEST INTEGER FUNCTION.
003919  1               	;LEAVES INT(FAC) IN FACHO&MO&LO SIGNED.
003919  1               	;ASSUMES FAC .LT. 2^23 = 8388608
003919  1  A5 B0        QINT:	LDA	FACEXP
00391B  1  F0 4A        	BEQ	CLRFAC		;IF ZERO, GOT IT.
00391D  1  38           	SEC
00391E  1               ;LGB NUM CONV ERROR: Error converting 8 according to radix 8 defaulting to radix 10 - 8
00391E  1  E9 A0        	SBC	#8*ADDPRC+$98	;GET NUMBER OF PLACES TO SHIFT.
003920  1  24 B5        	BIT	FACSGN
003922  1  10 09        	BPL	QISHFT
003924  1  AA           	TAX
003925  1  A9 FF        	LDA	#$FF
003927  1  85 B7        	STA	BITS		;PUT 377 IN WHEN SHFTR SHIFTS BYTES.
003929  1  20 CB 35     	JSR	NEGFCH		;TRULY NEGATE QUANTITY IN FAC.
00392C  1  8A           	TXA
00392D  1  A2 B0        QISHFT: LDX	#FAC
00392F  1  C9 F9        	CMP	#256-7
003931  1  10 06        	BPL	QINT1		;IF NUMBER OF PLACES .GE. 7
003933  1               				;SHIFT 1 PLACE AT A TIME.
003933  1  20 17 36     	JSR	SHIFTR		;START SHIFTING BYTES, THEN BITS.
003936  1  84 B7        	STY	BITS		;ZERO BITS SINCE ADDER WANTS ZERO.
003938  1  60           QINTRT: RTS
003939  1  A8           QINT1:	TAY			;PUT COUNT IN COUNTER.
00393A  1  A5 B5        	LDA	FACSGN
00393C  1  29 80        	AND	#$80		;GET SIGN BIT.
00393E  1  46 B1        	LSR	FACHO		;SAVE FIRST SHIFTED BYTE.
003940  1  05 B1        	ORA	FACHO
003942  1  85 B1        	STA	FACHO
003944  1  20 2E 36     	JSR	ROLSHF		;SHIFT THE REST.
003947  1  84 B7        	STY	BITS		;ZERO [BITS].
003949  1  60           	RTS
00394A  1               
00394A  1               	;GREATEST INTEGER FUNCTION.
00394A  1  A5 B0        INT:	LDA	FACEXP
00394C  1               ;LGB NUM CONV ERROR: Error converting 8 according to radix 8 defaulting to radix 10 - 8
00394C  1  C9 A0        	CMP	#8*ADDPRC+$98
00394E  1  B0 20        	BCS	INTRTS		;FORGET IT.
003950  1  20 19 39     	JSR	QINT
003953  1  84 BF        	STY	FACOV		;CLR OVERFLOW BYTE.
003955  1  A5 B5        	LDA	FACSGN
003957  1  84 B5        	STY	FACSGN		;MAKE FAC LOOK POSITIVE.
003959  1  49 80        	EOR	#$80		;GET COMPLEMENT OF SIGN IN CARRY.
00395B  1  2A           	ROL	A
00395C  1               ;LGB NUM CONV ERROR: Error converting 8 according to radix 8 defaulting to radix 10 - 8
00395C  1  A9 A0        	LDA	#8*ADDPRC+$98
00395E  1  85 B0        	STA	FACEXP
003960  1  A5 B4        	LDA	FACLO
003962  1  85 0D        	STA	INTEGR
003964  1  4C 50 35     	JMP	FADFLT
003967  1  85 B1        CLRFAC: STA	FACHO		;MAKE IT REALLY ZERO.
003969  1               .IF	ADDPRC <> 0
003969  1  85 B2        	STA FACMOH
00396B  1               .ENDIF
00396B  1  85 B3        	STA	FACMO
00396D  1  85 B4        	STA	FACLO
00396F  1  A8           	TAY
003970  1  60           INTRTS: RTS
003971  1               ; PAGE
003971  1               ; SUBTTL	FLOATING POINT INPUT ROUTINE.
003971  1               	;NUMBER INPUT IS LEFT IN FAC.
003971  1               	;AT ENTRY [TXTPTR] POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
003971  1               	;THE FIRST CHARACTER IS ALSO IN ACCA. FIN PACKS THE DIGITS
003971  1               	;INTO THE FAC AS AN INTEGER AND KEEPS TRACK OF WHERE THE
003971  1               	;DECIMAL POINT IS. [DPTFLG] TELL WHETHER A DP HAS BEEN
003971  1               	;SEEN. [DECCNT] IS THE NUMBER OF DIGITS AFTER THE DP.
003971  1               	;AT THE END [DECCNT] AND THE EXPONENT ARE USED TO
003971  1               	;DETERMINE HOW MANY TIMES TO MULTIPLY OR DIVIDE BY TEN
003971  1               	;TO GET THE CORRECT NUMBER.
003971  1  A0 00        FIN:	LDY	#0		;ZERO FACSGN&SGNFLG.
003973  1  A2 0A        	LDX	#$9+ADDPRC	;ZERO EXP AND HO (AND MOH).
003975  1  94 AC        FINZLP: STY	DECCNT,X	;ZERO MO AND LO.
003977  1  CA           	DEX			;ZERO TENEXP AND EXPSGN
003978  1  10 FB        	BPL	FINZLP		;ZERO DECCNT, DPTFLG.
00397A  1  90 0F        	BCC	FINDGQ		;FLAGS STILL SET FROM CHRGET.
00397C  1  C9 2D        	CMP	#'-'		;A NEGATIVE SIGN?
00397E  1  D0 04        	BNE	QPLUS		;NO, TRY PLUS SIGN.
003980  1  86 B6        	STX	SGNFLG		;IT'S NEGATIVE. (X=377).
003982  1  F0 04        	BEQ	FINC		;ALWAYS BRANCHES.
003984  1  C9 2B        QPLUS:	CMP	#'+'		;PLUS SIGN?
003986  1  D0 05        	BNE	FIN1		;YES, SKIP IT.
003988  1  20 C2 00     FINC:	JSR	CHRGET
00398B  1  90 5B        FINDGQ: BCC	FINDIG
00398D  1  C9 2E        FIN1:	CMP	#'.'		;THE DP?
00398F  1  F0 2E        	BEQ	FINDP		;NO KIDDING.
003991  1  C9 45        	CMP	#'E'		;EXPONENT FOLLOWS.
003993  1  D0 30        	BNE	FINE		;NO.
003995  1               	;HERE TO CHECK FOR SIGN OF EXP.
003995  1  20 C2 00     	JSR	CHRGET		;YES. GET ANOTHER.
003998  1  90 17        	BCC	FNEDG1		;IT IS A DIGIT. (EASIER THAN
00399A  1               				;BACKING UP POINTER.)
00399A  1  C9 A4        	CMP	#MINUTK		;MINUS?
00399C  1  F0 0E        	BEQ	FINEC1		;NEGATE.
00399E  1  C9 2D        	CMP	#'-'		;MINUS SIGN?
0039A0  1  F0 0A        	BEQ	FINEC1
0039A2  1  C9 A3        	CMP	#PLUSTK		;PLUS?
0039A4  1  F0 08        	BEQ	FINEC
0039A6  1  C9 2B        	CMP	#'+'		;PLUS SIGN?
0039A8  1  F0 04        	BEQ	FINEC
0039AA  1  D0 07        	BNE	FINEC2
0039AC  1  66 AF        FINEC1: ROR	EXPSGN		;TURN IT ON.
0039AE  1  20 C2 00     FINEC:	JSR	CHRGET		;GET ANOTHER.
0039B1  1  90 5C        FNEDG1: BCC	FINEDG		;IT IS A DIGIT.
0039B3  1  24 AF        FINEC2: BIT	EXPSGN
0039B5  1  10 0E        	BPL	FINE
0039B7  1  A9 00        	LDA	#0
0039B9  1  38           	SEC
0039BA  1  E5 AD        	SBC	TENEXP
0039BC  1  4C C7 39     	JMP	FINE1
0039BF  1  66 AE        FINDP:	ROR	DPTFLG
0039C1  1  24 AE        	BIT	DPTFLG
0039C3  1  50 C3        	BVC	FINC
0039C5  1  A5 AD        FINE:	LDA	TENEXP
0039C7  1  38           FINE1:	SEC
0039C8  1  E5 AC        	SBC	DECCNT		;GET NUMBER OF PLACES TO SHIFT.
0039CA  1  85 AD        	STA	TENEXP
0039CC  1  F0 12        	BEQ	FINQNG		;NEGATE?
0039CE  1  10 09        	BPL	FINMUL		;POSITIVE SO MULTIPLY.
0039D0  1  20 7C 37     FINDIV: JSR	DIV10
0039D3  1  E6 AD        	INC	TENEXP		;DONE?
0039D5  1  D0 F9        	BNE	FINDIV		;NO.
0039D7  1  F0 07        	BEQ	FINQNG		;YES.
0039D9  1  20 60 37     FINMUL: JSR	MUL10
0039DC  1  C6 AD        	DEC	TENEXP		;DONE?
0039DE  1  D0 F9        	BNE	FINMUL		;NO
0039E0  1  A5 B6        FINQNG: LDA	SGNFLG
0039E2  1  30 01        	BMI	NEGXQS		;IF POSITIVE, RETURN.
0039E4  1  60           	RTS
0039E5  1  4C F7 3B     NEGXQS: JMP	NEGOP		;OTHERWISE, NEGATE AND RETURN.
0039E8  1               
0039E8  1  48           FINDIG: PHA
0039E9  1  24 AE        	BIT	DPTFLG
0039EB  1  10 02        	BPL	FINDG1
0039ED  1  E6 AC        	INC	DECCNT
0039EF  1  20 60 37     FINDG1: JSR	MUL10
0039F2  1  68           	PLA			;GET IT BACK.
0039F3  1  38           	SEC
0039F4  1  E9 30        	SBC	#'0'
0039F6  1  20 FC 39     	JSR	FINLOG		;ADD IT IN.
0039F9  1  4C 88 39     	JMP	FINC
0039FC  1               
0039FC  1  48           FINLOG: PHA
0039FD  1  20 8A 38     	JSR	MOVAF		;SAVE FAC FOR LATER.
003A00  1  68           	PLA
003A01  1  20 BA 38     	JSR	FLOAT		;FLOAT THE VALUE IN ACCA.
003A04  1  A5 BD        	LDA	ARGSGN
003A06  1  45 B5        	EOR	FACSGN
003A08  1  85 BE        	STA	ARISGN		;RESULTANT SIGN.
003A0A  1  A6 B0        	LDX	FACEXP		;SET SIGNS ON THING TO ADD.
003A0C  1  4C E8 34     	JMP	FADDT		;ADD TOGETHER AND RETURN.
003A0F  1               
003A0F  1               	;HERE PACK IN THE NEXT DIGIT OF THE EXPONENT.
003A0F  1               	;MULTIPLY THE OLD EXP BY 10 AND ADD IN THE NEXT
003A0F  1               	;DIGIT. NOTE: EXP OVERFLOW IS NOT CHECKED FOR.
003A0F  1  A5 AD        FINEDG: LDA	TENEXP		;GET EXP SO FAR.
003A11  1  C9 0A        	CMP	#$A		;WILL RESULT BE .GE. 100?
003A13  1  90 09        	BCC	MLEX10
003A15  1  A9 64        	LDA	#$64		;GET 100.
003A17  1  24 AF        	BIT	EXPSGN
003A19  1  30 11        	BMI	MLEXMI		;IF NEG EXP, NO CHK FOR OVERR.
003A1B  1  4C FC 35     	JMP	OVERR
003A1E  1  0A           MLEX10: ASL	A 		;MULT BY 2 TWICE
003A1F  1  0A           	ASL	A
003A20  1  18           	CLC			;POSSIBLE SHIFT OUT OF HIGH.
003A21  1  65 AD        	ADC	TENEXP		;LIKE MULTIPLYING BY FIVE.
003A23  1  0A           	ASL	A 		;AND NOW BY TEN.
003A24  1  18           	CLC
003A25  1  A0 00        	LDY	#0
003A27  1  71 C9        	ADCDY	TXTPTR
003A29  1  38           	SEC
003A2A  1  E9 30        	SBC	#'0'
003A2C  1  85 AD        MLEXMI: STA	TENEXP		;SAVE RESULT.
003A2E  1  4C AE 39     	JMP	FINEC
003A31  1               ; PAGE
003A31  1               ; SUBTTL	FLOATING POINT OUTPUT ROUTINE.
003A31  1               
003A31  1               .IF	ADDPRC = 0
003A31  1               NZ0999: .BYTE $91	; 99999.9499
003A31  1               .BYTE	$43
003A31  1               .BYTE	$4F
003A31  1               .BYTE	$F8
003A31  1               NZ9999: .BYTE $94	; 999999.499
003A31  1               .BYTE	$74
003A31  1               .BYTE	$23
003A31  1               .BYTE	$F7
003A31  1               NZMIL:	.BYTE $94	; 10^6.
003A31  1               .BYTE	$74
003A31  1               .BYTE	$24
003A31  1               .BYTE	0
003A31  1               .ENDIF
003A31  1               .IF	ADDPRC <> 0
003A31  1  9B           NZ0999: .BYTE $9B	; 99999999.9499
003A32  1  3E           .BYTE	$3E
003A33  1  BC           .BYTE	$BC
003A34  1  1F           .BYTE	$1F
003A35  1  FD           .BYTE	$FD
003A36  1  9E           NZ9999: .BYTE $9E	; 999999999.499
003A37  1  6E           .BYTE	$6E
003A38  1  6B           .BYTE	$6B
003A39  1  27           .BYTE	$27
003A3A  1  FD           .BYTE	$FD
003A3B  1  9E           NZMIL:	.BYTE $9E	; 10^9
003A3C  1  6E           .BYTE	$6E
003A3D  1  6B           .BYTE	$6B
003A3E  1  28           .BYTE	$28
003A3F  1  00           .BYTE	0
003A40  1               .ENDIF
003A40  1               	;ENTRY TO LINPRT.
003A40  1  A9 8D A0 21  INPRT:	LDWDI	INTXT
003A44  1  20 58 3A     	JSR	STROU2
003A47  1  A5 89        	LDA	CURLIN+1
003A49  1  A6 88        	LDX	CURLIN
003A4B  1  85 B1 86 B2  LINPRT: STWX	FACHO
003A4F  1  A2 90        	LDX	#$90		;EXPONENT OF 16.
003A51  1  38           	SEC			;NUMBER IS POSITIVE.
003A52  1  20 C7 38     	JSR	FLOATC
003A55  1  20 5B 3A     	JSR	FOUT
003A58  1  4C 9A 28     STROU2: JMP	STROUT		;PRINT AND RETURN.
003A5B  1               
003A5B  1  A0 01        FOUT:	LDY	#1
003A5D  1  A9 20        FOUTC:	LDA	#' '		;PRINT SPACE IF POSITIVE.
003A5F  1  24 B5        	BIT	FACSGN
003A61  1  10 02        	BPL	FOUT1
003A63  1  A9 2D        	LDA	#'-'
003A65  1  99 FF 00     FOUT1:	STA	FBUFFR-1,Y 	;STORE THE CHARACTER.
003A68  1  85 B5        	STA	FACSGN		;MAKE FAC POS FOR QINT.
003A6A  1  84 C0        	STY	FBUFPT		;SAVE FOR LATER.
003A6C  1  C8           	INY
003A6D  1  A9 30        	LDA	#'0'		;GET ZERO TO TYPE IF FAC=0.
003A6F  1  A6 B0        	LDX	FACEXP
003A71  1  D0 03 4C 7E  	JEQ	FOUT19
003A75  1  3B           
003A76  1  A9 00        	LDA	#0
003A78  1  E0 80        	CPX	#$80		;IS NUMBER .LT. 1.0 ?
003A7A  1  F0 02        	BEQ	FOUT37		;NO.
003A7C  1  B0 09        	BCS	FOUT7
003A7E  1  A9 3B A0 3A  FOUT37: LDWDI	NZMIL		;MULTIPLY BY 10^6.
003A82  1  20 A6 36     	JSR	FMULT
003A85  1  A9 F7        	LDA	#256-3*ADDPRC-6
003A87  1  85 AC        FOUT7:	STA	DECCNT		;SAVE COUNT OR ZERO IT.
003A89  1  A9 36 A0 3A  FOUT4:	LDWDI	NZ9999
003A8D  1  20 D9 38     	JSR	FCOMP		;IS NUMBER .GT. 999999.499 ?
003A90  1               				;OR 999999999.499?
003A90  1  F0 1E        	BEQ	BIGGES
003A92  1  10 12        	BPL	FOUT9		;YES. MAKE IT SMALLER.
003A94  1  A9 31 A0 3A  FOUT3:	LDWDI	NZ0999
003A98  1  20 D9 38     	JSR	FCOMP		;IS NUMBER .GT. 99999.9499 ?
003A9B  1               				; OR 99999999.9499?
003A9B  1  F0 02        	BEQ	FOUT38
003A9D  1  10 0E        	BPL	FOUT5		;YES. DONE MULTIPLYING.
003A9F  1  20 60 37     FOUT38: JSR	MUL10		;MAKE IT BIGGER.
003AA2  1  C6 AC        	DEC	DECCNT
003AA4  1  D0 EE        	BNE	FOUT3		;SEE IF THAT DOES IT.
003AA6  1               				;THIS ALWAYS GOES.
003AA6  1  20 7C 37     FOUT9:	JSR	DIV10		;MAKE IT SMALLER.
003AA9  1  E6 AC        	INC	DECCNT
003AAB  1  D0 DC        	BNE	FOUT4		;SEE IF THAT DOES IT.
003AAD  1               				;THIS ALWAYS GOES.
003AAD  1               
003AAD  1  20 C7 34     FOUT5:	JSR	FADDH		;ADD A HALF TO ROUND UP.
003AB0  1  20 19 39     BIGGES: JSR	QINT
003AB3  1  A2 01        	LDX	#1		;DECIMAL POINT COUNT.
003AB5  1  A5 AC        	LDA	DECCNT
003AB7  1  18           	CLC
003AB8  1  69 0A        	ADC	#3*ADDPRC+7	;SHOULD NUMBER BE PRINTED IN E NOTATION?
003ABA  1               				;IE, IS NUMBER .LT. .01 ?
003ABA  1  30 09        	BMI	FOUTPI		;YES.
003ABC  1  C9 0B        	CMP	#3*ADDPRC+$8	;IS IT .GT. 999999 (999999999)?
003ABE  1  B0 06        	BCS	FOUT6		;YES. USE E NOTATION.
003AC0  1  69 FF        	ADC	#$FF		;NUMBER OF PLACES BEFORE DECIMAL POINT.
003AC2  1  AA           	TAX			;PUT INTO ACCX.
003AC3  1  A9 02        	LDA	#2		;NO E NOTATION.
003AC5  1  38           FOUTPI: SEC
003AC6  1  E9 02        FOUT6:	SBC	#2		;EFFECTIVELY ADD 5 TO ORIG EXP.
003AC8  1  85 AD        	STA	TENEXP		;THAT IS THE EXPONENT TO PRINT.
003ACA  1  86 AC        	STX	DECCNT		;NUMBER OF DECIMAL PLACES.
003ACC  1  8A           	TXA
003ACD  1  F0 02        	BEQ	FOUT39
003ACF  1  10 13        	BPL	FOUT8		;SOME PLACES BEFORE DEC PNT.
003AD1  1  A4 C0        FOUT39: LDY	FBUFPT		;GET POINTER TO OUTPUT.
003AD3  1  A9 2E        	LDA	#'.'		;PUT IN "."
003AD5  1  C8           	INY
003AD6  1  99 FF 00     	STA	FBUFFR-1,Y
003AD9  1  8A           	TXA
003ADA  1  F0 06        	BEQ	FOUT16
003ADC  1  A9 30        	LDA	#'0'		;GET THE ENSUING ZERO.
003ADE  1  C8           	INY
003ADF  1  99 FF 00     	STA	FBUFFR-1,Y
003AE2  1  84 C0        FOUT16: STY	FBUFPT		;SAVE FOR LATER.
003AE4  1  A0 00        FOUT8:	LDY	#0
003AE6  1  A2 80        FOUTIM: LDX	#$80		;FIRST PASS THRU, ACCX HAS MSB SET.
003AE8  1  A5 B4        FOUT2:	LDA	FACLO
003AEA  1  18           	CLC
003AEB  1  79 93 3B     	ADC	FOUTBL+2+ADDPRC,Y
003AEE  1  85 B4        	STA	FACLO
003AF0  1  A5 B3        	LDA	FACMO
003AF2  1  79 92 3B     	ADC	FOUTBL+1+ADDPRC,Y
003AF5  1  85 B3        	STA	FACMO
003AF7  1               .IF	ADDPRC <> 0
003AF7  1  A5 B2        	LDA	FACMOH
003AF9  1  79 91 3B     	ADC	FOUTBL+1,Y
003AFC  1  85 B2        	STA	FACMOH
003AFE  1               .ENDIF
003AFE  1  A5 B1        	LDA	FACHO
003B00  1  79 90 3B     	ADC	FOUTBL,Y
003B03  1  85 B1        	STA	FACHO
003B05  1  E8           	INX			;IT WAS DONE YET ANOTHER TIME.
003B06  1  B0 04        	BCS	FOUT41
003B08  1  10 DE        	BPL	FOUT2
003B0A  1  30 02        	BMI	FOUT40
003B0C  1  30 DA        FOUT41: BMI	FOUT2
003B0E  1  8A           FOUT40: TXA
003B0F  1  90 04        	BCC	FOUTYP		;CAN USE ACCA AS IS.
003B11  1  49 FF        	EOR	#$FF		;FIND 11.-[A].
003B13  1  69 0A        	ADC	#$A		;C IS STILL ON TO COMPLETE NEGATION.
003B15  1               				;AND WILL ALWAYS BE ON AFTER.
003B15  1  69 2F        FOUTYP: ADC	#'0'-1		;GET A CHARACTER TO PRINT.
003B17  1  C8 C8 C8 C8  	REPEAT	3+ADDPRC,{INY}	;BUMP POINTER UP.
003B1B  1  84 96        	STY	FDECPT
003B1D  1  A4 C0        	LDY	FBUFPT
003B1F  1  C8           	INY			;POINT TO PLACE TO STORE OUTPUT.
003B20  1  AA           	TAX
003B21  1  29 7F        	AND	#$7F		;GET RID OF MSB.
003B23  1  99 FF 00     	STA	FBUFFR-1,Y
003B26  1  C6 AC        	DEC	DECCNT
003B28  1  D0 06        	BNE	STXBUF		;NOT TIME FOR DP YET.
003B2A  1  A9 2E        	LDA	#'.'
003B2C  1  C8           	INY
003B2D  1  99 FF 00     	STA	FBUFFR-1,Y 	;STORE DP.
003B30  1  84 C0        STXBUF: STY	FBUFPT		;STORE PNTR FOR LATER.
003B32  1  A4 96        	LDY	FDECPT
003B34  1  8A           FOUTCM: TXA			;COMPLEMENT ACCX
003B35  1  49 FF        	EOR	#$FF		;COMPLEMENT ACCA.
003B37  1  29 80        	AND	#$80		;SAVE ONLY MSB.
003B39  1  AA           	TAX
003B3A  1  C0 24        	CPY	#FDCEND-FOUTBL
003B3C  1               .IF	TIME <> 0
003B3C  1               	BEQ	FOULDY
003B3C  1               	CPY	#TIMEND-FOUTBL
003B3C  1               .ENDIF
003B3C  1  D0 AA        	BNE	FOUT2		;CONTINUE WITH OUTPUT.
003B3E  1  A4 C0        FOULDY: LDY	FBUFPT		;GET BACK OUTPUT PNTR.
003B40  1  B9 FF 00     FOUT11: LDA	FBUFFR-1,Y 	;REMOVE TRAILING ZEROES.
003B43  1  88           	DEY
003B44  1  C9 30        	CMP	#'0'
003B46  1  F0 F8        	BEQ	FOUT11
003B48  1  C9 2E        	CMP	#'.'
003B4A  1  F0 01        	BEQ	FOUT12		;RUN INTO DP. STOP.
003B4C  1  C8           	INY			;SOMETHING ELSE. SAVE IT.
003B4D  1  A9 2B        FOUT12: LDA	#'+'
003B4F  1  A6 AD        	LDX	TENEXP
003B51  1  F0 2E        	BEQ	FOUT17		;NO EXPONENT TO OUTPUT.
003B53  1  10 08        	BPL	FOUT14
003B55  1  A9 00        	LDA	#0
003B57  1  38           	SEC
003B58  1  E5 AD        	SBC	TENEXP
003B5A  1  AA           	TAX
003B5B  1  A9 2D        	LDA	#'-'		;EXPONENT IS NEGATIVE.
003B5D  1  99 01 01     FOUT14: STA	FBUFFR-1+2,Y 	;STORE SIGN OF EXP
003B60  1  A9 45        	LDA	#'E'
003B62  1  99 00 01     	STA	FBUFFR-1+1,Y 	;STORE THE "E" CHARACTER.
003B65  1  8A           	TXA
003B66  1  A2 2F        	LDX	#'0'-1
003B68  1  38           	SEC
003B69  1  E8           FOUT15: INX			;MOVE CLOSER TO OUTPUT VALUE.
003B6A  1  E9 0A        	SBC	#$A		;SUBTRACT 10.
003B6C  1  B0 FB        	BCS	FOUT15		;NOT NEGATIVE YET.
003B6E  1  69 3A        	ADC	#'0'+$A		;GET SECOND OUTPUT CHARACTER.
003B70  1  99 03 01     	STA	FBUFFR-1+4,Y 	;STORE HIGH DIGIT.
003B73  1  8A           	TXA
003B74  1  99 02 01     	STA	FBUFFR-1+3,Y 	;STORE	LOW DIGIT.
003B77  1  A9 00        	LDA	#0		;PUT IN TERMINATOR.
003B79  1  99 04 01 F0  	STA	FBUFFR-1+5,Y
003B7D  1  08           
003B7E  1               	BEQA	FOUT20		;RETURN. (ALWAYS BRANCHES).
003B7E  1  99 FF 00     FOUT19: STA	FBUFFR-1,Y 	;STORE THE CHARACTER.
003B81  1  A9 00        FOUT17: LDA	#0		;A TERMINATOR.
003B83  1  99 00 01     	STA	FBUFFR-1+1,Y
003B86  1  A9 00 A0 01  FOUT20: LDWDI	FBUFFR
003B8A  1  60           FPWRRT: RTS			;ALL DONE.
003B8B  1  80           FHALF:	.BYTE $80	;1/2
003B8C  1  00           .BYTE	0
003B8D  1  00           ZERO:	.BYTE 0
003B8E  1  00           .BYTE	0
003B8F  1               .IF	ADDPRC <> 0
003B8F  1  00           .BYTE	0
003B90  1               .ENDIF
003B90  1               
003B90  1               ;POWER OF TEN TABLE
003B90  1               .IF	ADDPRC = 0
003B90  1               FOUTBL: .BYTE $FE	;-100000
003B90  1               .BYTE	$79
003B90  1               .BYTE	$60
003B90  1               .BYTE	0	;10000
003B90  1               .BYTE	$27
003B90  1               .BYTE	$10
003B90  1               .BYTE	$FF	;-1000
003B90  1               .BYTE	$FC
003B90  1               .BYTE	$18
003B90  1               .BYTE	0	;100
003B90  1               .BYTE	0
003B90  1               .BYTE	$64
003B90  1               .BYTE	$FF	;-10
003B90  1               .BYTE	$FF
003B90  1               .BYTE	$F6
003B90  1               .BYTE	0	;1
003B90  1               .BYTE	0
003B90  1               .BYTE	1
003B90  1               .ENDIF
003B90  1               
003B90  1               .IF	ADDPRC <> 0
003B90  1  FA           FOUTBL: .BYTE $FA	;-100,000,000
003B91  1  0A           .BYTE	$A
003B92  1  1F           .BYTE	$1F
003B93  1  00           .BYTE	0
003B94  1  00           .BYTE	0	;10,000,000
003B95  1  98           .BYTE	$98
003B96  1  96           .BYTE	$96
003B97  1  80           .BYTE	$80
003B98  1  FF           .BYTE	$FF	;-1,000,000
003B99  1  F0           .BYTE	$F0
003B9A  1  BD           .BYTE	$BD
003B9B  1  C0           .BYTE	$C0
003B9C  1  00           .BYTE	0	;100,000
003B9D  1  01           .BYTE	1
003B9E  1  86           .BYTE	$86
003B9F  1  A0           .BYTE	$A0
003BA0  1  FF           .BYTE	$FF	;-10,000
003BA1  1  FF           .BYTE	$FF
003BA2  1  D8           .BYTE	$D8
003BA3  1  F0           .BYTE	$F0
003BA4  1  00           .BYTE	0	;1000
003BA5  1  00           .BYTE	0
003BA6  1  03           .BYTE	3
003BA7  1  E8           .BYTE	$E8
003BA8  1  FF           .BYTE	$FF	;-100
003BA9  1  FF           .BYTE	$FF
003BAA  1  FF           .BYTE	$FF
003BAB  1  9C           .BYTE	$9C
003BAC  1  00           .BYTE	0	;10
003BAD  1  00           .BYTE	0
003BAE  1  00           .BYTE	0
003BAF  1  0A           .BYTE	$A
003BB0  1  FF           .BYTE	$FF	;-1
003BB1  1  FF           .BYTE	$FF
003BB2  1  FF           .BYTE	$FF
003BB3  1  FF           .BYTE	$FF
003BB4  1               .ENDIF
003BB4  1               FDCEND:
003BB4  1               .IF	TIME <> 0
003BB4  1               .BYTE	$FF	; -2160000 FOR TIME CONVERTER.
003BB4  1               .BYTE	$DF
003BB4  1               .BYTE	$A
003BB4  1               .BYTE	$80
003BB4  1               .BYTE	0	; 216000
003BB4  1               .BYTE	3
003BB4  1               .BYTE	$4B
003BB4  1               .BYTE	$C0
003BB4  1               .BYTE	$FF	; -36000
003BB4  1               .BYTE	$FF
003BB4  1               .BYTE	$73
003BB4  1               .BYTE	$60
003BB4  1               .BYTE	0	; 3600
003BB4  1               .BYTE	0
003BB4  1               .BYTE	$E
003BB4  1               .BYTE	$10
003BB4  1               .BYTE	$FF	; -600
003BB4  1               .BYTE	$FF
003BB4  1               .BYTE	$FD
003BB4  1               .BYTE	$A8
003BB4  1               .BYTE	0	; 60
003BB4  1               .BYTE	0
003BB4  1               .BYTE	0
003BB4  1               .BYTE	$3C
003BB4  1               TIMEND:
003BB4  1               .ENDIF
003BB4  1               
003BB4  1               ; PAGE
003BB4  1               ; SUBTTL	EXPONENTIATION AND SQUARE ROOT FUNCTION.
003BB4  1               	;SQUARE ROOT FUNCTION --- SQR(A)
003BB4  1               	;USE SQR(X)=X^.5
003BB4  1  20 8A 38     SQR:	JSR	MOVAF		;MOVE FAC INTO ARG.
003BB7  1  A9 8B A0 3B  	LDWDI	FHALF
003BBB  1  20 20 38     	JSR	MOVFM		;PUT MEMORY INTO FAC.
003BBE  1               				;LAST THING FETCHED IS FACEXP. INTO ACCX.
003BBE  1               ;	JMP	FPWRT		;FALL INTO FPWRT.
003BBE  1               
003BBE  1               	;EXPONENTIATION ---  X^Y.
003BBE  1               	;N.B.  0^0=1
003BBE  1               	;FIRST CHECK IF Y=0. IF SO, THE RESULT IS 1.
003BBE  1               	;NEXT CHECK IF X=0. IF SO THE RESULT IS 0.
003BBE  1               	;THEN CHECK IF X.GT.0. IF NOT CHECK THAT Y IS AN INTEGER.
003BBE  1               	;IF SO, NEGATE X, SO THAT LOG DOESN'T GIVE FCERR.
003BBE  1               	;IF X IS NEGATIVE AND Y IS ODD, NEGATE THE RESULT
003BBE  1               	;RETURNED BY EXP.
003BBE  1               	;TO COMPUTE THE RESULT USE X^Y=EXP((Y*LOG(X)).
003BBE  1  F0 70        FPWRT:	BEQ	EXP		;IF FAC=0, JUST EXPONENTIATE THAT.
003BC0  1  A5 B8        	LDA	ARGEXP		;IS X=0?
003BC2  1  D0 03        	BNE	FPWRT1
003BC4  1  4C 77 35     	JMP	ZEROF1		;ZERO FAC.
003BC7  1  A2 9D A0 00  FPWRT1: LDXYI	TEMPF3		;SAVE FOR LATER IN A TEMP.
003BCB  1  20 52 38     	JSR	MOVMF
003BCE  1               	;Y=0 ALREADY. GOOD IN CASE NO ONE CALLS INT.
003BCE  1  A5 BD        	LDA	ARGSGN
003BD0  1  10 0F        	BPL	FPWR1		;NO PROBLEMS IF X.GT.0.
003BD2  1  20 4A 39     	JSR	INT		;INTEGERIZE THE FAC.
003BD5  1  A9 9D A0 00  	LDWDI	TEMPF3		;GET ADDR OF COMPERAND.
003BD9  1  20 D9 38     	JSR	FCOMP		;EQUAL?
003BDC  1  D0 03        	BNE	FPWR1		;LEAVE X NEG. LOG WILL BLOW HIM OUT.
003BDE  1               				;A=-1 AND Y IS IRRELEVANT.
003BDE  1  98           	TYA			;NEGATE X. MAKE POSITIVE.
003BDF  1  A4 0D        	LDY	INTEGR		;GET EVENNESS.
003BE1  1  20 7C 38     FPWR1:	JSR	MOVFA1		;ALTERNATE ENTRY POINT.
003BE4  1  98           	TYA
003BE5  1  48           	PHA			;SAVE EVENNESS FOR LATER.
003BE6  1  20 68 36     	JSR	LOG		;FIND LOG.
003BE9  1  A9 9D A0 00  	LDWDI	TEMPF3		;MULTIPLY FAC TIMES LOG(X).
003BED  1  20 A6 36     	JSR	FMULT
003BF0  1  20 30 3C     	JSR	EXP		;EXPONENTIATE THE FAC.
003BF3  1  68           	PLA
003BF4  1  4A           	LSR	A 		;IS IT EVEN?
003BF5  1  90 0A        	BCC	NEGRTS		;YES. OR X.GT.0.
003BF7  1               	;NEGATE THE NUMBER IN FAC.
003BF7  1  A5 B0        NEGOP:	LDA	FACEXP
003BF9  1  F0 06        	BEQ	NEGRTS
003BFB  1  A5 B5 49 FF  	COM	FACSGN
003BFF  1  85 B5        
003C01  1  60           NEGRTS: RTS
003C02  1               
003C02  1               ; PAGE
003C02  1               ; SUBTTL	EXPONENTIATION FUNCTION.
003C02  1               	;FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY
003C02  1               	;LOG2(E). THE RESULT IS USED TO DETERMINE IF OVERFLOW
003C02  1               	;WILL OCCUR SINCE EXP(X)=2^(X*LOG2(E)) WHERE
003C02  1               	;LOG2(E)=LOG(E) BASE 2. THEN SAVE THE INTEGER PART OF
003C02  1               	;THIS TO SCALE THE ANSWER AT THE END. SINCE
003C02  1               	;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2^INT(Y) IS EASY TO COMPUTE.
003C02  1               	;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E)) BY
003C02  1               	;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
003C02  1               	;POLYNOMIAL. THE RESULT IS THEN SCALED BY THE POWER OF 2
003C02  1               	;PREVIOUSLY SAVED.
003C02  1               
003C02  1  81           LOGEB2: .BYTE $81			;LOG(E) BASE 2.
003C03  1  38           .BYTE	$38
003C04  1  AA           .BYTE	$AA
003C05  1  3B           .BYTE	$3B
003C06  1               .IF	ADDPRC <> 0
003C06  1  29           .BYTE	$29
003C07  1               .ENDIF
003C07  1               
003C07  1               .IF	ADDPRC = 0
003C07  1               EXPCON: .BYTE 6	; degree -1.
003C07  1               .BYTE	$74	; .00021702255
003C07  1               .BYTE	$63
003C07  1               .BYTE	$90
003C07  1               .BYTE	$8C
003C07  1               .BYTE	$77	; .0012439688
003C07  1               .BYTE	$23
003C07  1               .BYTE	$C
003C07  1               .BYTE	$AB
003C07  1               .BYTE	$7A	; .0096788410
003C07  1               .BYTE	$1E
003C07  1               .BYTE	$94
003C07  1               .BYTE	0
003C07  1               .BYTE	$7C	; .055483342
003C07  1               .BYTE	$63
003C07  1               .BYTE	$42
003C07  1               .BYTE	$80
003C07  1               .BYTE	$7E	; .24022984
003C07  1               .BYTE	$75
003C07  1               .BYTE	$FE
003C07  1               .BYTE	$D0
003C07  1               .BYTE	$80	; .69314698
003C07  1               .BYTE	$31
003C07  1               .BYTE	$72
003C07  1               .BYTE	$15
003C07  1               .BYTE	$81	; 1.0
003C07  1               .BYTE	0
003C07  1               .BYTE	0
003C07  1               .BYTE	0
003C07  1               .ENDIF
003C07  1               
003C07  1               
003C07  1               .IF	ADDPRC <> 0
003C07  1  07           EXPCON: .BYTE 7	;DEGREE-1
003C08  1  71           .BYTE	$71	; .000021498763697
003C09  1  34           .BYTE	$34
003C0A  1  58           .BYTE	$58
003C0B  1  3E           .BYTE	$3E
003C0C  1  56           .BYTE	$56
003C0D  1  74           .BYTE	$74	; .00014352314036
003C0E  1  16           .BYTE	$16
003C0F  1  7E           .BYTE	$7E
003C10  1  B3           .BYTE	$B3
003C11  1  1B           .BYTE	$1B
003C12  1  77           .BYTE	$77	; .0013422634824
003C13  1  2F           .BYTE	$2F
003C14  1  EE           .BYTE	$EE
003C15  1  E3           .BYTE	$E3
003C16  1  85           .BYTE	$85
003C17  1  7A           .BYTE	$7A	; .0096140170119
003C18  1  1D           .BYTE	$1D
003C19  1  84           .BYTE	$84
003C1A  1  1C           .BYTE	$1C
003C1B  1  2A           .BYTE	$2A
003C1C  1  7C           .BYTE	$7C	; .055505126860
003C1D  1  63           .BYTE	$63
003C1E  1  59           .BYTE	$59
003C1F  1  58           .BYTE	$58
003C20  1  0A           .BYTE	$A
003C21  1  7E           .BYTE	$7E	; .24022638462
003C22  1  75           .BYTE	$75
003C23  1  FD           .BYTE	$FD
003C24  1  E7           .BYTE	$E7
003C25  1  C6           .BYTE	$C6
003C26  1  80           .BYTE	$80	; .69314718608
003C27  1  31           .BYTE	$31
003C28  1  72           .BYTE	$72
003C29  1  18           .BYTE	$18
003C2A  1  10           .BYTE	$10
003C2B  1  81           .BYTE	$81	; 1.0
003C2C  1  00           .BYTE	0
003C2D  1  00           .BYTE	0
003C2E  1  00           .BYTE	0
003C2F  1  00           .BYTE	0
003C30  1               .ENDIF
003C30  1               
003C30  1               EXP:
003C30  1  A9 02 A0 3C  	LDWDI	LOGEB2		;MULTIPLY BY LOG(E) BASE 2.
003C34  1  20 A6 36     	JSR	FMULT
003C37  1  A5 BF        	LDA	FACOV
003C39  1  69 50        	ADC	#$50
003C3B  1  90 03        	BCC	STOLD
003C3D  1  20 A1 38     	JSR	INCRND
003C40  1  85 A5        STOLD:	STA	OLDOV
003C42  1  20 8D 38     	JSR	MOVEF		;TO SAVE IN ARG WITHOUT ROUND.
003C45  1  A5 B0        	LDA	FACEXP
003C47  1  C9 88        	CMP	#$88		;IF ABS(FAC) .GE. 128, TOO BIG.
003C49  1  90 03        	BCC	EXP1
003C4B  1  20 52 37     GOMLDV: JSR	MLDVEX		;OVERFLOW OR OVERFLOW.
003C4E  1  20 4A 39     EXP1:	JSR	INT
003C51  1  A5 0D        	LDA	INTEGR	;GET LOW PART.
003C53  1  18           	CLC
003C54  1  69 81        	ADC	#$81
003C56  1  F0 F3        	BEQ	GOMLDV		;OVERFLOW OR OVERFLOW !!
003C58  1  38           	SEC
003C59  1  E9 01        	SBC	#1		;SUBTRACT 1.
003C5B  1  48           	PHA			;SAVE A WHILE.
003C5C  1  A2 05        	LDX	#4+ADDPRC	;PREP TO SWAP FAC AND ARG.
003C5E  1  B5 B8        SWAPLP: LDA	ARGEXP,X
003C60  1  B4 B0        	LDY	FACEXP,X
003C62  1  95 B0        	STA	FACEXP,X
003C64  1  94 B8        	STY	ARGEXP,X
003C66  1  CA           	DEX
003C67  1  10 F5        	BPL	SWAPLP
003C69  1  A5 A5        	LDA	OLDOV
003C6B  1  85 BF        	STA	FACOV
003C6D  1  20 D1 34     	JSR	FSUBT
003C70  1  20 F7 3B     	JSR	NEGOP		;NEGATE FAC.
003C73  1  A9 07 A0 3C  	LDWDI	EXPCON
003C77  1  20 99 3C     	JSR	POLY
003C7A  1  A9 00 85 BE  	CLR	ARISGN		;MULTIPLY BY POSITIVE 1.0.
003C7E  1  68           	PLA			;GET SCALE FACTOR.
003C7F  1  20 37 37     	JSR	MLDEXP		;MODIFY FACEXP AND CHECK FOR OVERFLOW.
003C82  1  60           	RTS			;HAS TO DO JSR DUE TO PULAS IN MULDIV.
003C83  1               
003C83  1               
003C83  1               ; PAGE
003C83  1               ; SUBTTL	POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR.
003C83  1               	;EVALUATE P(X^2)*X
003C83  1               	;POINTER TO DEGREE IS IN [Y,A].
003C83  1               	;THE CONSTANTS FOLLOW THE DEGREE.
003C83  1               	;FOR X=FAC, COMPUTE:
003C83  1               	; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
003C83  1  85 C0 84 C1  POLYX:	STWD	POLYPT		;RETAIN POLYNOMIAL POINTER FOR LATER.
003C87  1  20 48 38     	JSR	MOV1F		;SAVE FAC IN FACTMP.
003C8A  1  A9 A6        	LDA	#TEMPF1
003C8C  1  20 A6 36     	JSR	FMULT		;COMPUTE X^2.
003C8F  1  20 9D 3C     	JSR	POLY1		;COMPUTE P(X^2).
003C92  1  A9 A6 A0 00  	LDWDI	TEMPF1
003C96  1  4C A6 36     	JMP	FMULT		;MULTIPLY BY FAC AGAIN.
003C99  1               
003C99  1               	;POLYNOMIAL EVALUATOR.
003C99  1               	;POINTER TO DEGREE IS IN [Y,A].
003C99  1               	;COMPUTE:
003C99  1               	; C0+C1*X+C2*X^2+C3*X^3+C4*X^4+...+C(N-1)*X^(N-1)+C(N)*X^N.
003C99  1  85 C0 84 C1  POLY:	STWD	POLYPT
003C9D  1  20 45 38     POLY1:	JSR	MOV2F		;SAVE FAC.
003CA0  1  B1 C0        	LDADY	POLYPT
003CA2  1  85 B6        	STA	DEGREE
003CA4  1  A4 C0        	LDY	POLYPT
003CA6  1  C8           	INY
003CA7  1  98           	TYA
003CA8  1  D0 02        	BNE	POLY3
003CAA  1  E6 C1        	INC	POLYPT+1
003CAC  1  85 C0        POLY3:	STA	POLYPT
003CAE  1  A4 C1        	LDY	POLYPT+1
003CB0  1  20 A6 36     POLY2:	JSR	FMULT
003CB3  1  A5 C0 A4 C1  	LDWD	POLYPT		;GET CURRENT POINTER.
003CB7  1  18           	CLC
003CB8  1  69 05        	ADC	#4+ADDPRC
003CBA  1  90 01        	BCC	POLY4
003CBC  1  C8           	INY
003CBD  1  85 C0 84 C1  POLY4:	STWD	POLYPT
003CC1  1  20 E5 34     	JSR	FADD		;ADD IN CONSTANT.
003CC4  1  A9 AB A0 00  	LDWDI	TEMPF2		;MULTIPLY THE ORIGINAL FAC.
003CC8  1  C6 B6        	DEC	DEGREE		;DONE?
003CCA  1  D0 E4        	BNE	POLY2
003CCC  1  60           RANDRT: RTS			;YES.
003CCD  1               
003CCD  1               	;PSUEDO-RANDOM NUMBER GENERATOR.
003CCD  1               	;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED.
003CCD  1               	;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS
003CCD  1               	;STARTED USING THE ARGUMENT.
003CCD  1               	;   TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE,
003CCD  1               	;MULTIPLY THE PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT
003CCD  1               	;AND ADD IN ANOTHER RANDOM CONSTANT. THE THEN HO
003CCD  1               	;AND LO BYTES ARE SWITCHED, THE EXPONENT IS PUT WHERE
003CCD  1               	;IT WILL BE SHIFTED IN BY NORMAL, AND THE EXPONENT IN THE FAC
003CCD  1               	;IS SET TO 200 SO THE RESULT WILL BE LESS THAN 1. THIS
003CCD  1               	;IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
003CCD  1               	;THE HO AND LOW BYTES WERE SWITCHED SO THERE WILL BE A
003CCD  1               	;RANDOM CHANCE OF GETTING A NUMBER LESS THAN OR GREATER
003CCD  1               	;THAN .5 .
003CCD  1               
003CCD  1  98           RMULZC: .BYTE $98
003CCE  1  35           .BYTE	$35
003CCF  1  44           .BYTE	$44
003CD0  1  7A           .BYTE	$7A
003CD1  1  68           RADDZC: .BYTE $68
003CD2  1  28           .BYTE	$28
003CD3  1  B1           .BYTE	$B1
003CD4  1  46           .BYTE	$46
003CD5  1               
003CD5  1  20 A9 38     RND:	JSR	SIGN		;GET SIGN INTO ACCX.
003CD8  1               .IF	REALIO-3 <> 0
003CD8  1  AA           	TAX			;GET INTO ACCX, SINCE "MOVFM" USES ACCX.
003CD9  1               .ENDIF
003CD9  1  30 18        	BMI	RND1		;START NEW SEQUENCE IF NEGATIVE.
003CDB  1               .IF	REALIO-3 = 0
003CDB  1               	BNE	QSETNR
003CDB  1               		;TIMERS ARE AT 9044(L0),45(HI),48(LO),49(HI) HEX.
003CDB  1               		;FIRST TWO ARE ALWAYS FREE RUNNING.
003CDB  1               		;SECOND PAIR IS NOT. LO IS FREER THAN HI THEN.
003CDB  1               		;SO ORDER IN FAC IS 44,48,45,49.
003CDB  1               	LDA	CQHTIM
003CDB  1               	STA	FACHO
003CDB  1               	LDA	CQHTIM+4
003CDB  1               	STA	FACMOH
003CDB  1               	LDA	CQHTIM+1
003CDB  1               	STA	FACMO
003CDB  1               	LDA	CQHTIM+5
003CDB  1               	STA	FACLO
003CDB  1               	JMP	STRNEX
003CDB  1               .ENDIF
003CDB  1  A9 DA A0 00  QSETNR: LDWDI	RNDX		;GET LAST ONE INTO FAC.
003CDF  1  20 20 38     	JSR	MOVFM
003CE2  1               .IF	REALIO-3 <> 0
003CE2  1  8A           	TXA			;FAC WAS ZERO?
003CE3  1  F0 E7        	BEQ	RANDRT		;RESTORE LAST ONE.
003CE5  1               .ENDIF
003CE5  1  A9 CD A0 3C  	LDWDI	RMULZC		;MULTIPLY BY RANDOM CONSTANT.
003CE9  1  20 A6 36     	JSR	FMULT
003CEC  1  A9 D1 A0 3C  	LDWDI	RADDZC
003CF0  1  20 E5 34     	JSR	FADD		;ADD RANDOM CONSTANT.
003CF3  1  A6 B4        RND1:	LDX	FACLO
003CF5  1  A5 B1        	LDA	FACHO
003CF7  1  85 B4        	STA	FACLO
003CF9  1  86 B1        	STX	FACHO		;REVERSE HO AND LO.
003CFB  1               .IF	REALIO-3 = 0
003CFB  1               	LDX	FACMOH
003CFB  1               	LDA	FACMO
003CFB  1               	STA	FACMOH
003CFB  1               	STX	FACMO
003CFB  1               .ENDIF
003CFB  1  A9 00 85 B5  STRNEX: CLR	FACSGN		;MAKE NUMBER POSITIVE.
003CFF  1  A5 B0        	LDA	FACEXP		;PUT EXP WHERE IT WILL
003D01  1  85 BF        	STA	FACOV		;BE SHIFTED IN BY NORMAL.
003D03  1  A9 80        	LDA	#$80
003D05  1  85 B0        	STA	FACEXP		;MAKE RESULT BETWEEN 0 AND 1.
003D07  1  20 55 35     	JSR	NORMAL		;NORMALIZE.
003D0A  1  A2 DA A0 00  	LDXYI	RNDX
003D0E  1  4C 52 38     GMOVMF: JMP	MOVMF		;PUT NEW ONE INTO MEMORY.
003D11  1               
003D11  1               ; PAGE
003D11  1               ; SUBTTL	SINE, COSINE AND TANGENT FUNCTIONS.
003D11  1               .IF	KIMROM = 0
003D11  1               	;COSINE FUNCTION.
003D11  1               	;USE COS(X)=SIN(X+PI/2)
003D11  1  A9 8D A0 3D  COS:	LDWDI	PI2		;PNTR TO PI/2.
003D15  1  20 E5 34     	JSR	FADD		;ADD IT IN.
003D18  1               				;FALL INTO SIN.
003D18  1               
003D18  1               
003D18  1               	;SINE FUNCTION.
003D18  1               	;USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV.
003D18  1               	;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED
003D18  1               	;BECAUSE SIN(X+2*PI)=SIN(X). THEN THE ARGUMENT CAN BE COMPARED
003D18  1               	;WITH PI/2 BY COMPARING THE RESULT OF THE DIVISION
003D18  1               	;WITH PI/2/(2*PI)=1/4.
003D18  1               	;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS
003D18  1               	;I OR IV. AN APPROXIMATION POLYNOMIAL IS THEN USED TO
003D18  1               	;COMPUTE SIN(X).
003D18  1  20 8A 38     SIN:	JSR	MOVAF
003D1B  1  A9 92 A0 3D  	LDWDI	TWOPI		;GET PNTR TO DIVISOR.
003D1F  1  A6 BD        	LDX	ARGSGN		;GET SIGN OF RESULT.
003D21  1  20 85 37     	JSR	FDIVF
003D24  1  20 8A 38     	JSR	MOVAF		;GET RESULT INTO ARG.
003D27  1  20 4A 39     	JSR	INT		;INTEGERIZE FAC.
003D2A  1  A9 00 85 BE  	CLR	ARISGN		;ALWAYS HAVE THE SAME SIGN.
003D2E  1  20 D1 34     	JSR	FSUBT		;KEEP ONLY THE FRACTIONAL PART.
003D31  1  A9 97 A0 3D  	LDWDI	FR4		;GET PNTR TO 1/4.
003D35  1  20 CE 34     	JSR	FSUB		;COMPUTE 1/4-FAC.
003D38  1  A5 B5        	LDA	FACSGN		;SAVE SIGN FOR LATER.
003D3A  1  48           	PHA
003D3B  1  10 0D        	BPL	SIN1		;FIRST QUADRANT.
003D3D  1  20 C7 34     	JSR	FADDH		;ADD 1/2 TO FAC.
003D40  1  A5 B5        	LDA	FACSGN		;SIGN IS NEGATIVE?
003D42  1  30 09        	BMI	SIN2
003D44  1  A5 16 49 FF  	COM	TANSGN		;QUADRANTS II AND III COME HERE.
003D48  1  85 16        
003D4A  1  20 F7 3B     SIN1:	JSR	NEGOP		;IF POSITIVE, NEGATE IT.
003D4D  1  A9 97 A0 3D  SIN2:	LDWDI	FR4		;POINTER TO 1/4.
003D51  1  20 E5 34     	JSR	FADD		;ADD IT IN.
003D54  1  68           	PLA			;GET ORIGINAL QUADRANT.
003D55  1  10 03        	BPL	SIN3
003D57  1  20 F7 3B     	JSR	NEGOP		;IF NEGATIVE, NEGATE RESULT.
003D5A  1  A9 9C A0 3D  SIN3:	LDWDI	SINCON
003D5E  1  4C 83 3C     GPOLYX: JMP	POLYX		;DO APPROXIMATION POLYNOMIAL.
003D61  1               
003D61  1               
003D61  1               	;TANGENT FUNCTION.
003D61  1  20 48 38     TAN:	JSR	MOV1F		;MOVE FAC INTO TEMPORARY.
003D64  1  A9 00 85 16  	CLR	TANSGN		;REMEMBER WHETHER TO NEGATE.
003D68  1  20 18 3D     	JSR	SIN		;COMPUTE THE SIN.
003D6B  1  A2 9D A0 00  	LDXYI	TEMPF3
003D6F  1  20 0E 3D     	JSR	GMOVMF		;PUT SIGN INTO OTHER TEMP.
003D72  1  A9 A6 A0 00  	LDWDI	TEMPF1
003D76  1  20 20 38     	JSR	MOVFM		;PUT THIS MEMORY LOC INTO FAC.
003D79  1  A9 00 85 B5  	CLR	FACSGN		;START OFF POSITIVE.
003D7D  1  A5 16        	LDA	TANSGN
003D7F  1  20 89 3D     	JSR	COSC		;COMPUTE COSINE.
003D82  1  A9 9D A0 00  	LDWDI	TEMPF3		;ADDRESS OF SINE VALUE.
003D86  1  4C 8D 37     GFDIV:	JMP	FDIV		;DIVIDE SINE BY COSINE AND RETURN.
003D89  1  48           COSC:	PHA
003D8A  1  4C 4A 3D     	JMP	SIN1
003D8D  1               
003D8D  1  81           PI2:	.BYTE $81	;PI/2
003D8E  1  49           .BYTE	$49
003D8F  1  0F           .BYTE	$F
003D90  1  DA           .BYTE	$DB-ADDPRC
003D91  1               .IF	ADDPRC <> 0
003D91  1  A2           .BYTE	$A2
003D92  1               .ENDIF
003D92  1  83           TWOPI:	.BYTE $83	;2*PI.
003D93  1  49           .BYTE	$49
003D94  1  0F           .BYTE	$F
003D95  1  DA           .BYTE	$DB-ADDPRC
003D96  1               .IF	ADDPRC <> 0
003D96  1  A2           .BYTE	$A2
003D97  1               .ENDIF
003D97  1  7F           FR4:	.BYTE $7F	;1/4
003D98  1  00           .BYTE	0
003D99  1  00           .BYTE	0
003D9A  1  00           .BYTE	0
003D9B  1               .IF	ADDPRC <> 0
003D9B  1  00           .BYTE	0
003D9C  1               .ENDIF
003D9C  1               .IF	ADDPRC = 0
003D9C  1               SINCON:	.BYTE 4	;DEGREE-1.
003D9C  1               .BYTE	$86	;39.710899
003D9C  1               .BYTE	$1E
003D9C  1               .BYTE	$D7
003D9C  1               .BYTE	$FB
003D9C  1               .BYTE	$87	;-76.574956
003D9C  1               .BYTE	$99
003D9C  1               .BYTE	$26
003D9C  1               .BYTE	$65
003D9C  1               .BYTE	$87	;81.602231
003D9C  1               .BYTE	$23
003D9C  1               .BYTE	$34
003D9C  1               .BYTE	$58
003D9C  1               .BYTE	$86	;-41.341677
003D9C  1               .BYTE	$A5
003D9C  1               .BYTE	$5D
003D9C  1               .BYTE	$E1
003D9C  1               .BYTE	$83	;6.2831853
003D9C  1               .BYTE	$49
003D9C  1               .BYTE	$F
003D9C  1               .BYTE	$DB
003D9C  1               .ENDIF
003D9C  1               
003D9C  1               .IF	ADDPRC <> 0
003D9C  1  05           SINCON: .BYTE 5		;DEGREE-1.
003D9D  1  84           .BYTE	$84	; -14.381383816
003D9E  1  E6           .BYTE	$E6
003D9F  1  1A           .BYTE	$1A
003DA0  1  2D           .BYTE	$2D
003DA1  1  1B           .BYTE	$1B
003DA2  1  86           .BYTE	$86	; 42.07777095
003DA3  1  28           .BYTE	$28
003DA4  1  07           .BYTE	7
003DA5  1  FB           .BYTE	$FB
003DA6  1  F8           .BYTE	$F8
003DA7  1  87           .BYTE	$87	; -76.704133676
003DA8  1  99           .BYTE	$99
003DA9  1  68           .BYTE	$68
003DAA  1  89           .BYTE	$89
003DAB  1  01           .BYTE	1
003DAC  1  87           .BYTE	$87	; 81.605223690
003DAD  1  23           .BYTE	$23
003DAE  1  35           .BYTE	$35
003DAF  1  DF           .BYTE	$DF
003DB0  1  E1           .BYTE	$E1
003DB1  1  86           .BYTE	$86	; -41.34170209
003DB2  1  A5           .BYTE	$A5
003DB3  1  5D           .BYTE	$5D
003DB4  1  E7           .BYTE	$E7
003DB5  1  28           .BYTE	$28
003DB6  1  83           .BYTE	$83	; 6.2831853070
003DB7  1  49           .BYTE	$49
003DB8  1  0F           .BYTE	$F
003DB9  1  DA           .BYTE	$DA
003DBA  1  A2           .BYTE	$A2
003DBB  1  A1           .BYTE	$A1	; 7.2362932E7
003DBC  1  54           .BYTE	$54
003DBD  1  46           .BYTE	$46
003DBE  1  8F           .BYTE	$8F
003DBF  1  13           .BYTE	$13
003DC0  1  8F           .BYTE	$8F	; 73276.2515
003DC1  1  52           .BYTE	$52
003DC2  1  43           .BYTE	$43
003DC3  1  89           .BYTE	$89
003DC4  1  CD           .BYTE	$CD
003DC5  1               .ENDIF
003DC5  1               ; PAGE
003DC5  1               ; SUBTTL	ARCTANGENT FUNCTION.
003DC5  1               	;USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
003DC5  1               	;APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X).
003DC5  1  A5 B5        ATN:	LDA	FACSGN		;WHAT IS SIGN?
003DC7  1  48           	PHA			;(MEANWHILE SAVE FOR LATER.)
003DC8  1  10 03        	BPL	ATN1
003DCA  1  20 F7 3B     	JSR	NEGOP		;IF NEGATIVE, NEGATE FAC.
003DCD  1               				;USE ARCTAN(X)=-ARCTAN(-X) .
003DCD  1  A5 B0        ATN1:	LDA	FACEXP
003DCF  1  48           	PHA			;SAVE THIS TOO FOR LATER.
003DD0  1  C9 81        	CMP	#$81		;SEE IF FAC .GE. 1.0 .
003DD2  1  90 07        	BCC	ATN2		;IT IS LESS THAN 1.
003DD4  1  A9 3A A0 36  	LDWDI	FONE		;GET PNTR TO 1.0 .
003DD8  1  20 8D 37     	JSR	FDIV		;COMPUTE RECIPROCAL.
003DDB  1               				;USE ARCTAN(X)=PI/2-ARCTAN(1/X) .
003DDB  1  A9 F5 A0 3D  ATN2:	LDWDI	ATNCON		;PNTR TO ARCTAN CONSTANTS.
003DDF  1  20 83 3C     	JSR	POLYX
003DE2  1  68           	PLA
003DE3  1  C9 81        	CMP	#$81		;WAS ORIGINAL ARGUMENT .LT. 1 ?
003DE5  1  90 07        	BCC	ATN3		;YES.
003DE7  1  A9 8D A0 3D  	LDWDI	PI2
003DEB  1  20 CE 34     	JSR	FSUB		;SUBTRACT ARCTAGN FROM PI/2.
003DEE  1  68           ATN3:	PLA			;WAS ORIGINAL ARGUMENT POSITIVE?
003DEF  1  10 03        	BPL	ATN4		;YES.
003DF1  1  4C F7 3B     	JMP	NEGOP		;IF NEGATIVE, NEGATE RESULT.
003DF4  1  60           ATN4:	RTS			;ALL DONE.
003DF5  1               
003DF5  1               .IF	ADDPRC = 0
003DF5  1               ATNCON:	 .BYTE $8	;DEGREE-1.
003DF5  1               .BYTE	$78	;.0028498896
003DF5  1               .BYTE	$3A
003DF5  1               .BYTE	$C5
003DF5  1               .BYTE	$37
003DF5  1               .BYTE	$7B	;-.016068629
003DF5  1               .BYTE	$83
003DF5  1               .BYTE	$A2
003DF5  1               .BYTE	$5C
003DF5  1               .BYTE	$7C	;.042691519
003DF5  1               .BYTE	$2E
003DF5  1               .BYTE	$DD
003DF5  1               .BYTE	$4D
003DF5  1               .BYTE	$7D	;-.075042945
003DF5  1               .BYTE	$99
003DF5  1               .BYTE	$B0
003DF5  1               .BYTE	$1E
003DF5  1               .BYTE	$7D	;.10640934
003DF5  1               .BYTE	$59
003DF5  1               .BYTE	$ED
003DF5  1               .BYTE	$24
003DF5  1               .BYTE	$7E	;-.14203644
003DF5  1               .BYTE	$91
003DF5  1               .BYTE	$72
003DF5  1               .BYTE	0
003DF5  1               .BYTE	$7E	;.19992619
003DF5  1               .BYTE	$4C
003DF5  1               .BYTE	$B9
003DF5  1               .BYTE	$73
003DF5  1               .BYTE	$7F	;.-33333073
003DF5  1               .BYTE	$AA
003DF5  1               .BYTE	$AA
003DF5  1               .BYTE	$53
003DF5  1               .BYTE	$81	;1.0
003DF5  1               .BYTE	0
003DF5  1               .BYTE	0
003DF5  1               .BYTE	0
003DF5  1               .ENDIF
003DF5  1               
003DF5  1               .IF	ADDPRC <> 0
003DF5  1  0B           ATNCON: .BYTE $B	;DEGREE-1.
003DF6  1  76           .BYTE	$76	; -.0006847939119
003DF7  1  B3           .BYTE	$B3
003DF8  1  83           .BYTE	$83
003DF9  1  BD           .BYTE	$BD
003DFA  1  D3           .BYTE	$D3
003DFB  1  79           .BYTE	$79	; .004850942156
003DFC  1  1E           .BYTE	$1E
003DFD  1  F4           .BYTE	$F4
003DFE  1  A6           .BYTE	$A6
003DFF  1  F5           .BYTE	$F5
003E00  1  7B           .BYTE	$7B	; -.01611170184
003E01  1  83           .BYTE	$83
003E02  1  FC           .BYTE	$FC
003E03  1  B0           .BYTE	$B0
003E04  1  10           .BYTE	$10
003E05  1  7C           .BYTE	$7C	; .03420963805
003E06  1  0C           .BYTE	$C
003E07  1  1F           .BYTE	$1F
003E08  1  67           .BYTE	$67
003E09  1  CA           .BYTE	$CA
003E0A  1  7C           .BYTE	$7C	; -.05427913276
003E0B  1  DE           .BYTE	$DE
003E0C  1  53           .BYTE	$53
003E0D  1  CB           .BYTE	$CB
003E0E  1  C1           .BYTE	$C1
003E0F  1  7D           .BYTE	$7D	; .07245719654
003E10  1  14           .BYTE	$14
003E11  1  64           .BYTE	$64
003E12  1  70           .BYTE	$70
003E13  1  4C           .BYTE	$4C
003E14  1  7D           .BYTE	$7D	; -.08980239538
003E15  1  B7           .BYTE	$B7
003E16  1  EA           .BYTE	$EA
003E17  1  51           .BYTE	$51
003E18  1  7A           .BYTE	$7A
003E19  1  7D           .BYTE	$7D	; .1109324134
003E1A  1  63           .BYTE	$63
003E1B  1  30           .BYTE	$30
003E1C  1  88           .BYTE	$88
003E1D  1  7E           .BYTE	$7E
003E1E  1  7E           .BYTE	$7E	; -.1428398077
003E1F  1  92           .BYTE	$92
003E20  1  44           .BYTE	$44
003E21  1  99           .BYTE	$99
003E22  1  3A           .BYTE	$3A
003E23  1  7E           .BYTE	$7E	; .1999991205
003E24  1  4C           .BYTE	$4C
003E25  1  CC           .BYTE	$CC
003E26  1  91           .BYTE	$91
003E27  1  C7           .BYTE	$C7
003E28  1  7F           .BYTE	$7F	; -.3333333157
003E29  1  AA           .BYTE	$AA
003E2A  1  AA           .BYTE	$AA
003E2B  1  AA           .BYTE	$AA
003E2C  1  13           .BYTE	$13
003E2D  1  81           .BYTE	$81	; 1.0
003E2E  1  00           .BYTE	0
003E2F  1  00           .BYTE	0
003E30  1  00           .BYTE	0
003E31  1  00           .BYTE	0
003E32  1               .ENDIF
003E32  1               .ENDIF
003E32  1               ; PAGE
003E32  1               ; SUBTTL	SYSTEM INITIALIZATION CODE.
003E32  1               ; RADIX	10		;IN ALL NON-MATH-PACKAGE CODE.
003E32  1               ; THIS INITIALIZES THE BASIC INTERPRETER FOR THE M6502 AND SHOULD BE
003E32  1               ; LOCATED WHERE IT WILL BE WIPED OUT IN RAM IF CODE IS ALL IN RAM.
003E32  1               
003E32  1               .IF	ROMSW = 0
003E32  1               	BLOCK	1		;SO ZEROING AT TXTTAB DOESN'T PREVENT
003E32  1               .ENDIF
003E32  1               				;RESTARTING INIT
003E32  1  E6 C9        INITAT: INC	CHRGET+7	;INCREMENT THE WHOLE TXTPTR.
003E34  1  D0 02        	BNE	CHZGOT
003E36  1  E6 CA        	INC	CHRGET+8
003E38  1  AD 60 EA     CHZGOT: LDA	60000		;A LOAD WITH AN EXT ADDR.
003E3B  1  C9 3A        	CMP	#':'		;IS IT A ":"?
003E3D  1  B0 0A        	BCS	CHZRTS		;IT IS .GE. ":"
003E3F  1  C9 20        	CMP	#' '		;SKIP SPACES.
003E41  1  F0 EF        	BEQ	INITAT
003E43  1  38           	SEC
003E44  1  E9 30        	SBC	#'0'		;ALL CHARS .GT. "9" HAVE RET'D SO
003E46  1  38           	SEC
003E47  1  E9 D0        	SBC	#256-'0'		;SEE IF NUMERIC.
003E49  1               				;TURN CARRY ON IF NUMERIC.
003E49  1               				;ALSO, SETZ IF NULL.
003E49  1  60           CHZRTS: RTS			;RETURN TO CALLER.
003E4A  1               
003E4A  1  80           .BYTE	128			;LOADED OR FROM ROM.
003E4B  1  4F           .BYTE	79			;THE INITIAL RANDOM NUMBER.
003E4C  1  C7           .BYTE	199
003E4D  1  52           .BYTE	82
003E4E  1               .IF	ADDPRC <> 0
003E4E  1  58           .BYTE	88
003E4F  1               .ENDIF
003E4F  1               .IF	REALIO-3 <> 0
003E4F  1               .IF	KIMROM = 0
003E4F  1  A9 7A A0 3F  TYPAUT: LDWDI	AUTTXT
003E53  1  20 9A 28     	JSR	STROUT
003E56  1               .ENDIF
003E56  1               .ENDIF
003E56  1               INIT:
003E56  1               .IF	REALIO-3 <> 0
003E56  1  A2 FF        	LDX	#255		;MAKE IT LOOK DIRECT IN CASE OF
003E58  1  86 89        	STX	CURLIN+1	;ERROR MESSAGE.
003E5A  1               .ENDIF
003E5A  1               .IF	STKEND-511 <> 0
003E5A  1               	LDX	#STKEND-256
003E5A  1               .ENDIF
003E5A  1  9A           	TXS
003E5B  1               .IF	REALIO-3 <> 0
003E5B  1  A9 56 A0 3E  	LDWDI	INIT		;ALLOW RESTART.
003E5F  1  85 01 84 02  	STWD	START+1
003E63  1  85 04 84 05  	STWD	RDYJSR+1	;RTS HERE ON ERRORS.
003E67  1  A9 3C A0 2E  	LDWDI	AYINT
003E6B  1  85 06 84 07  	STWD	ADRAYI
003E6F  1  A9 0F A0 30  	LDWDI	GIVAYF
003E73  1  85 08 84 09  	STWD	ADRGAY
003E77  1               .ENDIF
003E77  1  A9 4C        	LDA	#76		;JMP INSTRUCTION.
003E79  1               .IF	REALIO = 0
003E79  1               	;HRLI 1,^O1000		;MAKE AN INST.	;LGB What was its role?!
003E79  1               .ENDIF
003E79  1               .IF	REALIO-3 <> 0
003E79  1  85 00        	STA	START
003E7B  1  85 03        	STA	RDYJSR
003E7D  1               .ENDIF
003E7D  1  85 A3        	STA	JMPER
003E7F  1               .IF	ROMSW <> 0
003E7F  1  85 0A        	STA	USRPOK
003E81  1  A9 C5 A0 2E  	LDWDI	FCERR
003E85  1  85 0B 84 0C  	STWD	USRPOK+1
003E89  1               .ENDIF
003E89  1  A9 48        	LDA	#LINLEN		;THESE MUST BE NON-ZERO SO CHEAD WILL
003E8B  1  85 19        	STA	LINWID		;WORK AFTER MOVING A NEW LINE IN BUF
003E8D  1               				;INTO THE PROGRAM
003E8D  1  A9 38        	LDA	#NCMPOS
003E8F  1  85 1A        	STA	NCMWID
003E91  1  A2 1C        	LDX	#RNDX+4-CHRGET
003E93  1  BD 31 3E     MOVCHG: LDA	INITAT-1,X
003E96  1  95 C1        	STA	CHRGET-1,X 	;MOVE TO RAM.
003E98  1  CA           	DEX
003E99  1  D0 F8        	BNE	MOVCHG
003E9B  1  A9 03        	LDA	#STRSIZ
003E9D  1  85 A2        	STA	FOUR6
003E9F  1  8A           	TXA			;SET CONST IN RAM.
003EA0  1  85 B7        	STA	BITS
003EA2  1               .IF	EXTIO <> 0
003EA2  1               	STA	CHANNL
003EA2  1               .ENDIF
003EA2  1  85 67        	STA	LASTPT+1
003EA4  1               .IF	NULCMD <> 0
003EA4  1  85 17        	STA	NULCNT
003EA6  1               .ENDIF
003EA6  1  48           	PHA			;PUT ZERO AT THE END OF THE STACK
003EA7  1               				;SO FNDFOR WILL STOP
003EA7  1               .IF	REALIO <> 0
003EA7  1               	STA	CNTWFL		;BE TALKATIVE.
003EA7  1               .ENDIF
003EA7  1               .IF	BUFPAG <> 0
003EA7  1               	INX			;MAKE [X]=1
003EA7  1               	STX	BUF-3		;SET PRE-BUF BYTES NON-ZERO FOR CHEAD
003EA7  1               	STX	BUF-4
003EA7  1               .ENDIF
003EA7  1               .IF	REALIO-3 <> 0
003EA7  1  20 44 28     	JSR	CRDO		;TYPE A CR.
003EAA  1               .ENDIF
003EAA  1  A2 68        	LDX	#TEMPST
003EAC  1  86 65        	STX	TEMPPT		;SET UP STRING TEMPORARIES.
003EAE  1               .IF	(REALIO|LONGI) <> 0
003EAE  1               .IF	REALIO-3 <> 0
003EAE  1  A9 9A A0 3F  	LDWDI	MEMORY
003EB2  1  20 9A 28     	JSR	STROUT
003EB5  1  20 28 29     	JSR	QINLIN		;GET A LINE OF INPUT.
003EB8  1  86 C9 84 CA  	STXY	TXTPTR		;READ THIS !
003EBC  1  20 C2 00     	JSR	CHRGET		;GET THE FIRST CHARACTER.
003EBF  1               .IF	KIMROM = 0
003EBF  1  C9 41        	CMP	#'A'		;IS IT AN "A"?
003EC1  1  F0 8C        	BEQ	TYPAUT		;YES TYPE AUTHOR'S NAME.
003EC3  1               .ENDIF
003EC3  1  A8           	TAY			;NULL INPUT?
003EC4  1  D0 25        	BNE	USEDE9		;NO.
003EC6  1               .ENDIF
003EC6  1               .IF	REALIO-3 = 0
003EC6  1               	LDY	#RAMLOC/256
003EC6  1               .ENDIF
003EC6  1               .IF	REALIO-3 <> 0
003EC6  1               .IF	ROMSW = 0
003EC6  1               	LDWDI	LASTWR		;YES GET PNTR TO LAST WORD.
003EC6  1               .ENDIF
003EC6  1               .IF	ROMSW <> 0
003EC6  1  A9 00 A0 03  	LDWDI	RAMLOC
003ECA  1               .ENDIF
003ECA  1               .ENDIF
003ECA  1               .IF	ROMSW <> 0
003ECA  1  85 7A 84 7B  	STWD	TXTTAB		;SET UP START OF PROGRAM LOCATION
003ECE  1               .ENDIF
003ECE  1  85 1B 84 1C  	STWD	LINNUM
003ED2  1               .IF	REALIO-3 = 0
003ED2  1               	TAY
003ED2  1               .ENDIF
003ED2  1               .IF	REALIO-3 <> 0
003ED2  1  A0 00        	LDY	#0
003ED4  1               .ENDIF
003ED4  1  E6 1B        LOOPMM: INC	LINNUM
003ED6  1  D0 02        	BNE	LOOPM1
003ED8  1  E6 1C        	INC	LINNUM+1
003EDA  1               .IF	REALIO-3 = 0
003EDA  1               	BMI	USEDEC
003EDA  1               .ENDIF
003EDA  1  A9 55        LOOPM1: LDA	#85		;PUT RANDOM INFO INTO MEM.
003EDC  1  91 1B        	STADY	LINNUM
003EDE  1  D1 1B        	CMPDY	LINNUM		;WAS IT SAVED?
003EE0  1  D0 15        	BNE	USEDEC		;NO. THAT IS END OF MEMORY.
003EE2  1  0A           	ASL	A 		;LOOKS LIKE IT. TRY ANOTHER.
003EE3  1  91 1B        	STADY	LINNUM
003EE5  1  D1 1B        	CMPDY	LINNUM		;WAS IT SAVED?
003EE7  1               .IF	REALIO-3 <> 0
003EE7  1  D0 0E        	BNE	USEDEC		;NO. THIS IS THE END.
003EE9  1               .ENDIF
003EE9  1               .IF	REALIO-2 <> 0
003EE9  1  F0 E9        	BEQ	LOOPMM
003EEB  1               .ENDIF
003EEB  1               .IF	REALIO-2 = 0
003EEB  1               	BNE	USEDEC
003EEB  1               	CMP	0		;SEE IF HITTING PAGE 0
003EEB  1               	BNE	LOOPMM
003EEB  1               	LDA	#76
003EEB  1               	STA	0
003EEB  1               	BNEA	USEDEC
003EEB  1               .ENDIF
003EEB  1               .IF	REALIO-3 <> 0
003EEB  1  20 C8 00     USEDE9: JSR	CHRGOT		;GET CURRENT CHARACTER.
003EEE  1  20 3D 27     	JSR	LINGET		;GET DECIMAL ARGUMENT.
003EF1  1  A8           	TAY			;MAKE SURE A TERMINATOR EXISTS.
003EF2  1  F0 03        	BEQ	USEDEC		;IT DOES.
003EF4  1  4C 0E 2C     	JMP	SNERR		;IT DOESN'T.
003EF7  1               .ENDIF
003EF7  1  A5 1B A4 1C  USEDEC: LDWD	LINNUM		;GET SIZE OF MEMORY INPUT.
003EFB  1               USEDEF:				;HIGHEST ADDRESS.
003EFB  1               .ENDIF
003EFB  1               .IF	(REALIO|LONGI) = 0
003EFB  1               	LDWDI	16190		;A STRANGE NUMBER.
003EFB  1               .ENDIF
003EFB  1  85 86 84 87  	STWD	MEMSIZ		;THIS IS THE SIZE OF MEMORY.
003EFF  1  85 82 84 83  	STWD	FRETOP		;TOP OF STRINGS TOO.
003F03  1               TTYW:
003F03  1               .IF	REALIO-3 <> 0
003F03  1               .IF	(REALIO|LONGI) <> 0
003F03  1  A9 A6 A0 3F  	LDWDI	TTYWID
003F07  1  20 9A 28     	JSR	STROUT
003F0A  1  20 28 29     	JSR	QINLIN		;GET LINE OF INPUT.
003F0D  1  86 C9 84 CA  	STXY	TXTPTR		;READ THIS !
003F11  1  20 C2 00     	JSR	CHRGET		;GET FIRST CHARACTER.
003F14  1  A8           	TAY			;TEST ACCA BUT DON'T AFFECT CARRY.
003F15  1  F0 1C        	BEQ	ASKAGN
003F17  1  20 3D 27     	JSR	LINGET		;GET ARGUMENT.
003F1A  1  A5 1C        	LDA	LINNUM+1
003F1C  1  D0 E5        	BNE	TTYW		;WIDTH MUST BE .LT. 256.
003F1E  1  A5 1B        	LDA	LINNUM
003F20  1  C9 10        	CMP	#16		;WIDTH MUST BE GREATER THAN 16.
003F22  1  90 DF        	BCC	TTYW
003F24  1  85 19        	STA	LINWID		;THAT IS THE LINE WIDTH.
003F26  1  E9 0E        MORCPS: SBC	#CLMWID		;COMPUTE POSITION BEYOND WHICH
003F28  1  B0 FC        	BCS	MORCPS		;THERE ARE NO MORE FIELDS.
003F2A  1  49 FF        	EOR	#255
003F2C  1  E9 0C        	SBC	#CLMWID-2
003F2E  1  18           	CLC
003F2F  1  65 19        	ADC	LINWID
003F31  1  85 1A        	STA	NCMWID
003F33  1               .ENDIF
003F33  1               ASKAGN:
003F33  1               .IF	ROMSW = 0
003F33  1               .IF	(REALIO|LONGI) <> 0
003F33  1               	LDWDI	FNS
003F33  1               	JSR	STROUT
003F33  1               	JSR	QINLIN
003F33  1               	STXY	TXTPTR		;READ THIS !
003F33  1               	JSR	CHRGET
003F33  1               	LDXYI	INITAT		;DEFAULT.
003F33  1               	CMP	#'Y'
003F33  1               	BEQ	HAVFNS		;SAVE ALL FUNCTIONS.
003F33  1               	CMP	#'A'
003F33  1               	BEQ	OKCHAR		;SAVE ALL BUT ATN.
003F33  1               	CMP	#'N'
003F33  1               	BNE	ASKAGN		;BAD INPUT.
003F33  1               				;SAVE NOTHING.
003F33  1               OKCHAR: LDXYI	FCERR
003F33  1               	STXY	ATNFIX		;GET RID OF ATN FUNCTION.
003F33  1               	LDXYI	ATN		;UNTIL WE KNOW THAT WE SHOULD DEL MORE.
003F33  1               	CMP	#'A'
003F33  1               	BEQ	HAVFNS		;JUST GET RID OF ATN.
003F33  1               	LDXYI	FCERR
003F33  1               	STXY	COSFIX		;GET RID OF THE REST.
003F33  1               	STXY	TANFIX
003F33  1               	STXY	SINFIX
003F33  1               	LDXYI	COS		;AND GET RID OF ALL BACK TO "COS".
003F33  1               HAVFNS:
003F33  1               .ENDIF
003F33  1               .IF	(REALIO|LONGI) = 0
003F33  1               	LDXYI	INITAT-1	;GET RID OF ALL UP TO "INITAT".
003F33  1               .ENDIF
003F33  1               .ENDIF
003F33  1               .ENDIF
003F33  1               .IF	ROMSW <> 0
003F33  1  A2 00 A0 03  	LDXYI	RAMLOC
003F37  1  86 7A 84 7B  	STXY	TXTTAB
003F3B  1               .ENDIF
003F3B  1  A0 00        	LDY	#0
003F3D  1  98           	TYA
003F3E  1  91 7A        	STADY	TXTTAB		;SET UP TEXT TABLE.
003F40  1  E6 7A        	INC	TXTTAB
003F42  1               .IF	REALIO-3 <> 0
003F42  1  D0 02        	BNE	QROOM
003F44  1  E6 7B        	INC	TXTTAB+1
003F46  1               .ENDIF
003F46  1  A5 7A A4 7B  QROOM:	LDWD	TXTTAB		;PREPARE TO USE "REASON".
003F4A  1  20 1F 22     	JSR	REASON
003F4D  1               .IF	REALIO-3 = 0
003F4D  1               	LDWDI	FREMES
003F4D  1               	JSR	STROUT
003F4D  1               .ENDIF
003F4D  1               .IF	REALIO-3 <> 0
003F4D  1  20 44 28     	JSR	CRDO
003F50  1               .ENDIF
003F50  1  A5 86        	LDA	MEMSIZ		;COMPUTE [MEMSIZ]-[VARTAB].
003F52  1  38           	SEC
003F53  1  E5 7A        	SBC	TXTTAB
003F55  1  AA           	TAX
003F56  1  A5 87        	LDA	MEMSIZ+1
003F58  1  E5 7B        	SBC	TXTTAB+1
003F5A  1  20 4B 3A     	JSR	LINPRT		;TYPE THIS VALUE.
003F5D  1  A9 B5 A0 3F  	LDWDI	WORDS		;MORE BULLSHIT.
003F61  1  20 9A 28     	JSR	STROUT
003F64  1  20 3B 24     	JSR	SCRTCH		;SET UP EVERYTHING ELSE.
003F67  1               .IF	REALIO-3 = 0
003F67  1               	JMP	READY
003F67  1               .ENDIF
003F67  1               .IF	REALIO-3 <> 0
003F67  1  A9 9A A0 28  	LDWDI	STROUT
003F6B  1  85 04 84 05  	STWD	RDYJSR+1
003F6F  1  A9 72 A0 22  	LDWDI	READY
003F73  1  85 01 84 02  	STWD	START+1
003F77  1  6C 01 00     	JMPD	START+1
003F7A  1               
003F7A  1               .IF	ROMSW = 0
003F7A  1               FNS:	DT"WANT SIN-COS-TAN-ATN"
003F7A  1               .BYTE	0
003F7A  1               .ENDIF
003F7A  1               .IF	KIMROM = 0
003F7A  1  0D 0A        AUTTXT: ACRLF
003F7C  1  0C           .BYTE	12			;ANOTHER LINE FEED.
003F7D  1  57 52 49 54  	DT"WRITTEN "
003F81  1  54 45 4E 20  
003F85  1  42 59 20 57  	DT"BY WEILAND & GATES"
003F89  1  45 49 4C 41  
003F8D  1  4E 44 20 26  
003F97  1  0D 0A        	ACRLF
003F99  1  00           .BYTE	0
003F9A  1               .ENDIF
003F9A  1  4D 45 4D 4F  MEMORY: DT"MEMORY SIZE"
003F9E  1  52 59 20 53  
003FA2  1  49 5A 45     
003FA5  1  00           .BYTE	0
003FA6  1               TTYWID:
003FA6  1               .IF	KIMROM = 0
003FA6  1  54 45 52 4D  	DT"TERMINAL "
003FAA  1  49 4E 41 4C  
003FAE  1  20           
003FAF  1               .ENDIF
003FAF  1  57 49 44 54  	DT"WIDTH"
003FB3  1  48           
003FB4  1  00           .BYTE	0
003FB5  1               .ENDIF
003FB5  1  20 42 59 54  WORDS:	DT" BYTES FREE"
003FB9  1  45 53 20 46  
003FBD  1  52 45 45     
003FC0  1               .IF	REALIO-3 <> 0
003FC0  1  0D 0A        	ACRLF
003FC2  1  0D 0A        	ACRLF
003FC4  1               .ENDIF
003FC4  1               .IF	REALIO-3 = 0
003FC4  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FC4  1               .BYTE	0
003FC4  1               FREMES:
003FC4  1               .ENDIF
003FC4  1               .IF	REALIO = 0
003FC4  1  53 49 4D 55  	DT"SIMULATED BASIC FOR THE 6502 V1.1"
003FC8  1  4C 41 54 45  
003FCC  1  44 20 42 41  
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-1 = 0
003FE5  1               	DT"KIM BASIC V1.1"
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-2 = 0
003FE5  1               	DT"OSI 6502 BASIC VERSION 1.1"
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-3 = 0
003FE5  1               	DT"### COMMODORE BASIC ###"
003FE5  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FE5  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-4 = 0
003FE5  1               	DT"APPLE BASIC V1.1"
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-5 = 0
003FE5  1               	DT"STM BASIC V1.1"
003FE5  1               .ENDIF
003FE5  1               .IF	REALIO-3 <> 0
003FE5  1  0D 0A        	ACRLF
003FE7  1  43 4F 50 59  	DT"COPYRIGHT 1978 MICROSOFT"
003FEB  1  52 49 47 48  
003FEF  1  54 20 31 39  
003FFF  1  0D 0A        	ACRLF
004001  1               .ENDIF
004001  1  00           .BYTE	0
004002  1               LASTWR:
004002  1  xx xx xx xx  	BLOCK	100		;SPACE FOR TEMP STACK.
004006  1  xx xx xx xx  
00400A  1  xx xx xx xx  
004066  1               .IF	REALIO = 0
004066  1  xx xx xx xx  TSTACK:	BLOCK	13600
00406A  1  xx xx xx xx  
00406E  1  xx xx xx xx  
007586  1               .ENDIF
007586  1               
007586  1               ;IF2,<
007586  1               ;	PURGE	A,X,Y
007586  1               ;>
007586  1               ;IFNDEF	START,<START==0>
007586  1               ;	END	$Z+START
007586  1               
007586  1               
007586  1               .IF	REALIO = 0
007586  1  AD 00 D0 18  SIMULATION_TARGET_ROUTINES
00758A  1  60 AD 00 D0  
00758E  1  C9 00 F0 F9  
007594  1               .ENDIF
007594  1               
007594  1               .OUT .SPRINTF("LGB: ROMLOC=$%04X", ROMLOC)
007594  1               .OUT .SPRINTF("LGB: INIT  =$%04X", INIT)
007594  1               
007594  1               
007594  1               
