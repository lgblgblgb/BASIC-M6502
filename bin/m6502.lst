ca65 V2.18 - Ubuntu 2.19-1
Main file   : m6502-converted.asm
Current file: m6502-converted.asm

000000r 1               ; TITLE	BASIC M6502 8K VER 1.1 BY MICRO-SOFT
000000r 1               ; SEARCH	M6502
000000r 1               ; SALL
000000r 1               ; RADIX 10			;THROUGHOUT ALL BUT MATH-PAK.
000000r 1               
000000r 1               ; (C)1976 MICRO-SOFT (the original source)
000000r 1               ; (C)2025 Gabor Lenart "LGB" - the conversion/modification/etc project of mine to port this to CA65 assembler
000000r 1               
000000r 1               .INCLUDE "macros.inc"
000000r 2               .MACRO	ORG	addr
000000r 2               	.ORG	addr
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	BLOCK	n
000000r 2               	.RES	n
000000r 2               .ENDMACRO
000000r 2               
000000r 2               
000000r 2               .DEFINE	ADR(W)	.WORD	W
000000r 2               
000000r 2               .MACRO	DT	txt
000000r 2               	.BYTE	txt
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	REPEAT	n,what
000000r 2               	.REPEAT	n
000000r 2               		what
000000r 2               	.ENDREPEAT
000000r 2               .ENDMACRO
000000r 2               
000000r 2               
000000r 2               ; Guessing: EXP emits a byte, however it was removed to EXPOP not to collide with EXP as a label ...
000000r 2               .MACRO	EXPOP	n
000000r 2               	.BYTE	n
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO  LDADY	addr
000000r 2               	LDA	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO  STADY	addr
000000r 2               	STA	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	SBCDY addr
000000r 2               	SBC	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	CMPDY	addr
000000r 2               	CMP	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	ADCDY	addr
000000r 2               	ADC	(addr),Y
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	JMPD	addr
000000r 2               	JMP	(addr)
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ; ---- Only for the simulation target ---
000000r 2               
000000r 2               IO_START_ADDR = $D000
000000r 2               
000000r 2               .MACRO	SIM_INSIM
000000r 2               	LDA	IO_START_ADDR + 0
000000r 2               	CLC
000000r 2               .ENDMACRO
000000r 2               
000000r 2               .MACRO	SIM_OUTSIM
000000r 2               	STA	IO_START_ADDR + 0
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ; Was missing from the source: CZGETL = SIM_CZGETL_ADDR if REALIO = 0 (simulation)
000000r 2               ; That was $FFE4 for COMMODORE target, meaning KERNAL routine "GET".
000000r 2               ; No idea about the difference from "INSIM" ...
000000r 2               ; However, this is a label, so a routine should be put somewhere, and RTS from it?
000000r 2               SIM_CZGETL_ADDR = IO_START_ADDR + $100
000000r 2               
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; $Z::				;STARTING POINT FOR M6502 SIMULATOR
000000r 1               	ORG	0		;START OFF AT LOCATION ZERO.
000000  1               ; SUBTTL	SWITCHES,MACROS.
000000  1               
000000  1               REALIO=0			;5=STM
000000  1               				;4=APPLE.
000000  1               				;3=COMMODORE.
000000  1               				;2=OSI
000000  1               				;1=MOS TECH,KIM
000000  1               				;0=PDP-10 SIMULATING 6502
000000  1               INTPRC .SET 1			;INTEGER ARRAYS.
000000  1               ADDPRC .SET 1			;FOR ADDITIONAL PRECISION.
000000  1               LNGERR .SET 0			;LONG ERROR MESSAGES.
000000  1               TIME .SET 	0			;CAPABILITY TO SET AND READ A CLK.
000000  1               EXTIO .SET  0			;EXTERNAL I/O.
000000  1               DISKO .SET  0			;SAVE AND LOAD COMMANDS
000000  1               NULCMD .SET 1			;FOR THE "NULL" COMMAND
000000  1               GETCMD .SET 1
000000  1               RORSW .SET 1
000000  1               ROMSW .SET 1			;TELLS IF THIS IS ON ROM.
000000  1               CLMWID .SET 14
000000  1               LONGI .SET 1			;LONG INITIALIZATION SWITCH.
000000  1               STKEND .SET 511
000000  1               BUFPAG .SET 0
000000  1               LINLEN .SET 72			;TERMINAL LINE LENGTH.
000000  1               BUFLEN .SET 72			;INPUT BUFFER SIZE.
000000  1               ROMLOC .SET  $2000			;ADDRESS OF START OF PURE SEGMENT.
000000  1               KIMROM .SET 1
000000  1               .IF	ROMSW = 0
000000  1               	KIMROM .SET 0
000000  1               .ENDIF
000000  1               .IF	REALIO-1 <> 0
000000  1               	KIMROM .SET 0
000000  1               .ENDIF
000000  1               .IF	ROMSW <> 0
000000  1               	RAMLOC .SET  $4000		;USED ONLY IF ROMSW=1
000000  1               .IF	REALIO = 0
000000  1               	ROMLOC .SET  $2000		;START AT 8K.
000000  1               	RAMLOC .SET $300
000000  1               .ENDIF
000000  1               .ENDIF
000000  1               .IF	REALIO-3 = 0
000000  1               	DISKO .SET 1
000000  1               	RAMLOC .SET $400
000000  1               	ROMLOC .SET $C000
000000  1               	NULCMD .SET 0
000000  1               	GETCMD .SET 1
000000  1               	linlen .SET 40
000000  1               	BUFLEN .SET 81
000000  1               	CQOPEN=$FFC0
000000  1               	CQCLOS=$FFC3
000000  1               	CQOIN= $FFC6		;OPEN CHANNEL FOR INPUT
000000  1               	CQOOUT=$FFC9		;FILL FOR COMMO.
000000  1               	CQCCHN=$FFCC
000000  1               	CQINCH=$FFCF		;INCHR'S CALL TO GET A CHARACTER
000000  1               	OUTCH= $FFD2
000000  1               	CQLOAD=$FFD5
000000  1               	CQSAVE=$FFD8
000000  1               	CQVERF=$FFDB
000000  1               	CQSYS= $FFDE
000000  1               	ISCNTC=$FFE1
000000  1               	CZGETL=$FFE4		;CALL POINT FOR "GET"
000000  1               	CQCALL=$FFE7		;CLOSE ALL CHANNELS
000000  1               	CQTIMR=$8D
000000  1               	BUFPAG .SET 2
000000  1               	BUF .SET 256*BUFPAG
000000  1               	STKEND .SET 507
000000  1               	CQSTAT=$96
000000  1               	CQHTIM=$E844
000000  1               	EXTIO .SET 1
000000  1               	TIME .SET 1
000000  1               	GETCMD .SET 1
000000  1               	CLMWID .SET 10
000000  1               	PI=255				;VALUE OF PI CHARACTER FOR COMMODORE.
000000  1               	ROMSW .SET 1
000000  1               	RORSW .SET 1
000000  1               	TRMPOS=$C6
000000  1               .ENDIF
000000  1               .IF	REALIO-1 = 0
000000  1               	GETCMD .SET 1
000000  1               	DISKO .SET 1
000000  1               	OUTCH=$1EA0			;1EA0
000000  1               	ROMLOC .SET $2000
000000  1               	RORSW .SET 0
000000  1               	CZGETL=$1E5A
000000  1               .ENDIF
000000  1               .IF	REALIO-2 = 0
000000  1               	RORSW .SET 0
000000  1               	RAMLOC .SET $200
000000  1               .IF	ROMSW <> 0
000000  1               	RORSW .SET 0
000000  1               	RAMLOC .SET $8000
000000  1               .ENDIF
000000  1               	OUTCH .SET $FE0B
000000  1               .ENDIF
000000  1               .IF	REALIO-4 = 0
000000  1               	RORSW .SET 1
000000  1               	NULCMD .SET 0
000000  1               	GETCMD .SET 1
000000  1               	CQINLN .SET $FD67
000000  1               	CQPRMP .SET $33
000000  1               	CQINCH .SET $FD0C
000000  1               	CQCOUT .SET $FECD
000000  1               	CQCSIN .SET $FEFD
000000  1               	BUFPAG .SET 2
000000  1               	BUF=BUFPAG*256
000000  1               	ROMLOC .SET $800
000000  1               	RAMLOC .SET $2A00			;PAGE 2A
000000  1               	OUTCH=$FDED
000000  1               	CZGETL=$FD0C
000000  1               	LINLEN .SET 40
000000  1               	BUFLEN .SET 240
000000  1               	RORSW .SET 1
000000  1               	STKEND .SET 507
000000  1               .ENDIF
000000  1               .IF	RORSW = 0
000000  1               .OUT	"LGB: Software ROR emulation is ignored."
000000  1               .MACRO	ROR_	WD	;LGB was ROR before on old CPUs do not have bug-free ROR. On modern assemblers, we cannot define a macro with an existing opcode name though.
000000  1               	LDA	#0
000000  1               	BCC	*+4
000000  1               	LDA	#$80
000000  1               	LSR	WD
000000  1               	ORA	WD
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .ENDIF
000000  1               .MACRO	ACRLF
000000  1               .BYTE	13
000000  1               .BYTE	10
000000  1               .ENDMACRO
000000  1               .MACRO	SYNCHK	Q
000000  1               	LDA	#Q
000000  1               	JSR	SYNCHR
000000  1               .ENDMACRO
000000  1               ; LGB: begin
000000  1               ;DEFINE	DT(Q),<
000000  1               ;IRPC	Q,<IFDIF <Q><">,<EXP "Q">>  >	;
000000  1               .IF	REALIO = 0
000000  1               	;CZGETL=^O177744
000000  1               	CZGETL	= SIM_CZGETL_ADDR
000000  1               .ENDIF
000000  1               ; LGB: end
000000  1               .MACRO	LDWD	WD
000000  1               	LDA	WD
000000  1               	LDY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDWDI	WD
000000  1               	LDA	#.LOBYTE(WD)
000000  1               	LDY	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	LDWX	WD
000000  1               	LDA	WD
000000  1               	LDX	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDWXI	WD
000000  1               	LDA	#.LOBYTE(WD)
000000  1               	LDX	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	LDXY	WD
000000  1               	LDX	WD
000000  1               	LDY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	LDXYI	WD
000000  1               	LDX	#.LOBYTE(WD)
000000  1               	LDY	#.HIBYTE(WD)
000000  1               .ENDMACRO
000000  1               .MACRO	STWD	WD
000000  1               	STA	WD
000000  1               	STY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	STWX	WD
000000  1               	STA	WD
000000  1               	STX	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	STXY	WD
000000  1               	STX	WD
000000  1               	STY	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	CLR	WD
000000  1               	LDA	#0
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .MACRO	COM	WD
000000  1               	LDA	WD
000000  1               	EOR	#$FF
000000  1               	STA	WD
000000  1               .ENDMACRO
000000  1               .MACRO	PULWD	WD
000000  1               	PLA
000000  1               	STA	WD
000000  1               	PLA
000000  1               	STA	WD+1
000000  1               .ENDMACRO
000000  1               .MACRO	PSHWD	WD
000000  1               	LDA	WD+1
000000  1               	PHA
000000  1               	LDA	WD
000000  1               	PHA
000000  1               .ENDMACRO
000000  1               .MACRO	JEQ	WD
000000  1               	BNE	*+5
000000  1               	JMP	WD
000000  1               .ENDMACRO
000000  1               .MACRO	JNE	WD
000000  1               	BEQ	*+5
000000  1               	JMP	WD
000000  1               .ENDMACRO
000000  1               .DEFINE	BCCA	BCC			;BRANCHES THAT ALWAYS BRANCH
000000  1               .DEFINE	BCSA	BCS			;THESE ARE USED ON THE 6502 BECAUSE
000000  1               .DEFINE	BEQA	BEQ			;THERE IS NO UNCONDITIONAL BRANCH
000000  1               .DEFINE	BNEA	BNE
000000  1               .DEFINE	BMIA	BMI
000000  1               .DEFINE	BPLA	BPL
000000  1               .DEFINE	BVCA	BVC
000000  1               .DEFINE	BVSA	BVS
000000  1               .MACRO	INCW	R
000000  1               	INC	R
000000  1               	BNE	:+
000000  1               	INC	R+1
000000  1               	:
000000  1               .ENDMACRO
000000  1               .DEFINE	SKIP1	.BYTE $24		;BIT ZERO PAGE TRICK.
000000  1               .DEFINE	SKIP2	.BYTE $2C		;BIT ABS TRICK.
000000  1               .IF	REALIO = 0
000000  1               	.OUT	"SIMULATE"
000000  1               .ENDIF
000000  1               .IF	REALIO-1 = 0
000000  1               	.OUT	"KIM"
000000  1               .ENDIF
000000  1               .IF	REALIO-2 = 0
000000  1               	.OUT	"OSI"
000000  1               .ENDIF
000000  1               .IF	REALIO-3 = 0
000000  1               	.OUT	"COMMODORE"
000000  1               .ENDIF
000000  1               .IF	REALIO-4 = 0
000000  1               	.OUT	"APPLE"
000000  1               .ENDIF
000000  1               .IF	REALIO-5 = 0
000000  1               	.OUT	"STM"
000000  1               .ENDIF
000000  1               .IF	ADDPRC <> 0
000000  1               	.OUT	"ADDITIONAL PRECISION"
000000  1               .ENDIF
000000  1               .IF	INTPRC <> 0
000000  1               	.OUT	"INTEGER ARRAYS"
000000  1               .ENDIF
000000  1               .IF	LNGERR <> 0
000000  1               	.OUT	"LONG ERRORS"
000000  1               .ENDIF
000000  1               .IF	DISKO <> 0
000000  1               	.OUT	"SAVE AND LOAD"
000000  1               .ENDIF
000000  1               .IF	ROMSW = 0
000000  1               	.OUT	"RAM"
000000  1               .ENDIF
000000  1               .IF	ROMSW <> 0
000000  1               	.OUT	"ROM"
000000  1               .ENDIF
000000  1               .IF	RORSW = 0
000000  1               	.OUT	"NO ROR"
000000  1               .ENDIF
000000  1               .IF	RORSW <> 0
000000  1               	.OUT	"ROR ASSUMED"
000000  1               .ENDIF
000000  1               ; PAGE
000000  1               ; SUBTTL	INTRODUCTION AND COMPILATION PARAMETERS.
000000  1               
000000  1               ;
000000  1               ; --------- ---- -- ---------
000000  1               ; COPYRIGHT 1976 BY MICROSOFT
000000  1               ; --------- ---- -- ---------
000000  1               ; 7/27/78 FIXED BUG WHERE FOR VARIABLE AT BYTE FF MATCHED RETURN SEARCHING
000000  1               ; 	FOR GOSUB ENTRY ON STACK IN FNDFOR CALL BY CHANGING STA FORPNT
000000  1               ; 	TO STA FORPNT+1. THIS IS A SERIOUS BUG IN ALL VERSIONS.
000000  1               ; 7/27/78 FIXED BUG AT NEWSTT UNDER IFN BUFPAG WHEN CHECK OF CURLIN
000000  1               ; 	WAS DONE BEFORE CURLIN SET UP SO INPUT RETRIES OF FIRST STATEMENT
000000  1               ; 	WAS GIVING SYNTAX ERROR INSTEAD OF REDO FROM START (CODE WAS 12/1/77 FIX)
000000  1               ; 7/1/78	SAVED A FEW BYTES IN INIT FOR COMMODORE (14)
000000  1               ; 7/1/78 FIXED BUG WHERE REPLACING A LINE OVERFLOWING MEMORY LEFT LINKS
000000  1               ; 	IN A BAD STATE. (CODE AT NODEL AND FINI) BUG#4
000000  1               ; 7/1/78 FIXED BUG WHERE GARBAGE COLLECTION NEVER(!) COLLECTS TEMPS
000000  1               ; 	(STY GRBPNT  AT FNDVAR, LDA GRBPNT ORA GRBPNT+1 AT GRBPAS)
000000  1               ; 	THIS WAS COMMODORE BUG #2
000000  1               ; 7/1/78 FIXED BUG WHERE DELETE/INSERT OF LINE COULD CAUSE A GARBAGE COLLECTION WITH BAD VARTAB IF OUT OF MEMORY
000000  1               ; 	 (LDWD MEMSIZ STWD FRETOP=JSR RUNC CLC ALSO AT NODEL)
000000  1               ; 3/9/78 EDIT TO FIX COMMO TRMPOS AND CHANGE LEFT$ AND RIGHT$ TO ALLOW A SECOND ARGUMENT OF 0 AND RETURN A NULL STRING
000000  1               ; 2/25/78 FIXED BUG THAT INPFLG WAS SET WRONG WHEN BUFPAG.NE.0
000000  1               ; 	INCREASED NUMLEV FROM 19 TO 23
000000  1               ; 2/11/78 DISALLOWED SPACES IN RESERVED WORDS. PUT IN SPECIAL CHECK FOR "GO TO"
000000  1               ; 2/11/78 FIXED BUG WHERE ROUNDING OF THE FAC BEFORE PUSHING COULD CAUSE A STRING POINTER
000000  1               ; 	IN THE FAC TO BE INCREMENTED
000000  1               ; 1/24/78 fixed problem where user defined function undefined check fix was smashing error number in [x]
000000  1               ; 12/1/77 FIXED PROBLEM WHERE PEEK WAS SMASHING (POKER) CAUSING POKE OF PEEK TO FAIL
000000  1               ; 12/1/77 FIXED PROBLEM WHERE PROBLEM WITH VARTXT=LINNUM=BUF-2 CAUSING BUF-1 COMMA TO DISAPPEAR
000000  1               ; 12/1/77 FIXED BUFPAG.NE.0 PROBLEM AT NEWSTT AND STOP : CODE WAS STILL
000000  1               ; 	ASSUMING TXTPTR+1.EQ.0 IFF STATEMENT WAS DIRECT
000000  1               
000000  1               NUMLEV .SET 23			;NUMBER OF STACK LEVELS RESERVED
000000  1               				;BY AN EXPLICIT CALL TO "GETSTK".
000000  1               STRSIZ .SET 3			;# OF LOCS PER STRING DESCRIPTOR.
000000  1               NUMTMP .SET 3			;NUMBER OF STRING TEMPORARIES.
000000  1               CONTW .SET 15			;CHARACTER TO SUPPRESS OUTPUT.
000000  1               
000000  1               ; PAGE
000000  1               ; SUBTTL	SOME EXPLANATION.
000000  1               
000000  1               ;
000000  1               ; M6502 BASIC CONFIGURES BASIC AS FOLLOWS
000000  1               ;
000000  1               ; LOW LOCATIONS
000000  1               ; 	PAGE	ZERO
000000  1               ;
000000  1               ; 		STARTUP:
000000  1               ; 		INITIALLY A JMP TO INITIALIZATION CODE BUT
000000  1               ; 		CHANGED TO A JMP TO "READY".
000000  1               ; 		RESTARTING THE MACHINE AT LOC 0 DURING PROGRAM
000000  1               ; 		EXECUTION CAN LEAVE THINGS MESSED UP.
000000  1               ;
000000  1               ; 		LOC OF FAC TO INTEGER AND INTEGER TO FAC
000000  1               ; 		ROUTINES.
000000  1               ;
000000  1               ; 		"DIRECT" MEMORY:
000000  1               ; 		THESE ARE THE MOST COMMONLY USED LOCATIONS.
000000  1               ; 		THEY HOLD BOOKKEEPING INFO AND ALL OTHER
000000  1               ; 		FREQUENTLY USED INFORMATION.
000000  1               ; 		ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
000000  1               ; 		THE FLOATING ACCUMULATOR, AND ANYTHING ELSE THAT
000000  1               ; 		IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
000000  1               ; 		IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
000000  1               ; 		IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
000000  1               ; 		IS OFTEN DEPENDED UPON.
000000  1               ;
000000  1               ; 		STILL IN RAM WE HAVE THE BEGINNING OF THE "CHRGET"
000000  1               ; 		SUBROUTINE. IT IS HERE SO [TXTPTR] CAN BE THE
000000  1               ; 		EXTENDED ADDRESS OF A LOAD INSTRUCTION.
000000  1               ; 		THIS SAVES HAVING TO BOTHER ANY REGISTERS.
000000  1               ;
000000  1               ; 	PAGE	ONE
000000  1               ; 		THE STACK.
000000  1               ;
000000  1               ; 	STORAGE PAGE TWO AND ON
000000  1               ; 		IN RAM VERSIONS THESE DATA STRUCTURES COME AT THE
000000  1               ; 		END OF BASIC. IN ROM VERSON THEY ARE AT RAMLOC WHICH
000000  1               ; 		CAN EITHER BE ABOVE OR BELOW ROMLOC, WHICH IS WHERE
000000  1               ; 		BASIC ITSELF RESIDES.
000000  1               ;
000000  1               ; 				A ZERO.
000000  1               ; 		[TXTTAB]	POINTER TO NEXT LINE'S POINTER.
000000  1               ; 				LINE # OF THIS LINE (2 BYTES).
000000  1               ; 				CHARACTERS ON THIS LINE.
000000  1               ; 				ZERO.
000000  1               ; 				POINTER AT NEXT LINE'S POINTER
000000  1               ; 					(POINTED TO BY THE ABOVE POINTER).
000000  1               ; 				... REPEATS ...
000000  1               ; 		LAST LINE:	POINTER AT ZERO POINTER.
000000  1               ; 				LINE # OF THIS LINE.
000000  1               ; 				CHARACTERS ON THIS LINE.
000000  1               ; 				ZERO.
000000  1               ; 				DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER).
000000  1               ; 		[VARTAB]	SIMPLE VARIABLES. 6 BYTES PER VALUE.
000000  1               ; 				2 BYTES GIVE THE NAME, 4 BYTES THE VALUE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[ARYTAB]	ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
000000  1               ; 				LENGTH, NUMBER OF DIMENSIONS , EXTENT OF
000000  1               ; 				EACH DIMENSION (2BYTES/), VALUES
000000  1               ; 				... REPEATS ...
000000  1               ; 		[STREND]	FREE SPACE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[FRETOP]	STRING SPACE IN USE.
000000  1               ; 				... REPEATS ...
000000  1               ; 		[MEMSIZ]	HIGHEST MACHINE LOCATION.
000000  1               ; 				UNUSED EXCEPT BY THE VAL FUNCTION.
000000  1               ;
000000  1               ; 		ROM -- CONSTANTS AND CODE.
000000  1               ;
000000  1               ; 	FUNCTION DISPATCH ADDRESSES (AT ROMLOC)
000000  1               ; 		"FUNDSP" CONTAINS THE ADDRESSES OF THE
000000  1               ; 		FUNCTION ROUTINES IN THE ORDER OF THE
000000  1               ; 		FUNCTION NAMES IN THE CRUNCH LIST.
000000  1               ; 		THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
000000  1               ; 		ARE AT THE END. SEE THE EXPLANATION AT "ISFUN".
000000  1               ;
000000  1               ; 	THE OPERATOR LIST
000000  1               ; 		THE "OPTAB" LIST CONTAINS AN OPERATOR'S PRECEDENCE
000000  1               ; 		FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
000000  1               ; 		THE OPERATION. THE INDEX INTO THE
000000  1               ; 		OPERATOR LIST IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
000000  1               ; 		OF THE LOWEST NUMBERED OPERATOR. THE ORDER
000000  1               ; 		OF OPERATORS IN THE CRUNCH LIST AND IN "OPTAB" IS IDENTICAL.
000000  1               ; 		THE PRECEDENCES ARE ARBITRARY EXCEPT FOR THEIR
000000  1               ; 		COMPARATIVE SIZES. NOTE THAT THE PRECEDENCE FOR
000000  1               ; 		UNARY OPERATORS SUCH AS "NOT" AND NEGATION ARE
000000  1               ; 		SETUP SPECIALLY WITHOUT USING THE LIST.
000000  1               ;
000000  1               ; 	THE RESERVED WORD OR CRUNCH LIST
000000  1               ; 		WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
000000  1               ; 		IT IS STORED IN "BUF". AS SOON AS THE WHOLE LINE
000000  1               ; 		HAS BEEN TYPED IN ("INLIN" RETURNS) "CRUNCH" IS
000000  1               ; 		CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
000000  1               ; 		CRUNCHED VALUES. THIS REDUCES THE SIZE OF THE
000000  1               ; 		PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
000000  1               ; 		LIST DISPATCHES TO PERFORM FUNCTIONS, STATEMENTS,
000000  1               ; 		AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
000000  1               ; 		NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
000000  1               ; 		WHEN A MATCH IS FOUND BETWEEN A STRING
000000  1               ; 		OF CHARACTERS AND A WORD IN THE CRUNCH LIST
000000  1               ; 		THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
000000  1               ; 		THE INPUT LINE AND A RESERVED WORD TOKEN IS PUT
000000  1               ; 		IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
000000  1               ; 		TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
000000  1               ; 		IN THE CRUNCH LIST.
000000  1               ;
000000  1               ; 	STATEMENT DISPATCH ADDRESSES
000000  1               ; 		WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
000000  1               ; 		CHARACTER OF THE STATEMENT IS EXAMINED
000000  1               ; 		TO SEE IF IT IS LESS THAN THE RESERVED
000000  1               ; 		WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
000000  1               ; 		IF SO, THE "LET" CODE IS CALLED TO
000000  1               ; 		TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
000000  1               ; 		OTHERWISE A CHECK IS MADE TO MAKE SURE THE
000000  1               ; 		RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
000000  1               ; 		STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
000000  1               ; 		TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
000000  1               ; 		DISPATCH LIST) USING THE RESERVED WORD
000000  1               ; 		NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
000000  1               ; 		THE LIST.
000000  1               ;
000000  1               ; 	ERROR MESSAGES
000000  1               ; 		WHEN AN ERROR CONDITION IS DETECTED,
000000  1               ; 		[ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
000000  1               ; 		MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
000000  1               ; 		TO "ERROR". THE STACK WILL BE RESET AND ALL
000000  1               ; 		PROGRAM CONTEXT WILL BE LOST. VARIABLES
000000  1               ; 		VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
000000  1               ; 		ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
000000  1               ; 		THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
000000  1               ; 		INDEX INTO "ERRTAB" WHICH GIVES THE TWO
000000  1               ; 		CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
000000  1               ; 		USER'S TERMINAL.
000000  1               ;
000000  1               ;
000000  1               ; 	TEXTUAL MESSAGES
000000  1               ; 		CONSTANT MESSAGES ARE STORED HERE. UNLESS
000000  1               ; 		THE CODE TO CHECK IF A STRING MUST BE COPIED
000000  1               ; 		IS CHANGED THESE STRINGS MUST BE STORED ABOVE
000000  1               ; 		PAGE ZERO, OR ELSE THEY WILL BE COPIED BEFORE
000000  1               ; 		THEY ARE PRINTED.
000000  1               ;
000000  1               ; 	FNDFOR
000000  1               ; 		MOST SMALL ROUTINES ARE FAIRLY SIMPLE
000000  1               ; 		AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
000000  1               ; 		USED FOR FINDING "FOR" ENTRIES ON
000000  1               ; 		THE STACK. WHENEVER A "FOR" IS EXECUTED, A
000000  1               ; 		16-BYTE ENTRY IS PUSHED ONTO THE STACK.
000000  1               ; 		BEFORE THIS IS DONE, HOWEVER, A CHECK
000000  1               ; 		MUST BE MADE TO SEE IF THERE
000000  1               ; 		ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
000000  1               ; 		FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
000000  1               ; 		AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
000000  1               ; 		ARE ELIMINATED FROM THE STACK. THIS IS SO A
000000  1               ; 		PROGRAM THAT JUMPS OUT OF THE MIDDLE
000000  1               ; 		OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
000000  1               ; 		AND AGAIN WON'T USE UP 18 BYTES OF STACK
000000  1               ; 		SPACE EVERY TIME. THE "NEXT" CODE ALSO
000000  1               ; 		CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
000000  1               ; 		THE LOOP VARIABLE IN
000000  1               ; 		THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
000000  1               ; 		THE STACK IS RESET. IF NO MATCH IS FOUND A
000000  1               ; 		"NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
000000  1               ; 		ALSO PUTS A 5-BYTE ENTRY ON STACK.
000000  1               ; 		WHEN A RETURN IS EXECUTED "FNDFOR" IS
000000  1               ; 		CALLED WITH A VARIABLE POINTER THAT CAN'T
000000  1               ; 		BE MATCHED. WHEN "FNDFOR" HAS RUN
000000  1               ; 		THROUGH ALL THE "FOR" ENTRIES ON THE STACK
000000  1               ; 		IT RETURNS AND THE RETURN CODE MAKES
000000  1               ; 		SURE THE ENTRY THAT WAS STOPPED
000000  1               ; 		ON IS A GOSUB ENTRY. THIS ASSURES THAT
000000  1               ; 		IF YOU GOSUB TO A SECTION OF CODE
000000  1               ; 		IN WHICH A FOR LOOP IS ENTERED BUT NEVER
000000  1               ; 		EXITED THE RETURN WILL STILL BE
000000  1               ; 		ABLE TO FIND THE MOST RECENT
000000  1               ; 		GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
000000  1               ; 		"GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
000000  1               ; 		THE GOSUB ENTRY.
000000  1               ;
000000  1               ; 	NON-RUNTIME STUFF
000000  1               ; 		THE CODE TO INPUT A LINE, CRUNCH IT, GIVE ERRORS,
000000  1               ; 		FIND A SPECIFIC LINE IN THE PROGRAM,
000000  1               ; 		PERFORM A "NEW", "CLEAR", AND "LIST" ARE
000000  1               ; 		ALL IN THIS AREA. GIVEN THE EXPLANATION OF
000000  1               ; 		PROGRAM STORAGE SET FORTH ABOVE, THESE ARE
000000  1               ; 		ALL STRAIGHTFORWARD.
000000  1               ;
000000  1               ; 	NEWSTT
000000  1               ; 		WHENEVER A STATEMENT FINISHES EXECUTION IT
000000  1               ; 		DOES A "RTS" WHICH TAKES
000000  1               ; 		EXECUTION BACK TO "NEWSTT". STATEMENTS THAT
000000  1               ; 		CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
000000  1               ; 		MUST GET RID OF THE RETURN ADDRESS OF "NEWSTT" AND
000000  1               ; 		JMP TO "NEWSTT" WHEN DONE. "NEWSTT" ALWAYS
000000  1               ; 		CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
000000  1               ; 		NAME BEFORE DISPATCHING. WHEN RETURNING
000000  1               ; 		BACK TO "NEWSTT" THE ONLY THING THAT
000000  1               ; 		MUST BE SET UP IS THE TEXT POINTER IN
000000  1               ; 		"TXTPTR". "NEWSTT" WILL CHECK TO MAKE SURE
000000  1               ; 		"TXTPTR" IS POINTING TO A STATEMENT TERMINATOR.
000000  1               ; 		IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
000000  1               ; 		IT IS PROPERLY FORMATTED (I.E. "NEW") IT CAN
000000  1               ; 		SIMPLY DO A RETURN AFTER READING ALL OF
000000  1               ; 		ITS ARGUMENTS. SINCE THE ZERO FLAG
000000  1               ; 		BEING OFF INDICATES THERE IS NOT
000000  1               ; 		A STATEMENT TERMINATOR "NEWSTT" WILL
000000  1               ; 		DO THE JMP TO THE "SYNTAX ERROR"
000000  1               ; 		ROUTINE. IF A STATEMENT SHOULD BE STARTED
000000  1               ; 		OVER IT CAN DO LDWD OLDTXT, STWD TXTPTR RTS SINCE THE TEXT PNTR
000000  1               ; 		AT "NEWSTT" IS ALWAYS STORED IN "OLDTXT".
000000  1               ; 		THE ^C CODE STORES [CURLIN] (THE
000000  1               ; 		CURRENT LINE NUMBER) IN "OLDLIN" SINCE THE ^C CHECK
000000  1               ; 		IS MADE BEFORE THE STATEMENT POINTED TO IS
000000  1               ; 		EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
000000  1               ; 		FROM "TXTPTR", WHICH POINTS AT THEIR TERMINATING
000000  1               ; 		CHARACTER, IN "OLDTXT".
000000  1               ;
000000  1               ; 	STATEMENT CODE
000000  1               ; 		THE INDIVIDUAL STATEMENT CODE COMES
000000  1               ; 		NEXT. THE APPROACH USED IN EXECUTING EACH
000000  1               ; 		STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
000000  1               ; 		ITSELF.
000000  1               ;
000000  1               ; 	FRMEVL, THE FORMULA EVALUATOR
000000  1               ; 		GIVEN A TEXT POINTER POINTING TO THE STARTING
000000  1               ; 		CHARACTER OF A FORMULA, "FRMEVL"
000000  1               ; 		EVALUATES THE FORMULA AND LEAVES
000000  1               ; 		THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
000000  1               ; 		"TXTPTR" IS RETURNED POINTING TO THE FIRST CHARACTER
000000  1               ; 		THAT COULD NOT BE INTERPRETED AS PART OF THE
000000  1               ; 		FORMULA. THE ALGORITHM USES THE STACK
000000  1               ; 		TO STORE TEMPORARY RESULTS:
000000  1               ;
000000  1               ; 			0. PUT A DUMMY PRECEDENCE OF ZERO ON
000000  1               ; 				THE STACK.
000000  1               ; 			1. READ LEXEME (CONSTANT,FUNCTION,
000000  1               ; 				VARIABLE,FORMULA IN PARENS)
000000  1               ; 				AND TAKE THE LAST PRECEDENCE VALUE
000000  1               ; 				OFF THE STACK.
000000  1               ; 			2. SEE IF THE NEXT CHARACTER IS AN OPERATOR.
000000  1               ; 				IF NOT, CHECK PREVIOUS ONE. THIS MAY CAUSE
000000  1               ; 				OPERATOR APPLICATION OR AN ACTUAL
000000  1               ; 				RETURN FROM "FRMEVL".
000000  1               ; 			3. IF IT IS, SEE WHAT PRECEDENCE IT HAS
000000  1               ; 				AND COMPARE IT TO THE PRECEDENCE
000000  1               ; 				OF THE LAST OPERATOR ON THE STACK.
000000  1               ; 			4. IF = OR LESS REMEMBER THE OPERATOR
000000  1               ; 				POINTER OF THIS OPERATOR
000000  1               ; 				AND BRANCH TO "QCHNUM" TO CAUSE
000000  1               ; 				APPLICATION OF THE LAST OPERATOR.
000000  1               ; 				EVENTUALLY RETURN TO STEP 2
000000  1               ; 				BY RETURNING TO JUST AFTER "DOPREC".
000000  1               ; 			5. IF GREATER PUT THE LAST PRECEDENCE
000000  1               ; 				BACK ON, SAVE THE OPERATOR ADDRESS,
000000  1               ; 				CURRENT TEMPORARY RESULT,
000000  1               ; 				AND PRECEDENCE AND RETURN TO STEP 1.
000000  1               ;
000000  1               ; 		RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
000000  1               ; 		A COMMON ROUTINE. SPECIAL
000000  1               ; 		CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F".
000000  1               ;
000000  1               ; 	EVAL -- THE ROUTINE TO READ A LEXEME
000000  1               ; 		"EVAL" CHECKS FOR THE DIFFERENT TYPES OF
000000  1               ; 		ENTITIES IT IS SUPPOSED TO DETECT.
000000  1               ; 		LEADING PLUSES ARE IGNORED,
000000  1               ; 		DIGITS AND "." CAUSE "FIN" (FLOATING INPUT)
000000  1               ; 		TO BE CALLED. FUNCTION NAMES CAUSE THE
000000  1               ; 		FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
000000  1               ; 		AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
000000  1               ; 		NAMES CAUSE "PTRGET" TO BE CALLED TO GET A POINTER
000000  1               ; 		TO THE VALUE, AND THEN THE VALUE IS PUT INTO
000000  1               ; 		THE FAC. AN OPEN PARENTHESIS CAUSES "FRMEVL"
000000  1               ; 		TO BE CALLED (RECURSIVELY), AND THE ")" TO
000000  1               ; 		BE CHECKED FOR. UNARY OPERATORS (NOT AND
000000  1               ; 		NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
000000  1               ; 		AND ENTER FORMULA EVALUATION AT STEP 1, SO
000000  1               ; 		THAT EVERYTHING UP TO AN OPERATOR GREATER THAN
000000  1               ; 		THEIR PRECEDENCE OR THE END OF THE FORMULA
000000  1               ; 		WILL BE EVALUATED.
000000  1               ;
000000  1               ; 	DIMENSION AND VARIABLE SEARCHING
000000  1               ; 		SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
000000  1               ; 		ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
000000  1               ; 		EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
000000  1               ; 		FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
000000  1               ; 		NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
000000  1               ; 		BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
000000  1               ; 		GIVE ITS VALUE. [VARTAB] GIVES THE FIRST LOCATION
000000  1               ; 		WHERE A SIMPLE VARIABLE NAME IS FOUND AND [ARYTAB]
000000  1               ; 		GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
000000  1               ; 		VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
000000  1               ; 		AND A POINTER TO A VARIABLE VALUE SO NEITHER
000000  1               ; 		THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
000000  1               ; 		MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK.
000000  1               ; 		USER DEFINED FUNCTION VALUES ALSO CONTAIN
000000  1               ; 		POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
000000  1               ; 		FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
000000  1               ; 		ARE MOVED. ADDING A SIMPLE VARIABLE IS JUST
000000  1               ; 		ADDING SIX TO [ARYTAB] AND [STREND], BLOCK TRANSFERING
000000  1               ; 		THE ARRAY VARIABLES UP BY SIX AND MAKING SURE THE
000000  1               ; 		NEW [STREND] IS NOT TOO CLOSE TO THE STRINGS.
000000  1               ; 		THIS MOVEMENT OF ARRAY VARIABLES MEANS
000000  1               ; 		THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
000000  1               ; 		NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
000000  1               ; 		WHY ARRAY VARIABLES ARE NOT ALLOWED FOR "FOR"
000000  1               ; 		LOOP VARIABLES. SETTING UP A NEW ARRAY VARIABLE
000000  1               ; 		MERELY INVOLVES BUILDING THE DESCRIPTOR,
000000  1               ; 		UPDATING [STREND], AND MAKING SURE THERE IS
000000  1               ; 		STILL ENOUGH ROOM BETWEEN [STREND] AND STRING SPACE.
000000  1               ; 		"PTRGET", THE ROUTINE WHICH RETURNS A POINTER
000000  1               ; 		TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
000000  1               ; 		"DIMFLG" WHICH INDICATES WHETHER "DIM" CALLED "PTRGET"
000000  1               ; 		OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
000000  1               ; 		QUESTION SHOULD BE FOUND, AND THE INDEX INDICATES
000000  1               ; 		HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
000000  1               ; 		BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
000000  1               ; 		SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
000000  1               ; 		ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS "SUBFLG"
000000  1               ; 		WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
000000  1               ; 		ALLOWED IN THE CURRENT CONTEXT. IF [SUBFLG] IS NON-ZERO
000000  1               ; 		THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
000000  1               ; 		WILL NOT BE SCANNED BY "PTRGET", AND "PTRGET" WILL RETURN
000000  1               ; 		WITH A TEXT POINTER POINTING TO THE "(", IF
000000  1               ; 		THERE WAS ONE.
000000  1               ; 	STRINGS
000000  1               ; 		IN THE VARIABLE TABLES STRINGS ARE STORED JUST LIKE
000000  1               ; 		NUMERIC VARIABLES. SIMPLE STRINGS HAVE THREE VALUE
000000  1               ; 		BYTES WHICH ARE INITIALIZED TO ALL ZEROS (WHICH
000000  1               ; 		REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
000000  1               ; 		IN HANDLING IS THAT WHEN "PTRGET" SEES A "$" AFTER THE
000000  1               ; 		NAME OF A VARIABLE, "PTRGET" SETS [VALTYP]
000000  1               ; 		TO NEGATIVE ONE AND TURNS
000000  1               ; 		ON THE MSB (MOST-SIGNIFIGANT-BIT) OF THE VALUE OF
000000  1               ; 		THE FIRST CHARACTER OF THE VARIABLE NAME.
000000  1               ; 		HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
000000  1               ; 		THAT THE SEARCH ROUTINE WILL NOT MATCH
000000  1               ; 		'A' WITH 'A$' OR 'A$' WITH 'A'. THE MEANING OF
000000  1               ; 		THE THREE VALUE BYTES ARE:
000000  1               ; 			LOW
000000  1               ; 				LENGTH OF THE STRING
000000  1               ; 				LOW 8 BITS
000000  1               ; 				HIGH 8 BITS  OF THE ADDRESS
000000  1               ; 					OF THE CHARACTERS IN THE
000000  1               ; 					STRING IF LENGTH.NE.0.
000000  1               ; 					MEANINGLESS OTHERWISE.
000000  1               ; 			HIGH
000000  1               ; 		THE VALUE OF A STRING VARIABLE (THESE 3 BYTES)
000000  1               ; 		IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
000000  1               ; 		IT FROM THE ACTUAL STRING DATA. WHENEVER A
000000  1               ; 		STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
000000  1               ; 		PART OF AN INPUT STRING, OR AS PART OF DATA, "STRLIT"
000000  1               ; 		IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
000000  1               ; 		THE STRING. WHEN ASSIGNMENT IS MADE TO A STRING POINTING INTO
000000  1               ; 		"BUF" THE VALUE IS COPIED INTO STRING SPACE SINCE [BUF]
000000  1               ; 		IS ALWAYS CHANGING.
000000  1               ;
000000  1               ; 		STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
000000  1               ; 		ALWAYS RETURN THEIR VALUES IN STRING SPACE.
000000  1               ; 		ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
000000  1               ; 		THROUGH A "READ" OR ASSIGNMENT STATEMENT
000000  1               ; 		WILL NOT USE ANY STRING SPACE SINCE
000000  1               ; 		THE STRING DESCRIPTOR  WILL POINT INTO THE
000000  1               ; 		PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
000000  1               ; 		WHEN A STRING VALUE IS IN "BUF", OR IT IS IN STRING
000000  1               ; 		SPACE AND THERE IS AN ACTIVE POINTER TO IT.
000000  1               ; 		THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
000000  1               ; 		STRING DATA IN STRING SPACE. F$=CHR$(7)
000000  1               ; 		WILL USE ONE BYTE OF STRING SPACE TO STORE THE
000000  1               ; 		NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
000000  1               ; 		THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
000000  1               ; 		THE ONLY POINTER AT THE NEW STRING IS A
000000  1               ; 		TEMPORARY DESCRIPTOR CREATED BY "FRMEVL" WHICH WILL
000000  1               ; 		GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
000000  1               ; 		IT IS THE NATURE OF GARBAGE COLLECTION THAT
000000  1               ; 		DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
000000  1               ; 		AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
000000  1               ; 		MUST PROCEED AS FOLLOWS:
000000  1               ; 			1) FIGURE OUT THE LENGTH OF THEIR RESULT.
000000  1               ;
000000  1               ; 			2) CALL "GETSPA" TO FIND SPACE FOR THEIR
000000  1               ; 			RESULT. THE ARGUMENTS TO THE FUNCTION
000000  1               ; 			OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
000000  1               ; 			MAY BE INVOKED. THE ONLY THING THAT CAN
000000  1               ; 			BE SAVED DURING THE CALL TO "GETSPA" IS A POINTER
000000  1               ; 			TO THE DESCRIPTORS OF THE ARGUMENTS.
000000  1               ; 			3) CONSTRUCT THE RESULT DESCRIPTOR IN "DSCTMP".
000000  1               ; 			"GETSPA" RETURNS THE LOCATION OF THE AVAILABLE
000000  1               ; 			SPACE.
000000  1               ; 			4) CREATE THE NEW VALUE BY COPYING PARTS
000000  1               ; 			OF THE ARGUMENTS OR WHATEVER.
000000  1               ; 			5) FREE UP THE ARGUMENTS BY CALLING "FRETMP".
000000  1               ; 			6) JUMP TO "PUTNEW" TO GET THE DESCRIPTOR IN
000000  1               ; 			"DSCTMP" TRANSFERRED INTO A NEW STRING TEMPORARY.
000000  1               ;
000000  1               ; 		THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
000000  1               ; 		COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
000000  1               ; 		SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
000000  1               ; 		USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
000000  1               ;
000000  1               ; 		INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
000000  1               ; 		FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
000000  1               ; 		BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
000000  1               ; 		VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
000000  1               ; 		STORED IN THE FAC, AND IT IS THIS POINTER
000000  1               ; 		THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
000000  1               ; 		STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
000000  1               ; 		AWAY SINCE "GETSPA" MAY FORCE
000000  1               ; 		GARBAGE COLLECTION AND THE ARGUMENT STRINGS
000000  1               ; 		MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
000000  1               ; 		WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
000000  1               ; 		THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
000000  1               ; 		"DSCTMP" SINCE STRING TEMPORARIES ARE ALLOCATED
000000  1               ; 		(PUTNEW) AND DEALLOCATED (FRETMP) IN A FIFO ORDERING
000000  1               ; 		(I.E. A STACK) SO THE NEW TEMPORARY CANNOT
000000  1               ; 		BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
000000  1               ; 		TO BUILD A RESULT IN A TEMPORARY AFTER
000000  1               ; 		FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
000000  1               ; 		IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
000000  1               ; 		TOO SOON BY THE NEW RESULT.
000000  1               ;
000000  1               ; 		STRING SPACE IS ALLOCATED AT THE VERY TOP
000000  1               ; 		OF MEMORY. "MEMSIZ" POINTS BEYOND THE LAST LOCATION OF
000000  1               ; 		STRING SPACE. STRINGS ARE STORED IN HIGH LOCATIONS
000000  1               ; 		FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA).
000000  1               ; 		[FRETOP], WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
000000  1               ; 		TO GIVE THE HIGHEST LOCATION IN STRING SPACE
000000  1               ; 		THAT IS NOT IN USE. THE RESULT IS THAT
000000  1               ; 		[FRETOP] GETS SMALLER AND SMALLER, UNTIL SOME
000000  1               ; 		ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
000000  1               ; 		[STREND]. THIS MEANS STRING SPACE HAS RUN INTO THE
000000  1               ; 		THE ARRAYS AND THAT GARBAGE COLLECTION MUST BE CALLED.
000000  1               ;
000000  1               ; 		GARBAGE COLLECTION:
000000  1               ; 			0. [MINPTR]=[STREND] [FRETOP]=[MEMSIZ]
000000  1               ; 			1. [REMMIN]=0
000000  1               ; 			2. FOR EACH STRING DESCRIPTOR
000000  1               ; 			(TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
000000  1               ; 			IF THE STRING IS NOT NULL AND ITS POINTER IS
000000  1               ; 			.GT.MINPTR AND .LT.FRETOP,
000000  1               ; 			[MINPTR]=THIS STRING DESCRIPTOR'S POINTER,
000000  1               ; 			[REMMIN]=POINTER AT THIS STRING DESCRIPTOR.
000000  1               ; 			END.
000000  1               ; 			3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING),
000000  1               ; 			BLOCK TRANSFER THE STRING DATA POINTED
000000  1               ; 			TO IN THE STRING DESCRIPTOR POINTED TO BY "REMMIN"
000000  1               ; 			SO THAT THE LAST BYTE OF STRING DATA IS AT
000000  1               ; 			[FRETOP]. UPDATE [FRETOP] SO THAT IT
000000  1               ; 			POINTS TO THE LOCATION JUST BELOW THE ONE
000000  1               ; 			THE STRING DATA WAS MOVED INTO. UPDATE
000000  1               ; 			THE POINTER IN THE DESCRIPTOR SO IT POINTS
000000  1               ; 			TO THE NEW LOCATION OF THE STRING DATA.
000000  1               ; 			GO TO STEP 1.
000000  1               ;
000000  1               ; 		AFTER CALLING GARBAGE COLLECTION "GETSPA" AGAIN CHECKS
000000  1               ; 		TO SEE IF [ACCA] CHARACTERS ARE AVAILABLE BETWEEN
000000  1               ; 		[STREND] AND [FRETOP]; IF NOT, AN "OUT OF STRING"
000000  1               ; 		ERROR IS INVOKED.
000000  1               ;
000000  1               ; 	MATH PACKAGE
000000  1               ; 		THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
000000  1               ; 		FLOATING OUTPUT (FOUT), FLOATING COMPARE (FCOMP)
000000  1               ; 		... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
000000  1               ; 		THE FORMATS, CONVENTIONS AND ENTRY POINTS ARE ALL
000000  1               ; 		DESCRIBED IN THE MATH PACKAGE ITSELF.
000000  1               ;
000000  1               ; 	INIT -- THE INITIALIZATION ROUTINE
000000  1               ; 		THE AMOUNT OF MEMORY,
000000  1               ; 		TERMINAL WIDTH, AND WHICH FUNCTIONS TO BE RETAINED
000000  1               ; 		ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
000000  1               ; 		AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
000000  1               ; 		AND [TXTTAB] IS SET UP TO POINT AT THE NEXT LOCATION.
000000  1               ; 		THIS DETERMINES WHERE PROGRAM STORAGE WILL START.
000000  1               ; 		SPECIAL CHECKS ARE MADE TO MAKE SURE
000000  1               ; 		ALL QUESTIONS IN "INIT" ARE ANSWERED REASONABLY, SINCE
000000  1               ; 		ONCE "INIT" FINISHES, THE LOCATIONS IT USES ARE
000000  1               ; 		USED FOR PROGRAM STORAGE. THE LAST THING "INIT" DOES IS
000000  1               ; 		CHANGE LOCATION ZERO TO BE A JUMP TO "READY" INSTEAD
000000  1               ; 		OF "INIT". ONCE THIS IS DONE THERE IS NO WAY TO RESTART
000000  1               ; 		"INIT".
000000  1               ; HIGH LOCATIONS
000000  1               ;
000000  1               
000000  1               ; PAGE
000000  1               ; SUBTTL	PAGE ZERO.
000000  1               .IF	REALIO-3 <> 0
000000  1  4C 57 3E     START:	JMP	INIT		;INITIALIZE - SETUP CERTAIN LOCATIONS
000003  1               				;AND DELETE FUNCTIONS IF NOT NEEDED,
000003  1               				;AND CHANGE THIS TO "JMP READY"
000003  1               				;IN CASE USER RESTARTS AT LOC ZERO.
000003  1  4C 57 3E     RDYJSR: JMP	INIT		;CHANGED TO "JMP STROUT" BY "INIT"
000006  1               				;TO HANDLE ERRORS.
000006  1  3D 2E        ADRAYI: ADR(AYINT)		;STORE HERE THE ADDR OF THE
000008  1               				;ROUTINE TO TURN THE FAC INTO A
000008  1               				;TWO BYTE SIGNED INTEGER IN [Y,A]
000008  1  10 30        ADRGAY: ADR(GIVAYF)		;STORE HERE THE ADDR OF THE
00000A  1               				;ROUTINE TO CONVERT [Y,A] TO A FLOATING
00000A  1               				;POINT NUMBER IN THE FAC.
00000A  1               .ENDIF
00000A  1               .IF	ROMSW <> 0
00000A  1  4C C6 2E     USRPOK: JMP	FCERR		;SET UP ORIG BY INIT.
00000D  1               .ENDIF
00000D  1               ;
00000D  1               ; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
00000D  1               ; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
00000D  1               ; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
00000D  1               ; PROGRAM INSTRUCTIONS IN ROM.
00000D  1               ;
00000D  1               ; --- GENERAL RAM ---:
00000D  1  xx           CHARAC: BLOCK	1		;A DELIMITING CHARACTER.
00000E  1               INTEGR= CHARAC			;A ONE-BYTE INTEGER FROM "QINT".
00000E  1  xx           ENDCHR: BLOCK	1		;THE OTHER DELIMITING CHARACTER.
00000F  1  xx           COUNT:	BLOCK	1		;A GENERAL COUNTER.
000010  1               
000010  1               ; --- FLAGS ---:
000010  1  xx           DIMFLG: BLOCK	1		;IN GETTING A POINTER TO A VARIABLE
000011  1               				;IT IS IMPORTANT TO REMEMBER WHETHER IT
000011  1               				;IS BEING DONE FOR "DIM" OR NOT.
000011  1               				;DIMFLG AND VALTYP MUST BE
000011  1               				;CONSECUTIVE LOCATIONS.
000011  1               KIMY=	DIMFLG			;PLACE TO PRESERVE Y DURING OUT.
000011  1  xx           VALTYP: BLOCK	1		;THE TYPE INDICATOR.
000012  1               				;0=NUMERIC 1=STRING.
000012  1               .IF	INTPRC <> 0
000012  1  xx           INTFLG: BLOCK	1		;TELLS IF INTEGER.
000013  1               .ENDIF
000013  1  xx           DORES:	BLOCK	1		;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS.
000014  1               				;TURNED ON WHEN "DATA"
000014  1               				;BEING SCANNED BY CRUNCH SO UNQUOTED
000014  1               				;STRINGS WON'T BE CRUNCHED.
000014  1               GARBFL= DORES			;WHETHER TO DO GARBAGE COLLECTION.
000014  1  xx           SUBFLG: BLOCK	1		;FLAG WHETHER SUB'D VARIABLE ALLOWED.
000015  1               				;"FOR" AND USER-DEFINED FUNCTION
000015  1               				;POINTER FETCHING TURN
000015  1               				;THIS ON BEFORE CALLING "PTRGET"
000015  1               				;SO ARRAYS WON'T BE DETECTED.
000015  1               				;"STKINI" AND "PTRGET" CLEAR IT.
000015  1               				;ALSO DISALLOWS INTEGERS THERE.
000015  1  xx           INPFLG: BLOCK	1		;FLAGS WHETHER WE ARE DOING "INPUT"
000016  1               				;OR "READ".
000016  1  xx           TANSGN: BLOCK	1		;USED IN DETERMINING SIGN OF TANGENT.
000017  1               .IF	REALIO <> 0
000017  1               CNTWFL: BLOCK	1		;SUPPRESS OUTPUT FLAG.
000017  1               				;NON-ZERO MEANS SUPPRESS.
000017  1               				;RESET BY "INPUT", READY AND ERRORS.
000017  1               				;COMPLEMENTED BY INPUT OF ^O.
000017  1               .ENDIF
000017  1               
000017  1               .IF	REALIO-4 = 0
000017  1               	ORG	80	;ROOM FOR APPLE PAGE 0 STUFF.
000017  1               .ENDIF
000017  1               ; --- RAM DEALING WITH TERMINAL HANDLING ---:
000017  1               .IF	EXTIO <> 0
000017  1               CHANNL: BLOCK	1		;HOLDS CHANNEL NUMBER.
000017  1               .ENDIF
000017  1               .IF	NULCMD <> 0
000017  1  00           NULCNT: .BYTE 0			;NUMBER OF NULLS TO PRINT.
000018  1               .ENDIF
000018  1               .IF	REALIO-3 <> 0
000018  1  xx           TRMPOS: BLOCK	1		;POSITION OF TERMINAL CARRIAGE.
000019  1               .ENDIF
000019  1  48           LINWID: .BYTE LINLEN		;LENGTH OF LINE (WIDTH).
00001A  1  38           NCMWID: .BYTE NCMPOS		;POSITION BEYOND WHICH THERE ARE
00001B  1               				;NO MORE FIELDS.
00001B  1  00           LINNUM: .BYTE 0			;LOCATION TO STORE LINE NUMBER BEFORE BUF
00001C  1               				;SO THAT "BLTUC" CAN STORE IT ALL AWAY AT ONCE.
00001C  1  2C           .BYTE	44			;A COMMA (PRELOAD OR FROM ROM)
00001D  1               				;USED BY INPUT STATEMENT SINCE THE
00001D  1               				;DATA POINTER ALWAYS STARTS ON A
00001D  1               				;COMMA OR TERMINATOR.
00001D  1               .IF	BUFPAG = 0
00001D  1  xx xx xx xx  BUF:	BLOCK	BUFLEN		;TYPE IN STORED HERE.
000021  1  xx xx xx xx  
000025  1  xx xx xx xx  
000065  1               				;DIRECT STATEMENTS EXECUTE OUT OF
000065  1               				;HERE. REMEMBER "INPUT" SMASHES BUF.
000065  1               				;MUST BE ON PAGE ZERO
000065  1               				;OR ASSIGNMENT OF STRING
000065  1               				;VALUES IN DIRECT STATEMENTS WON'T COPY
000065  1               				;INTO STRING SPACE -- WHICH IT MUST.
000065  1               				;N.B. TWO NONZERO BYTES MUST PRECEDE "BUFLNM".
000065  1               .ENDIF
000065  1               
000065  1               ; --- STORAGE FOR TEMPORARY THINGS ---:
000065  1  xx           TEMPPT: BLOCK	1		;POINTER AT FIRST FREE TEMP DESCRIPTOR.
000066  1               				;INITIALIZED TO POINT TO TEMPST.
000066  1  xx xx        LASTPT: BLOCK	2		;POINTER TO LAST-USED STRING TEMPORARY.
000068  1  xx xx xx xx  TEMPST: BLOCK	STRSIZ*NUMTMP	;STORAGE FOR NUMTMP TEMP DESCRIPTORS.
00006C  1  xx xx xx xx  
000070  1  xx           
000071  1  xx xx        INDEX1: BLOCK	2		;INDEXES.
000073  1               INDEX=	INDEX1
000073  1  xx xx        INDEX2: BLOCK	2
000075  1  xx           RESHO:	BLOCK	1		;RESULT OF MULTIPLIER AND DIVIDER.
000076  1               .IF	ADDPRC <> 0
000076  1  xx           RESMOH: BLOCK	1		;ONE MORE BYTE.
000077  1               .ENDIF
000077  1  xx           RESMO:	BLOCK	1
000078  1  xx           RESLO:	BLOCK	1
000079  1               ADDEND= RESMO			;TEMPORARY USED BY "UMULT".
000079  1  00           .BYTE	0			;OVERFLOW FOR RES.
00007A  1               
00007A  1               ; --- POINTERS INTO DYNAMIC DATA STRUCTURES ---;
00007A  1  xx xx        TXTTAB: BLOCK	2		;POINTER TO BEGINNING OF TEXT.
00007C  1               				;DOESN'T CHANGE AFTER BEING
00007C  1               				;SETUP BY "INIT".
00007C  1  xx xx        VARTAB: BLOCK	2		;POINTER TO START OF SIMPLE
00007E  1               				;VARIABLE SPACE.
00007E  1               				;UPDATED WHENEVER THE SIZE OF THE
00007E  1               				;PROGRAM CHANGES, SET TO [TXTTAB]
00007E  1               				;BY "SCRATCH" ("NEW").
00007E  1  xx xx        ARYTAB: BLOCK	2		;POINTER TO BEGINNING OF ARRAY
000080  1               				;TABLE.
000080  1               				;INCREMENTED BY 6 WHENEVER
000080  1               				;A NEW SIMPLE VARIABLE IS FOUND, AND
000080  1               				;SET TO [VARTAB] BY "CLEARC".
000080  1  xx xx        STREND: BLOCK	2		;END OF STORAGE IN USE.
000082  1               				;INCREASED WHENEVER A NEW ARRAY
000082  1               				;OR SIMPLE VARIABLE IS ENCOUNTERED.
000082  1               				;SET TO [VARTAB] BY "CLEARC".
000082  1  xx xx        FRETOP: BLOCK	2		;TOP OF STRING FREE SPACE.
000084  1  xx xx        FRESPC: BLOCK	2		;POINTER TO NEW STRING.
000086  1  xx xx        MEMSIZ: BLOCK	2		;HIGHEST LOCATION IN MEMORY.
000088  1               
000088  1               ; --- LINE NUMBERS AND TEXTUAL POINTERS ---:
000088  1  xx xx        CURLIN: BLOCK	2		;CURRENT LINE #.
00008A  1               				;SET TO 0,255 FOR DIRECT STATEMENTS.
00008A  1  xx xx        OLDLIN: BLOCK	2		;OLD LINE NUMBER (SETUP BY ^C,"STOP"
00008C  1               				;OR "END" IN A PROGRAM).
00008C  1               POKER=	LINNUM			;SET UP LOCATION USED BY POKE.
00008C  1               				;TEMPORARY FOR INPUT AND READ CODE
00008C  1  xx xx        OLDTXT: BLOCK	2		;OLD TEXT POINTER.
00008E  1               				;POINTS AT STATEMENT TO BE EXEC'D NEXT.
00008E  1  xx xx        DATLIN: BLOCK	2		;DATA LINE # -- REMEMBER FOR ERRORS.
000090  1  xx xx        DATPTR: BLOCK	2		;POINTER TO DATA. INITIALIZED TO POINT
000092  1               				;AT THE ZERO IN FRONT OF [TXTTAB]
000092  1               				;BY "RESTORE" WHICH IS CALLED BY "CLEARC".
000092  1               				;UPDATED BY EXECUTION OF A "READ".
000092  1  xx xx        INPPTR: BLOCK	2		;THIS REMEMBERS WHERE INPUT IS COMING FROM.
000094  1               
000094  1               ; --- STUFF USED IN EVALUATIONS ---:
000094  1  xx xx        VARNAM: BLOCK	2		;VARIABLE'S NAME IS STORED HERE.
000096  1  xx xx        VARPNT: BLOCK	2		;POINTER TO VARIABLE IN MEMORY.
000098  1               FDECPT= VARPNT			;POINTER INTO POWER OF TENS OF "FOUT".
000098  1  xx xx        FORPNT: BLOCK	2		;A VARIABLE'S POINTER FOR "FOR" LOOPS
00009A  1               				;AND "LET" STATEMENTS.
00009A  1               LSTPNT= FORPNT			;PNTR TO LIST STRING.
00009A  1               ANDMSK= FORPNT			;THE MASK USED BY WAIT FOR ANDING.
00009A  1               EORMSK= FORPNT+1		;THE MASK FOR EORING IN WAIT.
00009A  1  xx xx        OPPTR:	BLOCK	2		;POINTER TO CURRENT OP'S ENTRY IN "OPTAB".
00009C  1               VARTXT= OPPTR			;POINTER INTO LIST OF VARIABLES.
00009C  1  xx           OPMASK: BLOCK	1		;MASK CREATED BY CURRENT OPERATOR.
00009D  1               DOMASK=TANSGN			;MASK IN USE BY RELATION OPERATIONS.
00009D  1  xx xx        DEFPNT: BLOCK	2		;POINTER USED IN FUNCTION DEFINITION.
00009F  1               GRBPNT= DEFPNT			;ANOTHER USED IN GARBAGE COLLECTION.
00009F  1  xx xx        DSCPNT: BLOCK	2		;POINTER TO A STRING DESCRIPTOR.
0000A1  1               .IF	ADDPRC <> 0
0000A1  1  xx           	BLOCK	1		;FOR TEMPF3.
0000A2  1               .ENDIF
0000A2  1               ; LGB: I am not sure what this means below: FOUR6:  EXP     STRSIZ
0000A2  1               ;      I assume this is an initialized byte
0000A2  1  03           FOUR6:	.BYTE	STRSIZ		;VARIABLE CONSTANT USED BY GARB COLLECT.
0000A3  1               
0000A3  1               ; --- ET CETERA ---:
0000A3  1  4C 60 EA     JMPER:	JMP	60000
0000A6  1               SIZE=	JMPER+1
0000A6  1               OLDOV=	JMPER+2			;THE OLD OVERFLOW.
0000A6  1               TEMPF3= DEFPNT			;A THIRD FAC TEMPORARY (4 BYTES).
0000A6  1               TEMPF1:
0000A6  1               .IF	ADDPRC <> 0		;FOR TEMPF1S EXTRA BYTE.
0000A6  1  00           .BYTE	0
0000A7  1               .ENDIF
0000A7  1  xx xx        HIGHDS: BLOCK	2		;DESINATION OF HIGHEST ELEMENT IN BLT.
0000A9  1  xx xx        HIGHTR: BLOCK	2		;SOURCE OF HIGHEST ELEMENT TO MOVE.
0000AB  1               TEMPF2:
0000AB  1               .IF	ADDPRC <> 0		;FOR TEMPF2S EXTRA BYTE.
0000AB  1  00           .BYTE	0
0000AC  1               .ENDIF
0000AC  1  xx xx        LOWDS:	BLOCK	2		;LOCATION OF LAST BYTE TRANSFERRED INTO.
0000AE  1  xx xx        LOWTR:	BLOCK	2		;LAST THING TO MOVE IN BLT.
0000B0  1               ARYPNT= HIGHDS			;A POINTER USED IN ARRAY BUILDING.
0000B0  1               GRBTOP= LOWTR			;A POINTER USED IN GARBAGE COLLECTION.
0000B0  1               DECCNT= LOWDS			;NUMBER OF PLACES BEFORE DECIMAL POINT.
0000B0  1               TENEXP= LOWDS+1			;HAS A DPT BEEN INPUT?
0000B0  1               DPTFLG= LOWTR			;BASE TEN EXPONENT.
0000B0  1               EXPSGN= LOWTR+1			;SIGN OF BASE TEN EXPONENT.
0000B0  1               
0000B0  1               ; --- THE FLOATING ACCUMULATOR ---:
0000B0  1               FAC:
0000B0  1  00           FACEXP: .BYTE 0
0000B1  1  00           FACHO:	.BYTE 0			;MOST SIGNIFICANT BYTE OF MANTISSA.
0000B2  1               .IF	ADDPRC <> 0
0000B2  1  00           FACMOH: .BYTE 0			;ONE MORE.
0000B3  1               .ENDIF
0000B3  1  00           FACMO:	.BYTE 0			;MIDDLE ORDER OF MANTISSA.
0000B4  1  00           FACLO:	.BYTE 0			;LEAST SIG BYTE OF MANTISSA.
0000B5  1  00           FACSGN: .BYTE 0			;SIGN OF FAC (0 OR -1) WHEN UNPACKED.
0000B6  1  00           SGNFLG: .BYTE 0			;SIGN OF FAC IS PRESERVED BERE BY "FIN".
0000B7  1               DEGREE= SGNFLG			;A COUNT USED BY POLYNOMIALS.
0000B7  1               DSCTMP= FAC			;THIS IS WHERE TEMP DESCS ARE BUILT.
0000B7  1               INDICE= FACMO			;INDICE IS SET UP HERE BY "QINT".
0000B7  1  00           BITS:	.BYTE 0			;SOMETHING FOR "SHIFTR" TO USE.
0000B8  1               
0000B8  1               ; --- THE FLOATING ARGUMENT (UNPACKED) ---:
0000B8  1  00           ARGEXP: .BYTE 0
0000B9  1  00           ARGHO:	.BYTE 0
0000BA  1               .IF	ADDPRC <> 0
0000BA  1  00           ARGMOH: .BYTE 0
0000BB  1               .ENDIF
0000BB  1  00           ARGMO:	.BYTE 0
0000BC  1  00           ARGLO:	.BYTE 0
0000BD  1  00           ARGSGN: .BYTE 0
0000BE  1               
0000BE  1  00           ARISGN: .BYTE 0			;A SIGN REFLECTING THE RESULT.
0000BF  1  00           FACOV:	.BYTE 0			;OVERFLOW BYTE OF THE FAC.
0000C0  1               STRNG1= ARISGN			;POINTER TO A STRING OR DESCRIPTOR.
0000C0  1               
0000C0  1  xx xx        FBUFPT: BLOCK	2		;POINTER INTO FBUFFR USED BY FOUT.
0000C2  1               BUFPTR= FBUFPT			;POINTER TO BUF USED BY "CRUNCH".
0000C2  1               STRNG2= FBUFPT			;POINTER TO STRING OR DESC.
0000C2  1               POLYPT= FBUFPT			;POINTER INTO POLYNOMIAL COEFFICIENTS.
0000C2  1               CURTOL= FBUFPT			;ABSOLUTE LINEAR INDEX IS FORMED HERE.
0000C2  1               ; PAGE
0000C2  1               ; SUBTTL	RAM CODE.
0000C2  1               ; THIS CODE GETS CHANGED THROUGHOUT EXECUTION.
0000C2  1               ; IT IS MADE TO BE FAST THIS WAY.
0000C2  1               ; ALSO, [X] AND [Y] ARE NOT DISTURBED
0000C2  1               ;
0000C2  1               ; "CHRGET" USING [TXTPTR] AS THE CURRENT TEXT PNTR
0000C2  1               ; FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [TXTPTR]
0000C2  1               ; AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
0000C2  1               ;	NOT C=	NUMERIC	  ("0" THRU "9")
0000C2  1               ;	Z=	":" OR END-OF-LINE (A NULL)
0000C2  1               ;
0000C2  1               ; [ACCA] = NEW CHAR.
0000C2  1               ; [TXTPTR]=[TXTPTR]+1
0000C2  1               ;
0000C2  1               ; THE FOLLOWING EXISTS IN ROM IF ROM EXISTS AND IS LOADED
0000C2  1               ; DOWN HERE BY INIT. OTHERWISE IT IS JUST LOADED INTO THIS
0000C2  1               ; RAM LIKE ALL THE REST OF RAM IS LOADED.
0000C2  1               ;
0000C2  1  E6 C9        CHRGET: INC	CHRGET+7	;INCREMENT THE WHOLE TXTPTR.
0000C4  1  D0 02        	BNE	CHRGOT
0000C6  1  E6 CA        	INC	CHRGET+8
0000C8  1  AD 60 EA     CHRGOT: LDA	60000		;A LOAD WITH AN EXT ADDR.
0000CB  1               TXTPTR= CHRGOT+1
0000CB  1  C9 20        	CMP	#' '		;SKIP SPACES.
0000CD  1  F0 F3        	BEQ	CHRGET
0000CF  1  C9 3A        QNUM:	CMP	#':'		;IS IT A ":"?
0000D1  1  B0 06        	BCS	CHRRTS		;IT IS .GE. ":"
0000D3  1  38           	SEC
0000D4  1  E9 30        	SBC	#'0'		;ALL CHARS .GT. "9" HAVE RET'D SO
0000D6  1  38           	SEC
0000D7  1  E9 D0        	SBC	#256-'0'		;SEE IF NUMERIC.
0000D9  1               				;TURN CARRY ON IF NUMERIC.
0000D9  1               				;ALSO, SETZ IF NULL.
0000D9  1  60           CHRRTS: RTS			;RETURN TO CALLER.
0000DA  1               
0000DA  1  80           RNDX:	.BYTE 128			;LOADED OR FROM ROM.
0000DB  1  4F           .BYTE	79			;THE INITIAL RANDOM NUMBER.
0000DC  1  C7           .BYTE	199
0000DD  1  52           .BYTE	82
0000DE  1               .IF	ADDPRC <> 0
0000DE  1  59           .BYTE	89			;ONE MORE BYTE.
0000DF  1               .ENDIF
0000DF  1               
0000DF  1               ORG	255			;PAGE 1 STUFF COMING UP.
0000FF  1  xx           LOFBUF: BLOCK	1		;THE LOW FAC BUFFER. COPYABLE.
000100  1               ;---  PAGE ZERO/ONE BOUNDARY ---.
000100  1               				;MUST HAVE 13 CONTIGUOUS BYTES.
000100  1  xx xx xx xx  FBUFFR: BLOCK	3*ADDPRC+13	;BUFFER FOR "FOUT".
000104  1  xx xx xx xx  
000108  1  xx xx xx xx  
000110  1               				;ON PAGE 1 SO THAT STRING IS NOT COPIED.
000110  1               
000110  1               ;STACK IS LOCATED HERE. IE FROM THE END OF FBUFFR TO STKEND.
000110  1               ; PAGE
000110  1               ; SUBTTL	DISPATCH TABLES, RESERVED WORDS, AND ERROR TEXTS.
000110  1               
000110  1               
000110  1               ; LGB: the trick that the "cutter" then extract the real binary, MUST be exactly before "ORG ROMLOC"
000110  1  7B 7B 43 55  .BYTE	"{{CUT#HERE}}"
000114  1  54 23 48 45  
000118  1  52 45 7D 7D  
00011C  1  00 20        .WORD	ROMLOC
00011E  1  57 3E        .WORD	INIT	; also give information about the entry point
000120  1  00 D0        .WORD	IO_START_ADDR
000122  1  00           .BYTE	REALIO
000123  1               ; LGB: end of hack
000123  1               
000123  1               	ORG	ROMLOC
002000  1               
002000  1  FF 25 1C 25  STMDSP: ADR(END-1)
002004  1  3E 2A CA 26  
002008  1               	ADR(FOR-1)
002008  1               	ADR(NEXT-1)
002008  1               	ADR(DATA-1)
002008  1  07 29 18 2D  .IF	EXTIO <> 0
00200C  1  31 29 77 27  
002010  1  77 26 4F 26  
002022  1               	ADR(INPUTN-1)
002022  1               .ENDIF
002022  1               	ADR(INPUT-1)
002022  1               	ADR(DIM-1)
002022  1               	ADR(READ-1)
002022  1               	ADR(LET-1)
002022  1               	ADR(GOTO-1)
002022  1               	ADR(RUN-1)
002022  1               	ADR(IF-1)
002022  1               	ADR(RESTOR-1)
002022  1               	ADR(GOSUB-1)
002022  1               	ADR(RETURN-1)
002022  1               	ADR(REM-1)
002022  1               	ADR(STOP-1)
002022  1               	ADR(ONGOTO-1)
002022  1  3E 26        .IF	NULCMD <> 0
002024  1               	ADR(NULL-1)
002024  1  AB 34        .ENDIF
002026  1               	ADR(FNWAIT-1)
002026  1  2F 30 A2 34  .IF	DISKO <> 0
00202A  1               .IF	REALIO-3 = 0
00202A  1               	ADR(CQLOAD-1)
00202A  1               	ADR(CQSAVE-1)
00202A  1               	ADR(CQVERF-1)
00202A  1               .ENDIF
00202A  1               .IF	REALIO <> 0
00202A  1               .IF	REALIO-2 <> 0
00202A  1               .IF	REALIO-3 <> 0
00202A  1               .IF	REALIO-5 <> 0
00202A  1               	ADR(LOAD-1)
00202A  1               	ADR(SAVE-1)
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .IF	REALIO-1 <> 0
00202A  1               .IF	REALIO-3 <> 0
00202A  1               .IF	REALIO-4 <> 0
00202A  1               	ADR(511)		;ADDRESS OF LOAD
00202A  1               	ADR(511)		;ADDRESS OF SAVE
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               .ENDIF
00202A  1               	ADR(DEF-1)
00202A  1               	ADR(POKE-1)
00202A  1  06 28 24 26  .IF	EXTIO <> 0
00202E  1               	ADR(PRINTN-1)
00202E  1               .ENDIF
00202E  1               	ADR(PRINT-1)
00202E  1               	ADR(CONT-1)
00202E  1  22 26        .IF	REALIO = 0
002030  1               	ADR(DDT-1)
002030  1  90 24 55 24  .ENDIF
002034  1               	ADR(LIST-1)
002034  1               	ADR(CLEAR-1)
002034  1               .IF	EXTIO <> 0
002034  1               	ADR(CMD-1)
002034  1               	ADR(CQSYS-1)
002034  1               	ADR(CQOPEN-1)
002034  1               	ADR(CQCLOS-1)
002034  1               .ENDIF
002034  1  F8 28        .IF	GETCMD <> 0
002036  1               	ADR(GET-1)		;FILL W/ GET ADDR.
002036  1  39 24        .ENDIF
002038  1               	ADR(SCRATH-1)
002038  1               
002038  1  B8 38 4B 39  FUNDSP: ADR(SGN)
00203C  1  D7 38        
00203E  1               	ADR(INT)
00203E  1               	ADR(ABS)
00203E  1               .IF	ROMSW = 0
00203E  1               USRLOC: ADR(FCERR)		;INITIALLY NO USER ROUTINE.
00203E  1               .ENDIF
00203E  1               .IF	ROMSW <> 0
00203E  1  0A 00        USRLOC: ADR(USRPOK)
002040  1  FC 2F 1D 30  .ENDIF
002044  1  B5 3B D6 3C  
002048  1  69 36 31 3C  
00204C  1               	ADR(FRE)
00204C  1               	ADR(POS)
00204C  1               	ADR(SQR)
00204C  1               	ADR(RND)
00204C  1               	ADR(LOG)
00204C  1               	ADR(EXP)
00204C  1               .IF	KIMROM <> 0
00204C  1               	REPEAT	4,{ADR(FCERR)}
00204C  1               .ENDIF
00204C  1               .IF	KIMROM = 0
00204C  1  12 3D        COSFIX: ADR(COS)
00204E  1  19 3D        SINFIX: ADR(SIN)
002050  1  62 3D        TANFIX: ADR(TAN)
002052  1  C6 3D        ATNFIX: ADR(ATN)
002054  1  8C 34 FA 33  .ENDIF
002058  1  E2 30 2B 34  
00205C  1  09 34 6A 33  
002066  1               	ADR(PEEK)
002066  1               	ADR(LEN)
002066  1               	ADR(STR)
002066  1               	ADR(VAL)
002066  1               	ADR(ASC)
002066  1               	ADR(CHR)
002066  1               	ADR(LEFT)
002066  1               	ADR(RIGHT)
002066  1               	ADR(MID)
002066  1  79 E8 34     OPTAB:	.BYTE 121
002069  1               	ADR(FADDT-1)
002069  1  79 D1 34     .BYTE	121
00206C  1               	ADR(FSUBT-1)
00206C  1  7B A9 36     .BYTE	123
00206F  1               	ADR(FMULTT-1)
00206F  1  7B 90 37     .BYTE	123
002072  1               	ADR(FDIVT-1)
002072  1  7F BE 3B     .BYTE	127
002075  1               	ADR(FPWRT-1)
002075  1  50 80 2C     .BYTE	80
002078  1               	ADR(ANDOP-1)
002078  1  46 7D 2C     .BYTE	70
00207B  1               	ADR(OROP-1)
00207B  1  7D F7 3B     NEGTAB: .BYTE 125
00207E  1               	ADR(NEGOP-1)
00207E  1  5A DA 2B     NOTTAB: .BYTE 90
002081  1               	ADR(NOTOP-1)
002081  1  64 AD 2C     PTDORL: .BYTE 100			;PRECEDENCE.
002084  1               	ADR	(DOREL-1)	;OPERATOR ADDRESS.
002084  1               ;
002084  1               ; TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
002084  1               ; SIGNIFICANT BIT ON.
002084  1               ; THE LIST OF RESERVED WORDS:
002084  1               ;
002084  1               Q .SET 128-1
002084  1               ;DEFINE	DCI(A),<Q=Q+1	; LGB converted
002084  1               ;	DC(A)>		; LGB converted
002084  1               .MACRO	DCI	txt
002084  1               	Q	.SET Q + 1
002084  1               	.BYTE	txt
002084  1               .ENDMACRO
002084  1               
002084  1  45 4E 44     RESLST: DCI"END"
002087  1               	ENDTK .SET Q
002087  1  46 4F 52     	DCI"FOR"
00208A  1               	FORTK .SET Q
00208A  1  4E 45 58 54  	DCI"NEXT"
00208E  1  44 41 54 41  	DCI"DATA"
002092  1               	DATATK .SET Q
002092  1               .IF	EXTIO <> 0
002092  1               	DCI"INPUT#"
002092  1               .ENDIF
002092  1  49 4E 50 55  	DCI"INPUT"
002096  1  54           
002097  1  44 49 4D     	DCI"DIM"
00209A  1  52 45 41 44  	DCI"READ"
00209E  1  4C 45 54     	DCI"LET"
0020A1  1  47 4F 54 4F  	DCI"GOTO"
0020A5  1               	GOTOTK .SET Q
0020A5  1  52 55 4E     	DCI"RUN"
0020A8  1  49 46        	DCI"IF"
0020AA  1  52 45 53 54  	DCI"RESTORE"
0020AE  1  4F 52 45     
0020B1  1  47 4F 53 55  	DCI"GOSUB"
0020B5  1  42           
0020B6  1               	GOSUTK=Q
0020B6  1  52 45 54 55  	DCI"RETURN"
0020BA  1  52 4E        
0020BC  1  52 45 4D     	DCI"REM"
0020BF  1               	REMTK=Q
0020BF  1  53 54 4F 50  	DCI"STOP"
0020C3  1  4F 4E        	DCI"ON"
0020C5  1               .IF	NULCMD <> 0
0020C5  1  4E 55 4C 4C  	DCI"NULL"
0020C9  1               .ENDIF
0020C9  1  57 41 49 54  	DCI"WAIT"
0020CD  1               .IF	DISKO <> 0
0020CD  1               	DCI"LOAD"
0020CD  1               	DCI"SAVE"
0020CD  1               .IF	REALIO-3 = 0
0020CD  1               	DCI"VERIFY"
0020CD  1               .ENDIF
0020CD  1               .ENDIF
0020CD  1  44 45 46     	DCI"DEF"
0020D0  1  50 4F 4B 45  	DCI"POKE"
0020D4  1               .IF	EXTIO <> 0
0020D4  1               	DCI"PRINT#"
0020D4  1               .ENDIF
0020D4  1  50 52 49 4E  	DCI"PRINT"
0020D8  1  54           
0020D9  1               	PRINTK .SET Q
0020D9  1  43 4F 4E 54  	DCI"CONT"
0020DD  1               .IF	REALIO = 0
0020DD  1  44 44 54     	DCI"DDT"
0020E0  1               .ENDIF
0020E0  1  4C 49 53 54  	DCI"LIST"
0020E4  1               .IF	REALIO-3 <> 0
0020E4  1  43 4C 45 41  	DCI"CLEAR"
0020E8  1  52           
0020E9  1               .ENDIF
0020E9  1               .IF	REALIO-3 = 0
0020E9  1               	DCI"CLR"
0020E9  1               .ENDIF
0020E9  1               .IF	EXTIO <> 0
0020E9  1               	DCI"CMD"
0020E9  1               	DCI"SYS"
0020E9  1               	DCI"OPEN"
0020E9  1               	DCI"CLOSE"
0020E9  1               .ENDIF
0020E9  1               .IF	GETCMD <> 0
0020E9  1  47 45 54     	DCI"GET"
0020EC  1               .ENDIF
0020EC  1  4E 45 57     	DCI"NEW"
0020EF  1               	SCRATK=Q
0020EF  1               ; END OF COMMAND LIST.
0020EF  1  54           	.BYTE "T"
0020F0  1  41           	.BYTE "A"
0020F1  1  42           	.BYTE "B"
0020F2  1  A8           	.BYTE '('+128
0020F3  1               	Q .SET Q+1
0020F3  1               	TABTK=Q
0020F3  1  54 4F        	DCI"TO"
0020F5  1               	TOTK .SET Q
0020F5  1  46 4E        	DCI"FN"
0020F7  1               	FNTK .SET Q
0020F7  1  53           	.BYTE "S"
0020F8  1  50           	.BYTE "P"
0020F9  1  43           	.BYTE "C"
0020FA  1  A8           	.BYTE '('+128		;MACRO DOESNT LIKE ('S IN ARGUMENTS.
0020FB  1               	Q .SET Q+1
0020FB  1               	SPCTK .SET Q
0020FB  1  54 48 45 4E  	DCI"THEN"
0020FF  1               	THENTK=Q
0020FF  1  4E 4F 54     	DCI"NOT"
002102  1               	NOTTK .SET Q
002102  1  53 54 45 50  	DCI"STEP"
002106  1               	STEPTK=Q
002106  1  2B           	DCI"+"
002107  1               	PLUSTK=Q
002107  1  2D           	DCI"-"
002108  1               	MINUTK=Q
002108  1  2A           	DCI"*"
002109  1  2F           	DCI"/"
00210A  1  5E           	DCI"^"
00210B  1  41 4E 44     	DCI"AND"
00210E  1  4F 52        	DCI"OR"
002110  1  BE           .BYTE	190			;A GREATER THAN SIGN
002111  1               	Q .SET Q+1
002111  1               	GREATK=Q
002111  1  3D           	DCI"="
002112  1               	EQULTK=Q
002112  1  BC           .BYTE	188
002113  1               	Q .SET Q+1		;A LESS THAN SIGN
002113  1               	LESSTK=Q
002113  1               ;
002113  1               ; NOTE DANGER OF ONE RESERVED WORD BEING A PART
002113  1               ; OF ANOTHER:
002113  1               ; IE . . IF 2 GREATER THAN F OR T=5 THEN...
002113  1               ; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
002113  1               ; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
002113  1               ; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
002113  1               ; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
002113  1               ;
002113  1  53 47 4E     	DCI"SGN"
002116  1               	ONEFUN=Q
002116  1  49 4E 54     	DCI"INT"
002119  1  41 42 53     	DCI"ABS"
00211C  1  55 53 52     	DCI"USR"
00211F  1  46 52 45     	DCI"FRE"
002122  1  50 4F 53     	DCI"POS"
002125  1  53 51 52     	DCI"SQR"
002128  1  52 4E 44     	DCI"RND"
00212B  1  4C 4F 47     	DCI"LOG"
00212E  1  45 58 50     	DCI"EXP"
002131  1  43 4F 53     	DCI"COS"
002134  1  53 49 4E     	DCI"SIN"
002137  1  54 41 4E     	DCI"TAN"
00213A  1  41 54 4E     	DCI"ATN"
00213D  1  50 45 45 4B  	DCI"PEEK"
002141  1  4C 45 4E     	DCI"LEN"
002144  1  53 54 52 24  	DCI"STR$"
002148  1  56 41 4C     	DCI"VAL"
00214B  1  41 53 43     	DCI"ASC"
00214E  1  43 48 52 24  	DCI"CHR$"
002152  1               LASNUM .SET Q			;NUMBER OF LAST FUNCTION
002152  1               				;THAT TAKES ONE ARG
002152  1  4C 45 46 54  	DCI"LEFT$"
002156  1  24           
002157  1  52 49 47 48  	DCI"RIGHT$"
00215B  1  54 24        
00215D  1  4D 49 44 24  	DCI"MID$"
002161  1  47 4F        	DCI"GO"
002163  1               GOTK .SET Q
002163  1  00           .BYTE	0			;MARKS END OF RESERVED WORD LIST
002164  1               
002164  1               .IF	LNGERR = 0
002164  1               Q .SET 0-2
002164  1               ;DEFINE	DCE(X),<Q=Q+2		; LGB
002164  1               ;	DC(X)>			; LGB
002164  1               .MACRO	DCE	txt
002164  1               	Q .SET	Q + 2
002164  1               	.BYTE	txt
002164  1               .ENDMACRO
002164  1  4E 46        ERRTAB: DCE"NF"
002166  1               	ERRNF .SET Q		;NEXT WITHOUT FOR.
002166  1  53 4E        	DCE"SN"
002168  1               	ERRSN .SET Q		;SYNTAX
002168  1  52 47        	DCE"RG"
00216A  1               	ERRRG .SET Q		;RETURN WITHOUT GOSUB.
00216A  1  4F 44        	DCE"OD"
00216C  1               	ERROD .SET Q		;OUT OF DATA.
00216C  1  46 43        	DCE"FC"
00216E  1               	ERRFC .SET Q		;ILLEGAL QUANTITY.
00216E  1  4F 56        	DCE"OV"
002170  1               	ERROV .SET Q		;OVERFLOW.
002170  1  4F 4D        	DCE"OM"
002172  1               	ERROM .SET Q		;OUT OF MEMORY.
002172  1  55 53        	DCE"US"
002174  1               	ERRUS .SET Q		;UNDEFINED STATEMENT.
002174  1  42 53        	DCE"BS"
002176  1               	ERRBS .SET Q		;BAD SUBSCRIPT.
002176  1  44 44        	DCE"DD"
002178  1               	ERRDD .SET Q		;REDIMENSIONED ARRAY.
002178  1  2F 30        	DCE"/0"
00217A  1               	ERRDV0 .SET Q		;DIVISION BY ZERO.
00217A  1  49 44        	DCE"ID"
00217C  1               	ERRID .SET Q		;ILLEGAL DIRECT.
00217C  1  54 4D        	DCE"TM"
00217E  1               	ERRTM .SET Q		;TYPE MISMATCH.
00217E  1  4C 53        	DCE"LS"
002180  1               	ERRLS .SET Q		;STRING TOO LONG.
002180  1               .IF	EXTIO <> 0
002180  1               	DCE"FD"			;FILE DATA.
002180  1               	ERRBD .SET Q
002180  1               .ENDIF
002180  1  53 54        	DCE"ST"
002182  1               	ERRST .SET Q		;STRING FORMULA TOO COMPLEX.
002182  1  43 4E        	DCE"CN"
002184  1               	ERRCN .SET Q		;CAN'T CONTINUE.
002184  1  55 46        	DCE"UF"
002186  1               	ERRUF .SET Q		;UNDEFINED FUNCTION.
002186  1               .ENDIF
002186  1               
002186  1               .IF	LNGERR <> 0
002186  1               Q .SET 0
002186  1               ; NOTE: THIS ERROR COUNT TECHNIQUE WILL NOT WORK IF THERE ARE MORE
002186  1               ; THAN 256 CHARACTERS OF ERROR MESSAGES
002186  1               ERRTAB: DC"NEXT WITHOUT FOR"
002186  1               	ERRNF .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"SYNTAX"
002186  1               	ERRSN .SET Q
002186  1               	Q .SET Q+6
002186  1               	DC"RETURN WITHOUT GOSUB"
002186  1               	ERRRG .SET Q
002186  1               	Q .SET Q+20
002186  1               	DC"OUT OF DATA"
002186  1               	ERROD .SET Q
002186  1               	Q .SET Q+11
002186  1               	DC"ILLEGAL QUANTITY"
002186  1               	ERRFC .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"OVERFLOW"
002186  1               	ERROV .SET Q
002186  1               	Q .SET Q+8
002186  1               	DC"OUT OF MEMORY"
002186  1               	ERROM .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"UNDEF'D STATEMENT"
002186  1               	ERRUS .SET Q
002186  1               	Q .SET Q+17
002186  1               	DC"BAD SUBSCRIPT"
002186  1               	ERRBS .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"REDIM'D ARRAY"
002186  1               	ERRDD .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"DIVISION BY ZERO"
002186  1               	ERRDV0 .SET Q
002186  1               	Q .SET Q+16
002186  1               	DC"ILLEGAL DIRECT"
002186  1               	ERRID .SET Q
002186  1               	Q .SET Q+14
002186  1               	DC"TYPE MISMATCH"
002186  1               	ERRTM .SET Q
002186  1               	Q .SET Q+13
002186  1               	DC"STRING TOO LONG"
002186  1               	ERRLS .SET Q
002186  1               	Q .SET Q+15
002186  1               .IF	EXTIO <> 0
002186  1               	DC"FILE DATA"
002186  1               	ERRBD .SET Q
002186  1               	Q .SET Q+9
002186  1               .ENDIF
002186  1               	DC"FORMULA TOO COMPLEX"
002186  1               	ERRST .SET Q
002186  1               	Q .SET Q+19
002186  1               	DC"CAN'T CONTINUE"
002186  1               	ERRCN .SET Q
002186  1               	Q .SET Q+14
002186  1               	DC"UNDEF'D FUNCTION"
002186  1               	ERRUF .SET Q
002186  1               .ENDIF
002186  1               
002186  1               ;
002186  1               ; NEEDED FOR MESSAGES IN ALL VERSIONS.
002186  1               ;
002186  1  20 45 52 52  ERR:	DT" ERROR"
00218A  1  4F 52        
00218C  1  00           .BYTE	0
00218D  1  20 49 4E 20  INTXT:	DT" IN "
002191  1  00           .BYTE	0
002192  1  0D 0A        REDDY:	ACRLF
002194  1               .IF	REALIO-3 = 0
002194  1               	DT"READY."
002194  1               .ENDIF
002194  1               .IF	REALIO-3 <> 0
002194  1  4F 4B        	DT"OK"
002196  1               .ENDIF
002196  1  0D 0A        	ACRLF
002198  1  00           .BYTE	0
002199  1  0D 0A        BRKTXT: ACRLF
00219B  1  42 52 45 41  	DT"BREAK"
00219F  1  4B           
0021A0  1  00           .BYTE	0
0021A1  1               ; PAGE
0021A1  1               ; SUBTTL	GENERAL STORAGE MANAGEMENT ROUTINES.
0021A1  1               ;
0021A1  1               ; FIND A "FOR" ENTRY ON THE STACK VIA "VARPNT".
0021A1  1               ;
0021A1  1               FORSIZ .SET 2*ADDPRC+16
0021A1  1  BA           FNDFOR: TSX			;LOAD XREG WITH STK PNTR.
0021A2  1  E8 E8 E8 E8  	REPEAT	4,{INX}		;IGNORE ADR(NEWSTT) AND RTS ADDR.
0021A6  1  BD 01 01     FFLOOP: LDA	257,X		;GET STACK ENTRY.
0021A9  1  C9 81        	CMP	#FORTK		;IS IT A "FOR" TOKEN?
0021AB  1  D0 21        	BNE	FFRTS		;NO, NO "FOR" LOOPS WITH THIS PNTR.
0021AD  1  A5 99        	LDA	FORPNT+1	;GET HIGH.
0021AF  1  D0 0A        	BNE	CMPFOR
0021B1  1  BD 02 01     	LDA	258,X		;PNTR IS ZERO, SO ASSUME THIS ONE.
0021B4  1  85 98        	STA	FORPNT
0021B6  1  BD 03 01     	LDA	259,X
0021B9  1  85 99        	STA	FORPNT+1
0021BB  1  DD 03 01     CMPFOR: CMP	259,X
0021BE  1  D0 07        	BNE	ADDFRS		;NOT THIS ONE.
0021C0  1  A5 98        	LDA	FORPNT		;GET DOWN.
0021C2  1  DD 02 01     	CMP	258,X
0021C5  1  F0 07        	BEQ	FFRTS		;WE GOT IT! WE GOT IT!
0021C7  1  8A           ADDFRS: TXA
0021C8  1  18           	CLC			;ADD 16 TO X.
0021C9  1  69 12        	ADC	#FORSIZ
0021CB  1  AA           	TAX			;RESULT BACK INTO X.
0021CC  1  D0 D8        	BNE	FFLOOP
0021CE  1  60           FFRTS:	RTS			;RETURN TO CALLER.
0021CF  1               
0021CF  1               ;
0021CF  1               ; THIS IS THE BLOCK TRANSFER ROUTINE.
0021CF  1               ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD.
0021CF  1               ;
0021CF  1               ; ON ENTRY:
0021CF  1               ; [Y,A]=[HIGHDS]    (FOR REASON).
0021CF  1               ; [HIGHDS]= DESTINATION OF [HIGH ADDRESS].
0021CF  1               ; [LOWTR]= LOWEST ADDR TO BE TRANSFERRED.
0021CF  1               ; [HIGHTR]= HIGHEST ADDR TO BE TRANSFERRED.
0021CF  1               ;
0021CF  1               ; A CHECK IS MADE TO ASCERTAIN THAT A REASONABLE
0021CF  1               ; AMOUNT OF SPACE REMAINS BETWEEN THE BOTTOM
0021CF  1               ; OF THE STRINGS AND THE HIGHEST LOCATION TRANSFERRED INTO.
0021CF  1               ;
0021CF  1               ; ON EXIT:
0021CF  1               ; [LOWTR] ARE UNCHANGED.
0021CF  1               ; [HIGHTR]=[LOWTR]-200 OCTAL.
0021CF  1               ; [HIGHDS]=LOWEST ADDR TRANSFERRED INTO MINUS 200 OCTAL.
0021CF  1               ;
0021CF  1  20 1F 22     BLTU:	JSR	REASON		;ASCERTAIN THAT STRING SPACE WON'T
0021D2  1               				;BE OVERRUN.
0021D2  1  85 80 84 81  	STWD	STREND
0021D6  1  38           BLTUC:	SEC			;PREPARE TO SUBTRACT.
0021D7  1  A5 A9        	LDA	HIGHTR
0021D9  1  E5 AE        	SBC	LOWTR		;COMPUTE NUMBER OF THINGS TO MOVE.
0021DB  1  85 71        	STA	INDEX		;SAVE FOR LATER.
0021DD  1  A8           	TAY
0021DE  1  A5 AA        	LDA	HIGHTR+1
0021E0  1  E5 AF        	SBC	LOWTR+1
0021E2  1  AA           	TAX			;PUT IT IN A COUNTER REGISTER.
0021E3  1  E8           	INX			;SO THAT COUNTER ALGORITHM WORKS.
0021E4  1  98           	TYA			;SEE IF LOW PART OF COUNT IS ZERO.
0021E5  1  F0 23        	BEQ	DECBLT		;YES, GO START MOVING BLOCKS.
0021E7  1  A5 A9        	LDA	HIGHTR		;NO, MUST MODIFY BASE ADDR.
0021E9  1  38           	SEC
0021EA  1  E5 71        	SBC	INDEX		;BORROW IS OFF SINCE [HIGHTR].GT.[LOWTR].
0021EC  1  85 A9        	STA	HIGHTR		;SAVE MODIFIED BASE ADDR.
0021EE  1  B0 03        	BCS	BLT1		;IF NO BORROW, GO SHOVE IT.
0021F0  1  C6 AA        	DEC	HIGHTR+1	;BORROW IMPLIES SUB 1 FROM HIGH ORDER.
0021F2  1  38           	SEC
0021F3  1  A5 A7        BLT1:	LDA	HIGHDS		;MOD BASE OF DEST ADDR.
0021F5  1  E5 71        	SBC	INDEX
0021F7  1  85 A7        	STA	HIGHDS
0021F9  1  B0 08        	BCS	MOREN1		;NO BORROW.
0021FB  1  C6 A8        	DEC	HIGHDS+1	;DECREMENT HIGH ORDER BYTE.
0021FD  1  90 04        	BCC	MOREN1		;ALWAYS SKIP.
0021FF  1  B1 A9        BLTLP:	LDADY	HIGHTR		;FETCH BYTE TO MOVE
002201  1  91 A7        	STADY	HIGHDS		;MOVE IT IN, MOVE IT OUT.
002203  1  88           MOREN1: DEY
002204  1  D0 F9        	BNE	BLTLP
002206  1  B1 A9        	LDADY	HIGHTR		;MOVE LAST OF THE BLOCK.
002208  1  91 A7        	STADY	HIGHDS
00220A  1  C6 AA        DECBLT: DEC	HIGHTR+1
00220C  1  C6 A8        	DEC	HIGHDS+1	;START ON NEW BLOCKS.
00220E  1  CA           	DEX
00220F  1  D0 F2        	BNE	MOREN1
002211  1  60           	RTS			;RETURN TO CALLER.
002212  1               
002212  1               ;
002212  1               ; THIS ROUTINE IS USED TO ASCERTAIN THAT A GIVEN
002212  1               ; NUMBER OF LOCS REMAIN AVAILABLE FOR THE STACK.
002212  1               ;    THE CALL IS:
002212  1               ;	LDAI	NUMBER OF 2-BYTE ENTRIES NEEDED.
002212  1               ;	JSR	GETSTK
002212  1               ;
002212  1               ; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
002212  1               ; AN ARBITRARY AMOUNT OF STUFF ON THE STACK,
002212  1               ; I.E., ANY RECURSIVE ROUTINE LIKE "FRMEVL".
002212  1               ; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
002212  1               ; WHICH MAKE PERMANENT ENTRIES ON THE STACK.
002212  1               ;
002212  1               ; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
002212  1               ; NUMLEV LOCATIONS NEED NOT CALL THIS.
002212  1               ;
002212  1               ;
002212  1               ; ON EXIT:
002212  1               ;    [A] AND [X] HAVE BEEN MODIFIED.
002212  1               ;
002212  1  0A           GETSTK: ASL	A 		;MULT [A] BY 2. NB, CLEARS C BIT.
002213  1  69 3E        	ADC	#2*NUMLEV+(3*ADDPRC)+13	;MAKE SURE 2*NUMLEV+13 LOCS
002215  1               				;(13 BECAUSE OF FBUFFR)
002215  1  B0 35        	BCS	OMERR		;WILL REMAIN IN STACK.
002217  1  85 71        	STA	INDEX
002219  1  BA           	TSX			;GET STACKED.
00221A  1  E4 71        	CPX	INDEX		;COMPARE.
00221C  1  90 2E        	BCC	OMERR		;IF STACK.LE.INDEX1, OM.
00221E  1  60           	RTS
00221F  1               
00221F  1               ;
00221F  1               ; [Y,A] IS A CERTAIN ADDRESS. "REASON" MAKES SURE
00221F  1               ; IT IS LESS THAN [FRETOP].
00221F  1               ;
00221F  1  C4 83        REASON: CPY	FRETOP+1
002221  1  90 28        	BCC	REARTS
002223  1  D0 04        	BNE	TRYMOR		;GO GARB COLLECT.
002225  1  C5 82        	CMP	FRETOP
002227  1  90 22        	BCC	REARTS
002229  1  48           TRYMOR: PHA
00222A  1  A2 09        	LDX	#8+ADDPRC	;IF TEMPF2 HAS ZERO IN BETWEEN.
00222C  1  98           	TYA
00222D  1  48           REASAV: PHA
00222E  1  B5 A6        	LDA	HIGHDS-1,X	;SAVE HIGHDS ON STACK.
002230  1  CA           	DEX
002231  1  10 FA        	BPL	REASAV		;PUT 8 OF THEM ON STK.
002233  1  20 9F 31     	JSR	GARBA2		;GO GARB COLLECT.
002236  1  A2 F7        	LDX	#256-8-ADDPRC
002238  1  68           REASTO: PLA
002239  1  95 B0        	STA	HIGHDS+8+ADDPRC,X	;RESTORE AFTER GARB COLLECT.
00223B  1  E8           	INX
00223C  1  30 FA        	BMI	REASTO
00223E  1  68           	PLA
00223F  1  A8           	TAY
002240  1  68           	PLA			;RESTORE A AND Y.
002241  1  C4 83        	CPY	FRETOP+1	;COMPARE HIGHS
002243  1  90 06        	BCC	REARTS
002245  1  D0 05        	BNE	OMERR		;HIGHER IS BAD.
002247  1  C5 82        	CMP	FRETOP		;AND THE LOWS.
002249  1  B0 01        	BCS	OMERR
00224B  1  60           REARTS: RTS
00224C  1               
00224C  1               ; PAGE
00224C  1               ; SUBTTL	ERROR HANDLER, READY, TERMINAL INPUT, COMPACTIFY, NEW, REINIT.
00224C  1  A2 0C        OMERR:	LDX	#ERROM
00224E  1               ERROR:
00224E  1               .IF	REALIO <> 0
00224E  1               	LSR	CNTWFL		;FORCE OUTPUT.
00224E  1               .ENDIF
00224E  1               .IF	EXTIO <> 0
00224E  1               	LDA	CHANNL		;CLOSE NON-TERMINAL CHANNEL.
00224E  1               	BEQ	ERRCRD
00224E  1               	JSR	CQCCHN		;CLOSE IT.
00224E  1               	LDA	#0
00224E  1               	STA	CHANNL
00224E  1               .ENDIF
00224E  1  20 45 28     ERRCRD: JSR	CRDO		;OUTPUT CRLF.
002251  1  20 BB 28     	JSR	OUTQST		;PRINT A QUESTION MARK
002254  1               .IF	LNGERR = 0
002254  1  BD 64 21     	LDA	ERRTAB,X 	;GET FIRST CHR OF ERR MSG.
002257  1  20 BD 28     	JSR	OUTDO		;OUTPUT IT.
00225A  1  BD 65 21     	LDA	ERRTAB+1,X 	;GET SECOND CHR.
00225D  1  20 BD 28     	JSR	OUTDO		;OUTPUT IT.
002260  1               .ENDIF
002260  1               .IF	LNGERR <> 0
002260  1               GETERR: LDA	ERRTAB,X
002260  1               	PHA
002260  1               	AND	#127		;GET RID OF HIGH BIT.
002260  1               	JSR	OUTDO		;OUTPUT IT.
002260  1               	INX
002260  1               	PLA			;LAST CHAR OF MESSAGE?
002260  1               	BPL	GETERR		;NO. GO GET NEXT AND OUTPUT IT.
002260  1               .ENDIF
002260  1  20 6F 24     TYPERR: JSR	STKINI		;RESET THE STACK AND FLAGS.
002263  1  A9 86 A0 21  	LDWDI	ERR		;GET PNTR TO " ERROR".
002267  1  20 9B 28     ERRFIN: JSR	STROUT		;OUTPUT IT.
00226A  1  A4 89        	LDY	CURLIN+1
00226C  1  C8           	INY			;WAS NUMBER 64000?
00226D  1  F0 03        	BEQ	READY		;YES, DON'T TYPE LINE NUMBER.
00226F  1  20 41 3A     	JSR	INPRT
002272  1               READY:
002272  1               .IF	REALIO <> 0
002272  1               	LSR	CNTWFL		;TURN OUTPUT BACK ON IF SUPRESSED
002272  1               .ENDIF
002272  1  A9 92 A0 21  	LDWDI	REDDY		;SAY "OK".
002276  1               .IF	REALIO-3 <> 0
002276  1  20 03 00     	JSR	RDYJSR		;OR GO TO INIT IF INIT ERROR.
002279  1               .ENDIF
002279  1               .IF	REALIO-3 = 0
002279  1               	JSR	STROUT		;NO INIT ERRORS POSSIBLE.
002279  1               .ENDIF
002279  1  20 51 23     MAIN:	JSR	INLIN		;GET A LINE FROM TERMINAL.
00227C  1  86 C9 84 CA  	STXY	TXTPTR
002280  1  20 C2 00     	JSR	CHRGET
002283  1  AA           	TAX			;SET ZERO FLAG BASED ON [A]
002284  1               				;THIS DISTINGUISHES ":" AND 0
002284  1  F0 F3        	BEQ	MAIN		;IF BLANK LINE, GET ANOTHER.
002286  1  A2 FF        	LDX	#255		;SET DIRECT LINE NUMBER.
002288  1  86 89        	STX	CURLIN+1
00228A  1  90 06        	BCC	MAIN1		;IS A LINE NUMBER. NOT DIRECT.
00228C  1  20 83 23     	JSR	CRUNCH		;COMPACTIFY.
00228F  1  4C B6 25     	JMP	GONE		;EXECUTE IT.
002292  1  20 3E 27     MAIN1:	JSR	LINGET		;READ LINE NUMBER INTO "LINNUM".
002295  1  20 83 23     	JSR	CRUNCH
002298  1  84 0F        	STY	COUNT		;RETAIN CHARACTER COUNT.
00229A  1  20 0B 24     	JSR	FNDLIN
00229D  1  90 44        	BCC	NODEL		;NO MATCH, SO DON'T DELETE.
00229F  1  A0 01        	LDY	#1
0022A1  1  B1 AE        	LDADY	LOWTR
0022A3  1  85 72        	STA	INDEX1+1
0022A5  1  A5 7C        	LDA	VARTAB
0022A7  1  85 71        	STA	INDEX1
0022A9  1  A5 AF        	LDA	LOWTR+1		;SET TRANSFER TO.
0022AB  1  85 74        	STA	INDEX2+1
0022AD  1  A5 AE        	LDA	LOWTR
0022AF  1  88           	DEY
0022B0  1  F1 AE        	SBCDY	LOWTR		;COMPUTE NEGATIVE LENGTH.
0022B2  1  18           	CLC
0022B3  1  65 7C        	ADC	VARTAB		;COMPUTE NEW VARTAB.
0022B5  1  85 7C        	STA	VARTAB
0022B7  1  85 73        	STA	INDEX2		;SET LOW OF TRANS TO.
0022B9  1  A5 7D        	LDA	VARTAB+1
0022BB  1  69 FF        	ADC	#255
0022BD  1  85 7D        	STA	VARTAB+1	;COMPUTE HIGH OF VARTAB.
0022BF  1  E5 AF        	SBC	LOWTR+1		;COMPUTE NUMBER OF BLOCKS TO MOVE.
0022C1  1  AA           	TAX
0022C2  1  38           	SEC
0022C3  1  A5 AE        	LDA	LOWTR
0022C5  1  E5 7C        	SBC	VARTAB		;COMPUTE OFFSET.
0022C7  1  A8           	TAY
0022C8  1  B0 03        	BCS	QDECT1		;IF VARTAB.LE.LOWTR,
0022CA  1  E8           	INX			;DECR DUE TO CARRY, AND
0022CB  1  C6 74        	DEC	INDEX2+1	;DECREMENT STORE SO CARRY WORKS.
0022CD  1  18           QDECT1: CLC
0022CE  1  65 71        	ADC	INDEX1
0022D0  1  90 03        	BCC	MLOOP
0022D2  1  C6 72        	DEC	INDEX1+1
0022D4  1  18           	CLC			;FOR LATER ADCQ
0022D5  1  B1 71        MLOOP:	LDADY	INDEX1
0022D7  1  91 73        	STADY	INDEX2
0022D9  1  C8           	INY
0022DA  1  D0 F9        	BNE	MLOOP		;BLOCK DONE?
0022DC  1  E6 72        	INC	INDEX1+1
0022DE  1  E6 74        	INC	INDEX2+1
0022E0  1  CA           	DEX
0022E1  1  D0 F2        	BNE	MLOOP		;DO ANOTHER BLOCK. ALWAYS.
0022E3  1  20 51 24     NODEL:	JSR	RUNC		;RESET ALL VARIABLE INFO SO GARBAGE
0022E6  1               				;COLLECTION CAUSED BY REASON WILL WORK
0022E6  1  20 1E 23     	JSR	LNKPRG		;FIX UP THE LINKS
0022E9  1  A5 1D        	LDA	BUF		;SEE IF ANYTHNG THERE
0022EB  1  F0 8C        	BEQ	MAIN
0022ED  1  18           	CLC
0022EE  1  A5 7C        	LDA	VARTAB
0022F0  1  85 A9        	STA	HIGHTR		;SETUP HIGHTR.
0022F2  1  65 0F        	ADC	COUNT		;ADD LENGTH OF LINE TO INSERT.
0022F4  1  85 A7        	STA	HIGHDS		;THIS GIVES DEST ADDR.
0022F6  1  A4 7D        	LDY	VARTAB+1
0022F8  1  84 AA        	STY	HIGHTR+1	;SAME FOR HIGH ORDERS.
0022FA  1  90 01        	BCC	NODELC
0022FC  1  C8           	INY
0022FD  1  84 A8        NODELC: STY	HIGHDS+1
0022FF  1  20 CF 21     	JSR	BLTU
002302  1               .IF	BUFPAG <> 0
002302  1               	LDWD	LINNUM		;POSITION THE BINARY LINE NUMBER
002302  1               	STWD	BUF-2		;IN FRONT OF BUF
002302  1               .ENDIF
002302  1  A5 80 A4 81  	LDWD	STREND
002306  1  85 7C 84 7D  	STWD	VARTAB
00230A  1  A4 0F        	LDY	COUNT
00230C  1  88           	DEY
00230D  1  B9 19 00     STOLOP: LDA	BUF-4,Y
002310  1  91 AE        	STADY	LOWTR
002312  1  88           	DEY
002313  1  10 F8        	BPL	STOLOP
002315  1  20 51 24     FINI:	JSR	RUNC		;DO CLEAR & SET UP STACK.
002318  1               				;AND SET [TXTPTR] TO [TXTTAB]-1.
002318  1  20 1E 23     	JSR	LNKPRG		;FIX UP PROGRAM LINKS
00231B  1  4C 79 22     	JMP	MAIN
00231E  1  A5 7A A4 7B  LNKPRG: LDWD	TXTTAB		;SET [INDEX] TO [TXTTAB].
002322  1  85 71 84 72  	STWD	INDEX
002326  1  18           	CLC
002327  1               ;
002327  1               ; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
002327  1               ; UP ALL THE LINKS. THE END OF EACH LINE IS FOUND
002327  1               ; BY SEARCHING FOR THE ZERO AT THE END.
002327  1               ; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM.
002327  1               ;
002327  1  A0 01        CHEAD:	LDY	#1
002329  1  B1 71        	LDADY	INDEX		;ARRIVED AT DOUBLE ZEROES?
00232B  1  F0 1D        	BEQ	LNKRTS
00232D  1  A0 04        	LDY	#4
00232F  1  C8           CZLOOP: INY			;THERE IS AT LEAST ONE BYTE.
002330  1  B1 71        	LDADY	INDEX
002332  1  D0 FB        	BNE	CZLOOP		;NO, CONTINUE SEARCHING.
002334  1  C8           	INY			;GO ONE BEYOND.
002335  1  98           	TYA
002336  1  65 71        	ADC	INDEX
002338  1  AA           	TAX
002339  1  A0 00        	LDY	#0
00233B  1  91 71        	STADY	INDEX
00233D  1  A5 72        	LDA	INDEX+1
00233F  1  69 00        	ADC	#0
002341  1  C8           	INY
002342  1  91 71        	STADY	INDEX
002344  1  86 71        	STX	INDEX
002346  1  85 72 90 DD  	STA	INDEX+1
00234A  1               	BCCA	CHEAD		;ALWAYS BRANCHES.
00234A  1  60           LNKRTS: RTS
00234B  1               ;
00234B  1               ; THIS IS THE LINE INPUT ROUTINE.
00234B  1               ; IT READS CHARACTERS INTO BUF USING BACKARROW (UNDERSCORE, OR
00234B  1               ; SHIFT O) AS THE DELETE CHARACTER AND @ AS THE
00234B  1               ; LINE DELETE CHARACTER. IF MORE THAN BUFLEN CHARACTERS
00234B  1               ; ARE TYPED, NO ECHOING IS DONE UNTIL A BACKARROW OR @ OR CR
00234B  1               ; IS TYPED. CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
00234B  1               ; THE ROUTINE IS ENTERED AT INLIN.
00234B  1               ;
00234B  1               .IF	REALIO-4 = 0
00234B  1               INLIN:	LDX	#128		;NO PROMPT CHARACTER
00234B  1               	STX	CQPRMP
00234B  1               	JSR	CQINLN		;GET A LINE ONTO PAGE 2
00234B  1               	CPX	#BUFLEN-1
00234B  1               	BCS	GDBUFS		;NOT TOO MANY CHARACTERS
00234B  1               	LDX	#BUFLEN-1
00234B  1               GDBUFS: LDA	#0		;PUT A ZERO AT THE END
00234B  1               	STA	BUF,X
00234B  1               	TXA
00234B  1               	BEQ	NOCHR
00234B  1               LOPBHT: LDA	BUF-1,X
00234B  1               	AND	#127
00234B  1               	STA	BUF-1,X
00234B  1               	DEX
00234B  1               	BNE	LOPBHT
00234B  1               NOCHR:	LDA	#0
00234B  1               	LDXYI	BUF-1		;POINT AT THE BEGINNING
00234B  1               	RTS
00234B  1               .ENDIF
00234B  1               .IF	REALIO-4 <> 0
00234B  1               .IF	REALIO-3 <> 0
00234B  1               LINLIN:
00234B  1               .IF	REALIO-2 = 0
00234B  1               	JSR	OUTDO		;ECHO IT.
00234B  1               .ENDIF
00234B  1  CA           	DEX			;BACKARROW SO BACKUP PNTR AND
00234C  1  10 05        	BPL	INLINC		;GET ANOTHER IF COUNT IS POSITIVE.
00234E  1               INLINN:
00234E  1               .IF	REALIO-2 = 0
00234E  1               	JSR	OUTDO		;PRINT THE @ OR A SECOND BACKARROW
00234E  1               				;IF THERE WERE TOO MANY.
00234E  1               .ENDIF
00234E  1  20 45 28     	JSR	CRDO
002351  1               .ENDIF
002351  1  A2 00        INLIN:	LDX	#0
002353  1  20 7E 23     INLINC: JSR	INCHR		;GET A CHARACTER.
002356  1               .IF	REALIO-3 <> 0
002356  1  C9 07        	CMP	#7		;IS IT BOB ALBRECHT RINGING THE BELL
002358  1               				;FOR SCHOOL KIDS?
002358  1  F0 14        	BEQ	GOODCH
00235A  1               .ENDIF
00235A  1  C9 0D        	CMP	#13		;CARRIAGE RETURN?
00235C  1  F0 1D        	BEQ	FININ1		;YES, FINISH UP.
00235E  1               .IF	REALIO-3 <> 0
00235E  1  C9 20        	CMP	#32		;CHECK FOR FUNNY CHARACTERS.
002360  1  90 F1        	BCC	INLINC
002362  1  C9 7D        	CMP	#125		;IS IT TILDA OR DELETE?
002364  1  B0 ED        	BCS	INLINC		;BIG BAD ONES TOO.
002366  1  C9 40        	CMP	#'@'		;LINE DELETE?
002368  1  F0 E4        	BEQ	INLINN		;YES.
00236A  1  C9 5F        	CMP	#'_'		;CHARACTER DELETE?
00236C  1  F0 DD        	BEQ	LINLIN		;YES.
00236E  1               .ENDIF
00236E  1               GOODCH:
00236E  1               .IF	REALIO-3 <> 0
00236E  1  E0 47        	CPX	#BUFLEN-1	;LEAVE ROOM FOR NULL.
002370  1               			;COMMO ASSURES US NEVER MORE THAN BUFLEN.
002370  1  B0 05        	BCS	OUTBEL
002372  1               .ENDIF
002372  1  95 1D        	STA	BUF,X
002374  1  E8           	INX
002375  1               .IF	REALIO-2 = 0
002375  1               	SKIP2
002375  1               .ENDIF
002375  1               .IF	REALIO-2 <> 0
002375  1  D0 DC        	BNE INLINC
002377  1               .ENDIF
002377  1               .IF	REALIO-3 <> 0
002377  1  A9 07        OUTBEL: LDA	#7
002379  1               .IF	REALIO <> 0
002379  1               	JSR	OUTDO		;ECHO IT.
002379  1               .ENDIF
002379  1  D0 D8        	BNE	INLINC		;CYCLE ALWAYS.
00237B  1               .ENDIF
00237B  1  4C 3F 28     FININ1: JMP	FININL		;GO TO FININL FAR, FAR AWAY.
00237E  1               .ENDIF
00237E  1               INCHR:
00237E  1               .IF	REALIO-3 = 0
00237E  1               	JSR	CQINCH		;FOR COMMODORE.
00237E  1               .ENDIF
00237E  1               .IF	REALIO-2 = 0
00237E  1               INCHRL: LDA	$FC00
00237E  1               	REPEAT	4,{NOP}
00237E  1               	LSR	A
00237E  1               	BCC	INCHRL
00237E  1               	LDA	$FC01	;GET THE CHARACTER.
00237E  1               	REPEAT	4,{NOP}
00237E  1               	AND	#127
00237E  1               .ENDIF
00237E  1               .IF	REALIO-1 = 0
00237E  1               	JSR	$1E5A		;1E5A FOR MOS TECH.
00237E  1               .ENDIF
00237E  1               .IF	REALIO-4 = 0
00237E  1               	JSR	CQINCH		;FD0C FOR APPLE COMPUTER.
00237E  1               	AND	#127
00237E  1               .ENDIF
00237E  1               .IF	REALIO = 0
00237E  1  AD 00 D0 18  	SIM_INSIM		;GET A CHARACTER FROM SIMULATOR
002382  1               .ENDIF
002382  1               
002382  1               .IF	REALIO <> 0
002382  1               .IF	EXTIO <> 0
002382  1               	LDY	CHANNL		;CNT-O HAS NO EFFECT IF NOT FROM TERM.
002382  1               	BNE	INCRTS
002382  1               .ENDIF
002382  1               	CMP	#CONTW		;SUPPRESS OUTPUT CHARACTER (^W).
002382  1               	BNE	INCRTS		;NO, RETURN.
002382  1               	PHA
002382  1               	COM	CNTWFL		;COMPLEMENT ITS STATE.
002382  1               	PLA
002382  1               .ENDIF
002382  1  60           INCRTS: RTS			;END OF INCHR.
002383  1               
002383  1               ;
002383  1               ; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
002383  1               ; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
002383  1               ; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
002383  1               ; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
002383  1               ; RESERVED WORD LIST IN THE SAME ORDER THEY
002383  1               ; APPEAR IN STMDSP.
002383  1               ;
002383  1               BUFOFS .SET 0			;THE AMOUNT TO OFFSET THE LOW BYTE
002383  1               				;OF THE TEXT POINTER TO GET TO BUF
002383  1               				;AFTER TXTPTR HAS BEEN SETUP TO POINT INTO BUF
002383  1               .IF	BUFPAG <> 0
002383  1               BUFOFS .SET (BUF/256)*256
002383  1               .ENDIF
002383  1  A6 C9        CRUNCH: LDX	TXTPTR		;SET SOURCE POINTER.
002385  1  A0 04        	LDY	#4		;SET DESTINATION OFFSET.
002387  1  84 13        	STY	DORES		;ALLOW CRUNCHING.
002389  1  B5 00        KLOOP:	LDA	BUFOFS,X
00238B  1               .IF	REALIO-3 = 0
00238B  1               	BPL	CMPSPC		;GO LOOK AT SPACES.
00238B  1               	CMP	#PI		;PI??
00238B  1               	BEQ	STUFFH		;GO SAVE IT.
00238B  1               	INX			;SKIP NO PRINTING.
00238B  1               	BNE	KLOOP		;ALWAYS GOES.
00238B  1               .ENDIF
00238B  1  C9 20        CMPSPC: CMP	#' '		;IS IT A SPACE TO SAVE?
00238D  1  F0 36        	BEQ	STUFFH		;YES, GO SAVE IT.
00238F  1  85 0E        	STA	ENDCHR		;IF IT'S A QUOTE, THIS WILL
002391  1               				;STOP LOOP WHEN OTHER QUOTE APPEARS.
002391  1  C9 22        	CMP	#34		;QUOTE SIGN?
002393  1  F0 54        	BEQ	STRNG		;YES, DO SPECIAL STRING HANDLING.
002395  1  24 13        	BIT	DORES		;TEST FLAG.
002397  1  70 2C        	BVS	STUFFH		;NO CRUNCH, JUST STORE.
002399  1  C9 3F        	CMP	#'?'		;A QMARK?
00239B  1  D0 04        	BNE	KLOOP1
00239D  1  A9 95        	LDA	#PRINTK		;YES, STUFF A "PRINT" TOKEN.
00239F  1  D0 24        	BNE	STUFFH		;ALWAYS GO TO STUFFH.
0023A1  1  C9 30        KLOOP1: CMP	#'0'		;SKIP NUMERICS.
0023A3  1  90 04        	BCC	MUSTCR
0023A5  1  C9 3C        	CMP	#60		;":" AND ";" ARE ENTERED STRAIGHTAWAY.
0023A7  1  90 1C        	BCC	STUFFH
0023A9  1  84 C0        MUSTCR: STY	BUFPTR		;SAVE BUFFER POINTER.
0023AB  1  A0 00        	LDY	#0		;LOAD RESLST POINTER.
0023AD  1  84 0F        	STY	COUNT		;ALSO CLEAR COUNT.
0023AF  1  88           	DEY
0023B0  1  86 C9        	STX	TXTPTR		;SAVE TEXT POINTER FOR LATER USE.
0023B2  1  CA           	DEX
0023B3  1  C8           RESER:	INY
0023B4  1  E8           RESPUL: INX
0023B5  1  B5 00        RESCON: LDA	BUFOFS,X
0023B7  1  38           	SEC			;PREPARE TO SUBSTARCT.
0023B8  1  F9 84 20     	SBC	RESLST,Y	;CHARACTERS EQUAL?
0023BB  1  F0 F6        	BEQ	RESER		;YES, CONTINUE SEARCH.
0023BD  1  C9 80        	CMP	#128		;NO BUT MAYBE THE END IS HERE.
0023BF  1  D0 2F        	BNE	NTHIS		;NO, TRULY UNEQUAL.
0023C1  1  05 0F        	ORA	COUNT
0023C3  1  A4 C0        GETBPT: LDY	BUFPTR		;GET BUFFER PNTR.
0023C5  1  E8           STUFFH: INX
0023C6  1  C8           	INY
0023C7  1  99 18 00     	STA	BUF-5,Y
0023CA  1  B9 18 00     	LDA	BUF-5,Y
0023CD  1  F0 34        	BEQ	CRDONE		;NULL IMPLIES END OF LINE.
0023CF  1  38           	SEC			;PREPARE TO SUBSTARCT.
0023D0  1  E9 3A        	SBC	#':'		;IS IT A ":"?
0023D2  1  F0 04        	BEQ	COLIS		;YES, ALLOW CRUNCHING AGAIN.
0023D4  1  C9 49        	CMP	#DATATK-':'	;IS IT A DATATK?
0023D6  1  D0 02        	BNE	NODATT		;NO, SEE IF IT IS REM TOKEN.
0023D8  1  85 13        COLIS:	STA	DORES		;SETUP FLAG.
0023DA  1  38           NODATT: SEC			;PREP TO SBCQ
0023DB  1  E9 54        	SBC	#REMTK-':'	;REM ONLY STOPS ON NULL.
0023DD  1  D0 AA        	BNE	KLOOP		;NO, CONTINUE CRUNCHING.
0023DF  1  85 0E        	STA	ENDCHR		;REM STOPS ONLY ON NULL, NOT : OR ".
0023E1  1  B5 00        STR1:	LDA	BUFOFS,X
0023E3  1  F0 E0        	BEQ	STUFFH		;YES, END OF LINE, SO DONE.
0023E5  1  C5 0E        	CMP	ENDCHR		;END OF GOBBLE?
0023E7  1  F0 DC        	BEQ	STUFFH		;YES, DONE WITH STRING.
0023E9  1  C8           STRNG:	INY			;INCREMENT BUFFER POINTER.
0023EA  1  99 18 00     	STA	BUF-5,Y
0023ED  1  E8           	INX
0023EE  1  D0 F1        	BNE	STR1		;PROCESS NEXT CHARACTER.
0023F0  1  A6 C9        NTHIS:	LDX	TXTPTR		;RESTORE TEXT POINTER.
0023F2  1  E6 0F        	INC	COUNT		;INCREMENT RES WORD COUNT.
0023F4  1  C8           NTHIS1: INY
0023F5  1  B9 83 20     	LDA	RESLST-1,Y 	;GET RES CHARACTER.
0023F8  1  10 FA        	BPL	NTHIS1		;END OF ENTRY?
0023FA  1  B9 84 20     	LDA	RESLST,Y 	;YES. IS IT THE END?
0023FD  1  D0 B6        	BNE	RESCON		;NO, TRY THE NEXT WORD.
0023FF  1  B5 00        	LDA	BUFOFS,X	;YES, END OF TABLE. GET 1ST CHR.
002401  1  10 C0        	BPL	GETBPT		;STORE IT AWAY (ALWAYS BRANCHES).
002403  1  99 1A 00     CRDONE: STA	BUF-3,Y 	;SO THAT IF THIS IS A DIR STATEMENT
002406  1               				;ITS END WILL LOOK LIKE END OF PROGRAM.
002406  1               .IF	((BUF+BUFLEN)/256)-((BUF-1)/256) <> 0
002406  1               	DEC	TXTPTR+1
002406  1               .ENDIF
002406  1               ;	LDAI	(BUF&255)-1	;LGB - the original line
002406  1  A9 1C        	LDA	#.LOBYTE(BUF-1)	;MAKE TXTPTR POINT TO
002408  1  85 C9        	STA	TXTPTR		;CRUNCHED LINE.
00240A  1  60           LISTRT: RTS			;RETURN TO CALLER.
00240B  1               ;
00240B  1               ; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
00240B  1               ; WHOSE NUMBER IS PASSED IN "LINNUM".
00240B  1               ; THERE ARE TWO POSSIBLE RETURNS:
00240B  1               ;
00240B  1               ;	1) CARRY SET.
00240B  1               ;	   LOWTR POINTS TO THE LINK FIELD IN THE LINE
00240B  1               ;	   WHICH IS THE ONE SEARCHED FOR.
00240B  1               ;
00240B  1               ;	2) CARRY NOT SET.
00240B  1               ;	   LINE NOT FOUND. [LOWTR] POINTS TO THE LINE IN THE
00240B  1               ;	   PROGRAM GREATER THAN THE ONE SOUGHT AFTER.
00240B  1               ;
00240B  1  A5 7A A6 7B  FNDLIN: LDWX	TXTTAB		;LOAD [X,A] WITH [TXTTAB]
00240F  1  A0 01        FNDLNC: LDY	#1
002411  1  85 AE 86 AF  	STWX	LOWTR		;STORE [X,A] INTO LOWTR
002415  1  B1 AE        	LDADY	LOWTR		;SEE IF LINK IS 0
002417  1  F0 1F        	BEQ	FLINRT
002419  1  C8           	INY
00241A  1  C8           	INY
00241B  1  A5 1C        	LDA	LINNUM+1	;COMP HIGH ORDERS OF LINE NUMBERS.
00241D  1  D1 AE        	CMPDY	LOWTR
00241F  1  90 18        	BCC	FLNRTS		;NO SUCH LINE NUMBER.
002421  1  F0 03        	BEQ	FNDLO1
002423  1  88           	DEY
002424  1  D0 09        	BNE	AFFRTS		;ALWAYS BRANCH.
002426  1  A5 1B        FNDLO1: LDA	LINNUM
002428  1  88           	DEY
002429  1  D1 AE        	CMPDY	LOWTR		;COMPARE LOW ORDERS.
00242B  1  90 0C        	BCC	FLNRTS		;NO SUCH NUMBER.
00242D  1  F0 0A        	BEQ	FLNRTS		;GO TIT.
00242F  1  88           AFFRTS: DEY
002430  1  B1 AE        	LDADY	LOWTR		;FETCH LINK.
002432  1  AA           	TAX
002433  1  88           	DEY
002434  1  B1 AE        	LDADY	LOWTR
002436  1  B0 D7        	BCS	FNDLNC		;ALWAYS BRANCHES.
002438  1  18           FLINRT: CLC			;C MAY BE HIGH.
002439  1  60           FLNRTS: RTS			;RETURN TO CALLER.
00243A  1               ;
00243A  1               ; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
00243A  1               ; AS VARIABLE SPACE.
00243A  1               ;
00243A  1  D0 FD        SCRATH: BNE	FLNRTS		;MAKE SURE THERE IS A TERMINATOR.
00243C  1  A9 00        SCRTCH: LDA	#0		;GET A CLEARER.
00243E  1  A8           	TAY			;SET UP INDEX.
00243F  1  91 7A        	STADY	TXTTAB		;CLEAR	FIRST LINK.
002441  1  C8           	INY
002442  1  91 7A        	STADY	TXTTAB
002444  1  A5 7A        	LDA	TXTTAB
002446  1  18           	CLC
002447  1  69 02        	ADC	#2
002449  1  85 7C        	STA	VARTAB		;SETUP [VARTAB].
00244B  1  A5 7B        	LDA	TXTTAB+1
00244D  1  69 00        	ADC	#0
00244F  1  85 7D        	STA	VARTAB+1
002451  1  20 83 24     RUNC:	JSR	STXTPT
002454  1  A9 00        	LDA	#0		;SET ZERO FLAG
002456  1               ;
002456  1               ; THIS CODE IS FOR THE CLEAR COMMAND.
002456  1               ;
002456  1  D0 2A        CLEAR:	BNE	STKRTS		;SYNTAX ERROR IF NO TERMINATOR.
002458  1               ;
002458  1               ; CLEAR INITIALIZES THE VARIABLE AND
002458  1               ; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
002458  1               ; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO "STKINI"
002458  1               ; WHICH RESETS THE STACK.
002458  1               ;
002458  1  A5 86 A4 87  CLEARC: LDWD	MEMSIZ		;FREE UP STRING SPACE.
00245C  1  85 82 84 83  	STWD	FRETOP
002460  1               .IF	EXTIO <> 0
002460  1               	JSR	CQCALL		;CLOSE ALL OPEN FILES.
002460  1               .ENDIF
002460  1  A5 7C A4 7D  	LDWD	VARTAB		;LIBERATE THE
002464  1  85 7E 84 7F  	STWD	ARYTAB		;VARIABLES AND
002468  1  85 80 84 81  	STWD	STREND		;ARRAYS.
00246C  1  20 EF 25     FLOAD:	JSR	RESTOR		;RESTORE DATA.
00246F  1               ;
00246F  1               ; STKINI RESETS THE STACK POINTER ELIMINATING
00246F  1               ; GOSUB AND FOR CONTEXT. STRING TEMPORARIES ARE FREED
00246F  1               ; UP, SUBFLG IS RESET. CONTINUING IS PROHIBITED.
00246F  1               ; AND A DUMMY ENTRY IS LEFT AT THE BOTTOM OF THE STACK SO "FNDFOR" WILL ALWAYS
00246F  1               ; FIND A NON-"FOR" ENTRY AT THE BOTTOM OF THE STACK.
00246F  1               ;
00246F  1  A2 68        STKINI: LDX	#TEMPST		;INITIALIZE STRING TEMPORARIES.
002471  1  86 65        	STX	TEMPPT
002473  1  68           	PLA			;SETUP RETURN ADDRESS.
002474  1  A8           	TAY
002475  1  68           	PLA
002476  1  A2 FE        	LDX	#STKEND-257
002478  1  9A           	TXS
002479  1  48           	PHA
00247A  1  98           	TYA
00247B  1  48           	PHA
00247C  1  A9 00        	LDA	#0
00247E  1  85 8D        	STA	OLDTXT+1	;DISALLOWING CONTINUING
002480  1  85 14        	STA	SUBFLG		;ALLOW SUBSCRIPTS.
002482  1  60           STKRTS: RTS
002483  1               
002483  1  18           STXTPT: CLC
002484  1  A5 7A        	LDA	TXTTAB
002486  1  69 FF        	ADC	#255
002488  1  85 C9        	STA	TXTPTR
00248A  1  A5 7B        	LDA	TXTTAB+1
00248C  1  69 FF        	ADC	#255
00248E  1  85 CA        	STA	TXTPTR+1	;SETUP TEXT POINTER.
002490  1  60           	RTS
002491  1               ; PAGE
002491  1               ; SUBTTL	THE "LIST" COMMAND.
002491  1               
002491  1  90 06        LIST:	BCC	GOLST		;IT IS A DIGIT.
002493  1  F0 04        	BEQ	GOLST		;IT IS A TERMINATOR.
002495  1  C9 A4        	CMP	#MINUTK		;DASH PRECEDING?
002497  1  D0 E9        	BNE	STKRTS		;NO, SO SYNTAX ERROR.
002499  1  20 3E 27     GOLST:	JSR	LINGET		;GET LINE NUMBER INTO NUMLIN.
00249C  1  20 0B 24     	JSR	FNDLIN		;FIND LINE .GE. [NUMLIN].
00249F  1  20 C8 00     	JSR	CHRGOT		;GET LAST CHARACTER.
0024A2  1  F0 0C        	BEQ	LSTEND		;IF END OF LINE, # IS THE END.
0024A4  1  C9 A4        	CMP	#MINUTK		;DASH?
0024A6  1  D0 91        	BNE	FLNRTS		;IF NOT, SYNTAX ERROR.
0024A8  1  20 C2 00     	JSR	CHRGET		;GET NEXT CHAR.
0024AB  1  20 3E 27     	JSR	LINGET		;GET END #.
0024AE  1  D0 89        	BNE	FLNRTS		;IF NOT TERMINATOR, ERROR.
0024B0  1  68           LSTEND: PLA
0024B1  1  68           	PLA			;GET RID OF "NEWSTT" RTS ADDR.
0024B2  1  A5 1B        	LDA	LINNUM		;SEE IF IT WAS EXISTENT.
0024B4  1  05 1C        	ORA	LINNUM+1
0024B6  1  D0 06        	BNE	LIST4		;IT WAS TYPED.
0024B8  1  A9 FF        	LDA	#255
0024BA  1  85 1B        	STA	LINNUM
0024BC  1  85 1C        	STA	LINNUM+1	;MAKE IT HUGE.
0024BE  1  A0 01        LIST4:	LDY	#1
0024C0  1               .IF	REALIO-3 = 0
0024C0  1               	STY	DORES
0024C0  1               .ENDIF
0024C0  1  B1 AE        	LDADY	LOWTR		;IS LINK ZERO?
0024C2  1  F0 36        	BEQ	GRODY		;YES, GO TO READY.
0024C4  1               .IF	REALIO <> 0
0024C4  1               	JSR	ISCNTC		;LISTEN FOR CONT-C.
0024C4  1               .ENDIF
0024C4  1  20 45 28     	JSR	CRDO		;PRINT CRLF TO START WITH.
0024C7  1  C8           	INY
0024C8  1  B1 AE        	LDADY	LOWTR
0024CA  1  AA           	TAX
0024CB  1  C8           	INY
0024CC  1  B1 AE        	LDADY	LOWTR		;GET LINE NUMBER.
0024CE  1  C5 1C        	CMP	LINNUM+1	;SEE IF BEYOND LAST.
0024D0  1  D0 04        	BNE	TSTDUN		;GO DETERMINE RELATION.
0024D2  1  E4 1B        	CPX	LINNUM		;WAS EQUAL SO TEST LOW ORDER.
0024D4  1  F0 02        	BEQ	TYPLIN		;EQUAL, SO LIST IT.
0024D6  1  B0 22        TSTDUN: BCS	GRODY		;IF LINE IS GR THAN LAST, THEN DUNE.
0024D8  1  84 98        TYPLIN: STY	LSTPNT
0024DA  1  20 4C 3A     	JSR	LINPRT		;PRINT AS INT WITHOUT LEADING SPACE.
0024DD  1  A9 20        	LDA	#' '		;ALWAYS PRINT SPACE AFTER NUMBER.
0024DF  1  A4 98        PRIT4:	LDY	LSTPNT		;GET POINTER TO LINE BACK.
0024E1  1  29 7F        	AND	#127
0024E3  1  20 BD 28     PLOOP:	JSR	OUTDO		;PRINT CHAR.
0024E6  1               .IF	REALIO-3 = 0
0024E6  1               	CMP	#34
0024E6  1               	BNE	PLOOP1
0024E6  1               	COM	DORES		;IF QUOTE, COMPLEMENT FLAG.
0024E6  1               .ENDIF
0024E6  1  C8           PLOOP1: INY
0024E7  1  F0 11        	BEQ	GRODY		;IF WE HAVE PRINTED 256 CHARACTERS
0024E9  1               				;THE PROGRAM MUST BE MISFORMATED IN
0024E9  1               				;MEMORY DUE TO A BAD LOAD OR BAD
0024E9  1               				;HARDWARE. LET THE GUY RECOVER
0024E9  1  B1 AE        	LDADY	LOWTR		;GET NEXT CHAR. IS IT ZERO?
0024EB  1  D0 10        	BNE	QPLOP		;YES. END OF LINE.
0024ED  1  A8           	TAY
0024EE  1  B1 AE        	LDADY	LOWTR
0024F0  1  AA           	TAX
0024F1  1  C8           	INY
0024F2  1  B1 AE        	LDADY	LOWTR
0024F4  1  86 AE        	STX	LOWTR
0024F6  1  85 AF        	STA	LOWTR+1
0024F8  1  D0 C4        	BNE	LIST4		;BRANCH IF SOMETHING TO LIST.
0024FA  1  4C 72 22     GRODY:	JMP	READY
0024FD  1               				;IS IT A TOKEN?
0024FD  1  10 E4        QPLOP:	BPL	PLOOP		;NO, HEAD FOR PRINTER.
0024FF  1               .IF	REALIO-3 = 0
0024FF  1               	CMP	#PI
0024FF  1               	BEQ	PLOOP
0024FF  1               	BIT	DORES		;INSIDE QUOTE MARKS?
0024FF  1               	BMI	PLOOP		;YES, JUST TYPE THE CHARACTER.
0024FF  1               .ENDIF
0024FF  1  38           	SEC
002500  1  E9 7F        	SBC	#127		;GET RID OF SIGN BIT AND ADD 1.
002502  1  AA           	TAX			;MAKE IT A COUNTER.
002503  1  84 98        	STY	LSTPNT		;SAVE POINTER TO LINE.
002505  1  A0 FF        	LDY	#255		;LOOK AT RES'D WORD LIST.
002507  1  CA           RESRCH: DEX			;IS THIS THE RES'D WORD?
002508  1  F0 08        	BEQ	PRIT3		;YES, GO TOSS IT UP..
00250A  1  C8           RESCR1: INY
00250B  1  B9 84 20     	LDA	RESLST,Y 	;END OF ENTRY?
00250E  1  10 FA        	BPL	RESCR1		;NO, CONTINUE PASSING.
002510  1  30 F5        	BMI	RESRCH
002512  1  C8           PRIT3:	INY
002513  1  B9 84 20     	LDA	RESLST,Y
002516  1  30 C7        	BMI	PRIT4		;END OF RESERVED WORD.
002518  1  20 BD 28     	JSR	OUTDO		;PRINT IT.
00251B  1  D0 F5        	BNE	PRIT3		;END OF ENTRY? NO, TYPE REST.
00251D  1               ; PAGE
00251D  1               ; SUBTTL THE "FOR" STATEMENT.
00251D  1               ;
00251D  1               ; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
00251D  1               ;
00251D  1               ; LOW ADDRESS
00251D  1               ;	TOKEN (FORTK) 1 BYTE
00251D  1               ;	A POINTER TO THE LOOP VARIABLE 2 BYTES
00251D  1               ;	THE STEP 4+ADDPRC BYTES
00251D  1               ;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
00251D  1               ;	THE UPPER VALUE 4+ADDPRC BYTES
00251D  1               ;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
00251D  1               ;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
00251D  1               ; HIGH ADDRESS
00251D  1               ;
00251D  1               ; TOTAL 16+2*ADDPRC BYTES.
00251D  1               ;
00251D  1               
00251D  1  A9 80        FOR:	LDA	#128		;DON'T RECOGNIZE
00251F  1  85 14        	STA	SUBFLG		;SUBSCRIPTED VARIABLES.
002521  1  20 78 27     	JSR	LET		;READ THE VARIABLE AND ASSIGN IT
002524  1               				;THE CORRECT INITIAL VALUE AND STORE
002524  1               				;A POINTER TO THE VARIABLE IN VARPNT.
002524  1  20 A1 21     	JSR	FNDFOR		;PNTR IS IN VARPNT, AND FORPNT.
002527  1  D0 05        	BNE	NOTOL		;IF NO MATCH, DON'T ELIMINATE ANYTHING.
002529  1  8A           	TXA			;MAKE IT ARITHMETICAL.
00252A  1  69 0F        	ADC	#FORSIZ-3	;ELIMINATE ALMOST ALL.
00252C  1  AA           	TAX			;NOTE C=1, THEN PLA, PLA.
00252D  1  9A           	TXS			;MANIFEST.
00252E  1  68           NOTOL:	PLA			;GET RID OF NEWSTT RETURN ADDRESS
00252F  1  68           	PLA			;IN CASE THIS IS A TOTALLY NEW ENTRY.
002530  1  A9 09        	LDA	#8+ADDPRC
002532  1  20 12 22     	JSR	GETSTK		;MAKE SURE 16 BYTES ARE AVAILABLE.
002535  1  20 D9 26     	JSR	DATAN		;GET A COUNT IN [Y] OF THE NUMBER OF
002538  1               				;CHACRACTERS LEFT IN THE "FOR" STATEMENT
002538  1               				;[TXTPTR] IS UNAFFECTED.
002538  1  18           	CLC			;PREP TO ADD.
002539  1  98           	TYA			;SAVE IT FOR PUSHING.
00253A  1  65 C9        	ADC	TXTPTR
00253C  1  48           	PHA
00253D  1  A5 CA        	LDA	TXTPTR+1
00253F  1  69 00        	ADC	#0
002541  1  48           	PHA
002542  1  A5 89 48 A5  	PSHWD	CURLIN		;PUT LINE NUMBER ON STACK.
002546  1  88 48        
002548  1  A9 9D 20 06  	SYNCHK	TOTK		;"TO" IS NECESSARY.
00254C  1  2C           
00254D  1  20 AD 2A     	JSR	CHKNUM		;VALUE MUST BE A NUMBER.
002550  1  20 AA 2A     	JSR	FRMNUM		;GET UPPER VALUE INTO FAC.
002553  1  A5 B5        	LDA	FACSGN		;PACK FAC.
002555  1  09 7F        	ORA	#127
002557  1  25 B1        	AND	FACHO
002559  1  85 B1        	STA	FACHO		;SET PACKED SIGN BIT.
00255B  1  A9 66 A0 25  	LDWDI	LDFONE
00255F  1  85 71 84 72  	STWD	INDEX1
002563  1  4C 63 2B     	JMP	FORPSH		;PUT FAC ONTO STACK, PACKED.
002566  1  A9 3B A0 36  LDFONE: LDWDI	FONE		;PUT 1.0 INTO FAC.
00256A  1  20 21 38     	JSR	MOVFM
00256D  1  20 C8 00     	JSR	CHRGOT
002570  1  C9 A2        	CMP	#STEPTK		;A STEP IS GIVEN?
002572  1  D0 06        	BNE	ONEON		;NO. ASSUME 1.0.
002574  1  20 C2 00     	JSR	CHRGET		;YES. ADVANCE POINTER.
002577  1  20 AA 2A     	JSR	FRMNUM		;READ THE STEP.
00257A  1  20 AA 38     ONEON:	JSR	SIGN		;GET SIGN IN ACCA.
00257D  1  20 58 2B     	JSR	PUSHF		;PUSH FAC ONTO STACK (THRU A).
002580  1  A5 99 48 A5  	PSHWD	FORPNT		;PUT PNTR TO VARIABLE ON STACK.
002584  1  98 48        
002586  1  A9 81        NXTCON: LDA	#FORTK		;PUT A FORTK ONTO STACK.
002588  1  48           	PHA
002589  1               ;	BNEA	NEWSTT		;SIMULATE BNE TO NEWSTT. JUST FALL IN.
002589  1               ; PAGE
002589  1               ; SUBTTL	NEW STATEMENT FETCHER.
002589  1               ;
002589  1               ; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY TXTPTR
002589  1               ; IS ":" OR END-OF-LINE. THE ADDRESS OF THIS LOC IS LEFT
002589  1               ; ON THE STACK WHEN A STATEMENT IS EXECUTED SO THAT
002589  1               ; IT CAN MERELY DO A RTS WHEN IT IS DONE.
002589  1               ;
002589  1               NEWSTT:
002589  1               .IF	REALIO <> 0
002589  1               	JSR	ISCNTC		;LISTEN FOR CONTROL-C.
002589  1               .ENDIF
002589  1  A5 C9 A4 CA  	LDWD	TXTPTR		;LOOK AT CURRENT CHARACTER.
00258D  1               .IF	BUFPAG <> 0
00258D  1               	CPY	#BUFPAG		;SEE IF IT WAS DIRECT BY CHECK FOR BUF'S PAGE NUMBER
00258D  1               .ENDIF
00258D  1  F0 06        	BEQ	DIRCON
00258F  1  85 8C 84 8D  	STWD	OLDTXT		;SAVE IN CASE OF RESTART BY INPUT.
002593  1               .IF	BUFPAG <> 0
002593  1               DIRCON:
002593  1               .ENDIF
002593  1  A0 00        	LDY	#0
002595  1               .IF	BUFPAG = 0
002595  1               DIRCON:
002595  1               .ENDIF
002595  1  B1 C9        	LDADY	TXTPTR
002597  1  D0 40        	BNE	MORSTS		;NOT NULL -- CHECK WHAT IT IS
002599  1  A0 02        	LDY	#2		;LOOK AT LINK.
00259B  1  B1 C9        	LDADY	TXTPTR		;IS LINK 0?
00259D  1  18           	CLC		;CLEAR CARRY FOR ENDCON AND MATH THAT FOLLOWS
00259E  1  D0 03 4C 17  	JEQ	ENDCON		;YES - RAN OFF THE END.
0025A2  1  26           
0025A3  1  C8           	INY			;PUT LINE NUMBER IN CURLIN.
0025A4  1  B1 C9        	LDADY	TXTPTR
0025A6  1  85 88        	STA	CURLIN
0025A8  1  C8           	INY
0025A9  1  B1 C9        	LDADY	TXTPTR
0025AB  1  85 89        	STA	CURLIN+1
0025AD  1  98           	TYA
0025AE  1  65 C9        	ADC	TXTPTR
0025B0  1  85 C9        	STA	TXTPTR
0025B2  1  90 02        	BCC	GONE
0025B4  1  E6 CA        	INC	TXTPTR+1
0025B6  1  20 C2 00     GONE:	JSR	CHRGET		;GET THE STATEMENT TYPE.
0025B9  1  20 BF 25     	JSR	GONE3
0025BC  1  4C 89 25     	JMP	NEWSTT
0025BF  1  F0 3C        GONE3:	BEQ	ISCRTS		;IF TERMINATOR, TRY AGAIN.
0025C1  1               				;NO NEED TO SET UP CARRY SINCE IT WILL
0025C1  1               				;BE ON IF NON-NUMERIC AND NUMERICS
0025C1  1               				;WILL CAUSE A SYNTAX ERROR LIKE THEY SHOULD
0025C1  1  E9 80        GONE2:	SBC	#ENDTK		;" ON ... GOTO AND GOSUB" COME HERE.
0025C3  1  90 11        	BCC	GLET
0025C5  1  C9 1C        	CMP	#SCRATK-ENDTK+1
0025C7  1  B0 17        	BCS	SNERRX		;SOME RES'D WORD BUT NOT
0025C9  1               				;A STATEMENT RES'D WORD.
0025C9  1  0A           	ASL	A 		;MULTIPLY BY TWO.
0025CA  1  A8           	TAY			;MAKE AN INDEX.
0025CB  1  B9 01 20     	LDA	STMDSP+1,Y
0025CE  1  48           	PHA
0025CF  1  B9 00 20     	LDA	STMDSP,Y
0025D2  1  48           	PHA			;PUT DISP ADDR ONTO STACK.
0025D3  1  4C C2 00     	JMP	CHRGET
0025D6  1  4C 78 27     GLET:	JMP	LET		;MUST BE A LET
0025D9  1  C9 3A        MORSTS: CMP	#':'
0025DB  1  F0 D9        	BEQ	GONE		;IF A ":" CONTINUE STATEMENT
0025DD  1  4C 0F 2C     SNERR1: JMP	SNERR		;NEITHER 0 OR ":" SO SYNTAX ERROR
0025E0  1  C9 44        SNERRX: CMP	#GOTK-ENDTK
0025E2  1  D0 F9        	BNE	SNERR1
0025E4  1  20 C2 00     	JSR	CHRGET		;READ IN THE CHARACTER AFTER "GO "
0025E7  1  A9 9D 20 06  	SYNCHK	TOTK
0025EB  1  2C           
0025EC  1  4C 78 26     	JMP	GOTO
0025EF  1               ; PAGE
0025EF  1               ; SUBTTL	RESTORE,STOP,END,CONTINUE,NULL,CLEAR.
0025EF  1               
0025EF  1  38           RESTOR: SEC
0025F0  1  A5 7A        	LDA	TXTTAB
0025F2  1  E9 01        	SBC	#1
0025F4  1  A4 7B        	LDY	TXTTAB+1
0025F6  1  B0 01        	BCS	RESFIN
0025F8  1  88           	DEY
0025F9  1  85 90 84 91  RESFIN: STWD	DATPTR		;READ FINISHES COME TO "RESFIN".
0025FD  1  60           ISCRTS: RTS
0025FE  1               
0025FE  1               .IF	REALIO-1 = 0
0025FE  1               ISCNTC: LDA	#1
0025FE  1               	BIT	$1740
0025FE  1               	BMI	ISCRTS
0025FE  1               	LDX	#8
0025FE  1               	LDA	#3
0025FE  1               	CMP	#3
0025FE  1               .ENDIF
0025FE  1               .IF	REALIO-2 = 0
0025FE  1               ISCNTC: LDA	$FC00
0025FE  1               	REPEAT	4,{NOP}
0025FE  1               	LSR	A
0025FE  1               	BCC	ISCRTS
0025FE  1               	JSR	INCHR		;EAT CHAR THAT WAS TYPED
0025FE  1               	CMP	#3		;WAS IT A CONTROL-C??
0025FE  1               .ENDIF
0025FE  1               
0025FE  1               .IF	REALIO-4 = 0
0025FE  1               ISCNTC: LDA	$C000	;CHECK THE CHARACTER
0025FE  1               	CMP	#$83
0025FE  1               	BEQ	ISCCAP
0025FE  1               	RTS
0025FE  1               ISCCAP: JSR	INCHR
0025FE  1               	CMP	#$83
0025FE  1               .ENDIF
0025FE  1  B0 01        STOP:	BCS	STOPC		;MAKE [C] NONZERO AS A FLAG.
002600  1  18           END:	CLC
002601  1  D0 3B        STOPC:	BNE	CONTRT		;RETURN IF NOT CONT-C OR
002603  1               				;IF NO TERMINATOR FOR STOP OR END.
002603  1               				;[C]=0 SO WILL NOT PRINT "BREAK".
002603  1  A5 C9 A4 CA  	LDWD	TXTPTR
002607  1               .IF	BUFPAG <> 0
002607  1               	LDX	CURLIN+1
002607  1               	INX
002607  1               .ENDIF
002607  1  F0 0C        	BEQ	DIRIS
002609  1  85 8C 84 8D  	STWD	OLDTXT
00260D  1  A5 88 A4 89  STPEND: LDWD	CURLIN
002611  1  85 8A 84 8B  	STWD	OLDLIN
002615  1  68           DIRIS:	PLA			;POP OFF NEWSTT ADDR.
002616  1  68           	PLA
002617  1  A9 99 A0 21  ENDCON: LDWDI	BRKTXT
00261B  1               .IF	REALIO <> 0
00261B  1               	LDX	#0
00261B  1               	STX	CNTWFL
00261B  1               .ENDIF
00261B  1  90 03        	BCC	GORDY		;CARRY CLEAR SO DON'T PRINT "BREAK".
00261D  1  4C 67 22     	JMP	ERRFIN
002620  1  4C 72 22     GORDY:	JMP	READY		;TYPE "READY".
002623  1               
002623  1               .IF	REALIO = 0
002623  1  68           DDT:	PLA			;GET RID OF NEWSTT RETURN.
002624  1  68           	PLA
002625  1               	;HRRZ	14,.JBDDT##	;LGB
002625  1               	;JRST	0(14)		;LGB
002625  1               .ENDIF
002625  1  D0 17        CONT:	BNE	CONTRT		;MAKE SURE THERE IS A TERMINATOR.
002627  1  A2 1E        	LDX	#ERRCN		;CONTINUE ERROR.
002629  1  A4 8D        	LDY	OLDTXT+1	;A STORED TXTPTR OF ZERO IS SETUP
00262B  1               				;BY STKINI AND INDICATES THERE IS
00262B  1               				;NOTHING TO CONTINUE.
00262B  1  D0 03 4C 4E  	JEQ	ERROR		;"STOP", "END", TYPING CRLF TO
00262F  1  22           
002630  1               				;"INPUT" AND  ^C SETUP OLDTXT.
002630  1  A5 8C        	LDA	OLDTXT
002632  1  85 C9 84 CA  	STWD	TXTPTR
002636  1  A5 8A A4 8B  	LDWD	OLDLIN
00263A  1  85 88 84 89  	STWD	CURLIN
00263E  1  60           CONTRT: RTS			;RETURN TO CALLER.
00263F  1               
00263F  1               .IF	NULCMD <> 0
00263F  1  20 1C 34     NULL:	JSR	GETBYT
002642  1  D0 FA        	BNE	CONTRT		;MAKE SURE THERE IS TERMINATOR.
002644  1  E8           	INX
002645  1  E0 F0        	CPX	#240		;IS THE NUMBER REASONABLE?
002647  1  B0 04        	BCS	FCERR1		;"FUNCTION CALL" ERROR.
002649  1  CA           	DEX			;BACK -1
00264A  1  86 17        	STX	NULCNT
00264C  1  60           	RTS
00264D  1  4C C6 2E     FCERR1: JMP	FCERR
002650  1               .ENDIF
002650  1               ; PAGE
002650  1               ; SUBTTL	LOAD AND SAVE SUBROUTINES.
002650  1               
002650  1               .IF	REALIO-1 = 0		;KIM CASSETTE I/O
002650  1               SAVE:	TSX			;SAVE STACK POINTER
002650  1               	STX	INPFLG
002650  1               	LDA	#STKEND-256-200
002650  1               	STA	$F2		;SETUP DUMMY STACK FOR KIM MONITOR
002650  1               	LDA	#254		;MAKE ID BYTE EQUAL TO FF HEX
002650  1               	STA	$17F9		;STORE INTO KIM ID
002650  1               	LDWD	TXTTAB		;START DUMPING FROM TXTTAB
002650  1               	STWD	$17F5		;SETUP SAL,SAH
002650  1               	LDWD	VARTAB		;STOP AT VARTAB
002650  1               	STWD	$17F7		;SETUP EAL,EAH
002650  1               	JMP	$1800
002650  1               RETSAV: LDX	INPFLG		;RESORE THE REAL STACK POINTER
002650  1               	TXS
002650  1               	LDWDI	TAPMES		;SAY IT WAS DONE
002650  1               	JMP	STROUT
002650  1               GLOAD:	DT"LOADED"
002650  1               .BYTE	0
002650  1               TAPMES: DT"SAVED"
002650  1               	ACRLF
002650  1               .BYTE	0
002650  1               PATSAV: BLOCK 20
002650  1               LOAD:	LDWD	TXTTAB		;START DUMPING IN AT TXTTAB
002650  1               	STWD	$17F5		;SETUP SAL,SAH
002650  1               	LDA	#255
002650  1               	STA	$17F9
002650  1               	LDWDI	RTLOAD
002650  1               	STWD	$1		;SET UP RETURN ADDRESS FOR LOAD
002650  1               	JMP	$1873		;GO READ THE DATA IN
002650  1               RTLOAD: LDX	#STKEND-256		;RESET THE STACK
002650  1               	TXS
002650  1               	LDWDI	READY
002650  1               	STWD	$1
002650  1               	LDWDI	GLOAD		;TELL HIM IT WORKED
002650  1               	JSR	STROUT
002650  1               	LDXY	$17ED		;GET LAST LOCATION
002650  1               	TXA			;ITS ONE TOO BIG
002650  1               	BNE	DECVRT		;DECREMENT [X,Y]
002650  1               	NOP
002650  1               DECVRT: NOP
002650  1               	STXY	VARTAB		;SETUP NEW VARIABLE LOCATION
002650  1               	JMP	FINI		;RELINK THE PROGRAM
002650  1               .ENDIF
002650  1               .IF	REALIO-4 = 0
002650  1               SAVE:	SEC			;CALCLUATE PROGRAM SIZE IN POKER
002650  1               	LDA	VARTAB
002650  1               	SBC	TXTTAB
002650  1               	STA	POKER
002650  1               	LDA	VARTAB+1
002650  1               	SBC	TXTTAB+1
002650  1               	STA	POKER+1
002650  1               	JSR	VARTIO
002650  1               	JSR	CQCOUT		;WRITE PROGRAM SIZE [POKER]
002650  1               	JSR	PROGIO
002650  1               	JMP	CQCOUT		;WRITE PROGRAM.
002650  1               
002650  1               LOAD:	JSR	VARTIO
002650  1               	JSR	CQCSIN		;READ SIZE OF PROGRAM INTO POKER
002650  1               	CLC
002650  1               	LDA	TXTTAB		;CALCULATE VARTAB FROM SIZE AND
002650  1               	ADC	POKER		;TXTTAB
002650  1               	STA	VARTAB
002650  1               	LDA	TXTTAB+1
002650  1               	ADC	POKER+1
002650  1               	STA	VARTAB+1
002650  1               	JSR	PROGIO
002650  1               	JSR	CQCSIN		;READ PROGRAM.
002650  1               	LDWDI	TPDONE
002650  1               	JSR	STROUT
002650  1               	JMP	FINI
002650  1               
002650  1               TPDONE: DT"LOADED"
002650  1               .BYTE	0
002650  1               
002650  1               VARTIO: LDWDI	POKER
002650  1               	STWD	$3C
002650  1               	LDA	#POKER+2
002650  1               	STWD	$3E
002650  1               	RTS
002650  1               PROGIO: LDWD	TXTTAB
002650  1               	STWD	$3C
002650  1               	LDWD	VARTAB
002650  1               	STWD	$3E
002650  1               	RTS
002650  1               .ENDIF
002650  1               ; PAGE
002650  1               ; SUBTTL	RUN,GOTO,GOSUB,RETURN.
002650  1  D0 03 4C 51  RUN:	JEQ	RUNC		;IF NO LINE # ARGUMENT.
002654  1  24           
002655  1  20 58 24     	JSR	CLEARC		;CLEAN UP -- RESET THE STACK.
002658  1  4C 6F 26     	JMP	RUNC2		;MUST REPLACE RTS ADDR.
00265B  1               ;
00265B  1               ; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
00265B  1               ;
00265B  1               ; LOW ADDRESS:
00265B  1               ;	THE GOSUTK ONE BYTE
00265B  1               ;	THE LINE NUMBER OF THE GOSUB STATEMENT TWO BYTES
00265B  1               ;	A POINTER INTO THE TEXT OF THE GOSUB TWO BYTES
00265B  1               ;
00265B  1               ; HIGH ADDRESS.
00265B  1               ;
00265B  1               ; TOTAL FIVE BYTES.
00265B  1               ;
00265B  1  A9 03        GOSUB:	LDA	#3
00265D  1  20 12 22     	JSR	GETSTK		;MAKE SURE THERE IS ROOM.
002660  1  A5 CA 48 A5  	PSHWD	TXTPTR		;PUSH ON THE TEXT POINTER.
002664  1  C9 48        
002666  1  A5 89 48 A5  	PSHWD	CURLIN		;PUSH ON THE CURRENT LINE NUMBER.
00266A  1  88 48        
00266C  1  A9 8C        	LDA	#GOSUTK
00266E  1  48           	PHA			;PUSH ON A GOSUB TOKEN.
00266F  1  20 C8 00     RUNC2:	JSR	CHRGOT		;GET CHARACTER AND SET CODES FOR LINGET.
002672  1  20 78 26     	JSR	GOTO		;USE RTS SCHEME TO "NEWSTT".
002675  1  4C 89 25     	JMP	NEWSTT
002678  1               
002678  1  20 3E 27     GOTO:	JSR	LINGET		;PICK UP THE LINE NUMBER IN "LINNUM".
00267B  1  20 DC 26     	JSR	REMN		;SKIP TO END OF LINE.
00267E  1  A5 89        	LDA	CURLIN+1
002680  1  C5 1C        	CMP	LINNUM+1
002682  1  B0 0B        	BCS	LUK4IT
002684  1  98           	TYA
002685  1  38           	SEC
002686  1  65 C9        	ADC	TXTPTR
002688  1  A6 CA        	LDX	TXTPTR+1
00268A  1  90 07        	BCC	LUKALL
00268C  1  E8 B0 04     	INX
00268F  1               	BCSA	LUKALL		;ALWAYS GOES.
00268F  1  A5 7A A6 7B  LUK4IT: LDWX	TXTTAB
002693  1  20 0F 24     LUKALL: JSR	FNDLNC		;[X,A] ARE ALL SET UP.
002696  1  90 1E        QFOUND: BCC	USERR		;GOTO LINE IS NONEXISTANT.
002698  1  A5 AE        	LDA	LOWTR
00269A  1  E9 01        	SBC	#1
00269C  1  85 C9        	STA	TXTPTR
00269E  1  A5 AF        	LDA	LOWTR+1
0026A0  1  E9 00        	SBC	#0
0026A2  1  85 CA        	STA	TXTPTR+1
0026A4  1  60           GORTS:	RTS			;PROCESS THE STATEMENT.
0026A5  1               ;
0026A5  1               ; "RETURN" RESTORES THE LINE NUMBER AND TEXT PNTR FROM THE STACK
0026A5  1               ; AND ELIMINATES ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB" ENTRY.
0026A5  1               ;
0026A5  1  D0 FD        RETURN: BNE	GORTS		;NO TERMINATOR=BLOW HIM UP.
0026A7  1  A9 FF        	LDA	#255
0026A9  1  85 99        	STA	FORPNT+1	;MAKE SURE THE VARIABLE'S PNTR
0026AB  1               				;NEVER GETS MATCHED.
0026AB  1  20 A1 21     	JSR	FNDFOR		;GO PAST ALL THE "FOR" ENTRIES.
0026AE  1  9A           	TXS
0026AF  1  C9 8C        	CMP	#GOSUTK		;RETURN WITHOUT GOSUB?
0026B1  1  F0 0B        	BEQ	RETU1
0026B3  1  A2 04 2C     	LDX	#ERRRG
0026B6  1               	SKIP2
0026B6  1  A2 0E        USERR:	LDX	#ERRUS		;NO MATCH SO "US" ERROR.
0026B8  1  4C 4E 22     	JMP	ERROR		;YES.
0026BB  1  4C 0F 2C     SNERR2: JMP	SNERR
0026BE  1  68           RETU1:	PLA			;REMOVE GOSUTK.
0026BF  1  68 85 88 68  	PULWD	CURLIN		;GET LINE NUMBER "GOSUB" WAS FROM.
0026C3  1  85 89        
0026C5  1  68 85 C9 68  	PULWD	TXTPTR		;GET TEXT PNTR FROM "GOSUB".
0026C9  1  85 CA        
0026CB  1  20 D9 26     DATA:	JSR	DATAN		;SKIP TO END OF STATEMENT,
0026CE  1               				;SINCE WHEN "GOSUB" STUCK THE TEXT  PNTR
0026CE  1               				;ONTO THE STACK, THE LINE NUMBER ARG
0026CE  1               				;HADN'T BEEN READ YET.
0026CE  1  98           ADDON:	TYA
0026CF  1  18           	CLC
0026D0  1  65 C9        	ADC	TXTPTR
0026D2  1  85 C9        	STA	TXTPTR
0026D4  1  90 02        	BCC	REMRTS
0026D6  1  E6 CA        	INC	TXTPTR+1
0026D8  1  60           REMRTS: RTS			;"NEWSTT" RTS ADDR IS STILL THERE.
0026D9  1               
0026D9  1  A2 3A 2C     DATAN:	LDX	#':'		;"DATA" TERMINATES ON ":" AND NULL.
0026DC  1               	SKIP2
0026DC  1  A2 00        REMN:	LDX	#0		;THE ONLY TERMINATOR IS NULL.
0026DE  1  86 0D        	STX	CHARAC		;PRESERVE IT.
0026E0  1  A0 00        	LDY	#0		;THIS MAKES CHARAC=0 AFTER SWAP.
0026E2  1  84 0E        	STY	ENDCHR
0026E4  1  A5 0E        EXCHQT: LDA	ENDCHR
0026E6  1  A6 0D        	LDX	CHARAC
0026E8  1  85 0D        	STA	CHARAC
0026EA  1  86 0E        	STX	ENDCHR
0026EC  1  B1 C9        REMER:	LDADY	TXTPTR
0026EE  1  F0 E8        	BEQ	REMRTS		;NULL ALWAYS TERMINATES.
0026F0  1  C5 0E        	CMP	ENDCHR		;IS IT THE OTHER TERMINATOR?
0026F2  1  F0 E4        	BEQ	REMRTS		;YES, IT'S FINISHED.
0026F4  1  C8           	INY			;PROGRESS TO NEXT CHARACTER.
0026F5  1  C9 22        	CMP	#34		;IS IT A QUOTE?
0026F7  1  D0 F3 F0 E9  	BNE	REMER		;NO, JUST CONTINUE.
0026FB  1               	BEQA	EXCHQT		;YES, TIME TO TRADE.
0026FB  1               ; PAGE
0026FB  1               ; SUBTTL	"IF ... THEN" CODE.
0026FB  1  20 BE 2A     IF:	JSR	FRMEVL		;EVALUATE A FORMULA.
0026FE  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER.
002701  1  C9 88        	CMP	#GOTOTK		;IS TERMINATING CHARACTER A GOTOTK?
002703  1  F0 05        	BEQ	OKGOTO		;YES.
002705  1  A9 A0 20 06  	SYNCHK	THENTK		;NO, IT MUST BE "THEN".
002709  1  2C           
00270A  1  A5 B0        OKGOTO: LDA	FACEXP		;0=FALSE. ALL OTHERS TRUE.
00270C  1  D0 05        	BNE	DOCOND		;TRUE !
00270E  1  20 DC 26 F0  REM:	JSR	REMN		;SKIP REST OF STATEMENT.
002712  1  BB           
002713  1               	BEQA	ADDON		;WILL ALWAYS BRANCH.
002713  1  20 C8 00     DOCOND: JSR	CHRGOT		;TEST CURRENT CHARACTER.
002716  1  B0 03        	BCS	DOCO		;IF A NUMBER, GOTO IT.
002718  1  4C 78 26     	JMP	GOTO
00271B  1  4C BF 25     DOCO:	JMP	GONE3		;INTERPRET NEW STATEMENT.
00271E  1               ; PAGE
00271E  1               ; SUBTTL	"ON ... GO TO ..." CODE.
00271E  1  20 1C 34     ONGOTO: JSR	GETBYT		;GET VALUE IN FACLO.
002721  1  48           	PHA			;SAVE FOR LATER.
002722  1  C9 8C        	CMP	#GOSUTK		;AN "ON ... GOSUB" PERHAPS?
002724  1  F0 04        	BEQ	ONGLOP		;YES.
002726  1  C9 88        SNERR3: CMP	#GOTOTK		;MUST BE "GOTOTK".
002728  1  D0 91        	BNE	SNERR2
00272A  1  C6 B4        ONGLOP: DEC	FACLO
00272C  1  D0 04        	BNE	ONGLP1		;SKIP ANOTHER LINE NUMBER.
00272E  1  68           	PLA			;GET DISPATCH CHARACTER.
00272F  1  4C C1 25     	JMP	GONE2
002732  1  20 C2 00     ONGLP1: JSR	CHRGET		;ADVANCE AND SET CODES.
002735  1  20 3E 27     	JSR	LINGET
002738  1  C9 2C        	CMP	#44		;IS IT A COMMA?
00273A  1  F0 EE        	BEQ	ONGLOP
00273C  1  68           	PLA			;REMOVE STACK ENTRY (TOKEN).
00273D  1  60           ONGRTS: RTS			;EITHER END-OF-LINE OR SYNTAX ERROR.
00273E  1               ; PAGE
00273E  1               ; SUBTTL	LINGET -- READ A LINE NUMBER INTO LINNUM
00273E  1               ;
00273E  1               ; "LINGET" READS A LINE NUMBER FROM THE CURRENT TEXT POSITION.
00273E  1               ;
00273E  1               ; LINE NUMBERS RANGE FROM 0 TO 64000-1.
00273E  1               ;
00273E  1               ; THE ANSWER IS RETURNED IN "LINNUM".
00273E  1               ; "TXTPTR" IS UPDATED TO POINT TO THE TERMINATING CHARCTER
00273E  1               ; AND [A] = THE TERMINATING CHARACTER WITH CONDITION
00273E  1               ; CODES SET UP TO REFLECT ITS VALUE.
00273E  1               ;
00273E  1  A2 00        LINGET: LDX	#0
002740  1  86 1B        	STX	LINNUM		;INITIALIZE LINE NUMBER TO ZERO.
002742  1  86 1C        	STX	LINNUM+1
002744  1  B0 F7        MORLIN: BCS	ONGRTS		;IT IS NOT A DIGIT.
002746  1  E9 2F        	SBC	#'0'-1		;-1 SINCE C=0.
002748  1  85 0D        	STA	CHARAC		;SAVE CHARACTER.
00274A  1  A5 1C        	LDA	LINNUM+1
00274C  1  85 71        	STA	INDEX
00274E  1  C9 19        	CMP	#25		;LINE NUMBER WILL BE .LT. 64000?
002750  1  B0 D4        	BCS	SNERR3
002752  1  A5 1B        	LDA	LINNUM
002754  1  0A           	ASL	A 		;MULTIPLY BY 10.
002755  1  26 71        	ROL	INDEX
002757  1  0A           	ASL	A
002758  1  26 71        	ROL	INDEX
00275A  1  65 1B        	ADC	LINNUM
00275C  1  85 1B        	STA	LINNUM
00275E  1  A5 71        	LDA	INDEX
002760  1  65 1C        	ADC	LINNUM+1
002762  1  85 1C        	STA	LINNUM+1
002764  1  06 1B        	ASL	LINNUM
002766  1  26 1C        	ROL	LINNUM+1
002768  1  A5 1B        	LDA	LINNUM
00276A  1  65 0D        	ADC	CHARAC		;ADD IN DIGIT.
00276C  1  85 1B        	STA	LINNUM
00276E  1  90 02        	BCC	NXTLGC
002770  1  E6 1C        	INC	LINNUM+1
002772  1  20 C2 00     NXTLGC: JSR	CHRGET
002775  1  4C 44 27     	JMP	MORLIN
002778  1               
002778  1               ; PAGE
002778  1               ; SUBTTL	"LET" CODE.
002778  1  20 23 2D     LET:	JSR	PTRGET		;GET PNTR TO VARIABLE INTO "VARPNT".
00277B  1  85 98 84 99  	STWD	FORPNT		;PRESERVE POINTER.
00277F  1  A9 AB 20 06  	SYNCHK	EQULTK		;"=" IS NECESSARY.
002783  1  2C           
002784  1               .IF	INTPRC <> 0
002784  1  A5 12        	LDA	INTFLG		;SAVE FOR LATER.
002786  1  48           	PHA
002787  1               .ENDIF
002787  1  A5 11        	LDA	VALTYP		;RETAIN THE VARIABLE'S VALUE TYPE.
002789  1  48           	PHA
00278A  1  20 BE 2A     	JSR	FRMEVL		;GET VALUE OF FORMULA INTO "FAC".
00278D  1  68           	PLA
00278E  1  2A           	ROL	A 		;CARRY SET FOR STRING, OFF FOR
00278F  1               				;NUMERIC.
00278F  1  20 B0 2A     	JSR	CHKVAL		;MAKE SURE "VALTYP" MATCHES CARRY.
002792  1               				;AND SET ZERO FLAG FOR NUMERIC.
002792  1  D0 18        	BNE	COPSTR		;IF NUMERIC, COPY IT.
002794  1               COPNUM:
002794  1               .IF	INTPRC <> 0
002794  1  68           	PLA			;GET NUMBER TYPE.
002795  1  10 12        QINTGR: BPL	COPFLT		;STORE A FLTING NUMBER.
002797  1  20 9A 38     	JSR	ROUND		;ROUND INTEGER.
00279A  1  20 3D 2E     	JSR	AYINT		;MAKE 2-BYTE NUMBER.
00279D  1  A0 00        	LDY	#0
00279F  1  A5 B3        	LDA	FACMO		;GET HIGH.
0027A1  1  91 98        	STADY	FORPNT		;STORE IT.
0027A3  1  C8           	INY
0027A4  1  A5 B4        	LDA	FACLO		;GET LOW.
0027A6  1  91 98        	STADY	FORPNT
0027A8  1  60           	RTS
0027A9  1               .ENDIF
0027A9  1  4C 4F 38     COPFLT: JMP	MOVVF		;PUT NUMBER @FORPNT.
0027AC  1               
0027AC  1               COPSTR:
0027AC  1               .IF	INTPRC <> 0
0027AC  1  68           	PLA		;IF STRING, NO INTFLG.
0027AD  1               .ENDIF
0027AD  1               INPCOM:
0027AD  1               .IF	TIME <> 0
0027AD  1               	LDY	FORPNT+1	;TI$?
0027AD  1               	CPY	#ZERO/256	;ONLY TI$ CAN BE THIS ON ASSIG.
0027AD  1               	BNE	GETSPT		; WAS NOT TI$.
0027AD  1               	JSR	FREFAC		;WE WONT NEEDIT.
0027AD  1               	CMP	#6		;LENGTH CORRECT?
0027AD  1               	BNE	FCERR2
0027AD  1               	LDY	#0		;YES. DO SETUP.
0027AD  1               	STY	FACEXP		;ZERO FAC TO START WITH.
0027AD  1               	STY	FACSGN
0027AD  1               TIMELP: STY	FBUFPT		;SAVE POSOTION.
0027AD  1               	JSR	TIMNUM		;GET A DIGIT.
0027AD  1               	JSR	MUL10		;WHOLE QTY BY 10.
0027AD  1               	INC	FBUFPT
0027AD  1               	LDY	FBUFPT
0027AD  1               	JSR	TIMNUM
0027AD  1               	JSR	MOVAF
0027AD  1               	TAX			;IF NUM=0 THEN NO MULT.
0027AD  1               	BEQ	NOML6		;IF =0, GO TIT.
0027AD  1               	INX			;MULT BY TWO.
0027AD  1               	TXA
0027AD  1               	JSR	FINML6		;ADD IN AND MULT BY 2 GIVES *6.
0027AD  1               NOML6:	LDY	FBUFPT
0027AD  1               	INY
0027AD  1               	CPY	#6		;DONE ALL SIX?
0027AD  1               	BNE	TIMELP
0027AD  1               	JSR	MUL10		;ONE LAST TIME.
0027AD  1               	JSR	QINT		;SHIFT IT OVER TO THE RIGHT.
0027AD  1               	LDX	#2
0027AD  1               	SEI			;DISALLOW INTERRUPTS.
0027AD  1               TIMEST: LDA	FACMOH,X
0027AD  1               	STA	CQTIMR,X
0027AD  1               	DEX
0027AD  1               	BPL	TIMEST		;LOOP 3 TIMES.
0027AD  1               	CLI			;TURN ON INTS AGAIN.
0027AD  1               	RTS
0027AD  1               TIMNUM: LDADY	INDEX		;INDEX SET UP BY FREFAC.
0027AD  1               	JSR	QNUM
0027AD  1               	BCC	GOTNUM
0027AD  1               FCERR2: JMP	FCERR		;MUST BE NUMERIC STRING.
0027AD  1               GOTNUM: SBC	#'0'-1		;C IS OFF.
0027AD  1               	JMP	FINLOG		;ADD IN DIGIT TO FAC.
0027AD  1               .ENDIF
0027AD  1               
0027AD  1  A0 02        GETSPT: LDY	#2		;GET PNTR TO DESCRIPTOR.
0027AF  1  B1 B3        	LDADY	FACMO
0027B1  1  C5 83        	CMP	FRETOP+1	;SEE IF IT POINTS INTO STRING SPACE.
0027B3  1  90 17        	BCC	DNTCPY		;IF [FRETOP],GT.[2&3,FACMO], DON'T COPY.
0027B5  1  D0 07        	BNE	QVARIA		;IT IS LESS.
0027B7  1  88           	DEY
0027B8  1  B1 B3        	LDADY	FACMO
0027BA  1  C5 82        	CMP	FRETOP		;COMPARE LOW ORDERS.
0027BC  1  90 0E        	BCC	DNTCPY
0027BE  1  A4 B4        QVARIA: LDY	FACLO
0027C0  1  C4 7D        	CPY	VARTAB+1	;IF [VARTAB].GT.[FACMO], DON'T COPY.
0027C2  1  90 08        	BCC	DNTCPY
0027C4  1  D0 0D        	BNE	COPY		;IT IS LESS.
0027C6  1  A5 B3        	LDA	FACMO
0027C8  1  C5 7C        	CMP	VARTAB		;COMPARE LOW ORDERS.
0027CA  1  B0 07        	BCS	COPY
0027CC  1  A5 B3 A4 B4  DNTCPY: LDWD	FACMO
0027D0  1  4C E9 27     	JMP	COPYZC
0027D3  1  A0 00        COPY:	LDY	#0
0027D5  1  B1 B3        	LDADY	FACMO
0027D7  1  20 F2 30     	JSR	STRINI		;GET ROOM TO COPY STRING INTO.
0027DA  1  A5 9F A4 A0  	LDWD	DSCPNT		;GET POINTER TO OLD DESCRIPTOR, SO
0027DE  1  85 BE 84 BF  	STWD	STRNG1		;MOVINS CAN FIND STRING.
0027E2  1  20 F8 32     	JSR	MOVINS		;COPY IT.
0027E5  1  A9 B0 A0 00  	LDWDI	DSCTMP		;GET POINTER TO OLD DESCRIPTOR.
0027E9  1  85 9F 84 A0  COPYZC: STWD	DSCPNT		;REMEMBER POINTER TO DESCRIPTOR.
0027ED  1  20 59 33     	JSR	FRETMS		;FREE UP THE TEMPORARY WITHOUT
0027F0  1               				;FREEING UP ANY STRING SPACE.
0027F0  1  A0 00        	LDY	#0
0027F2  1  B1 9F        	LDADY	DSCPNT
0027F4  1  91 98        	STADY	FORPNT
0027F6  1  C8           	INY			;POINT TO STRING PNTR.
0027F7  1  B1 9F        	LDADY	DSCPNT
0027F9  1  91 98        	STADY	FORPNT
0027FB  1  C8           	INY
0027FC  1  B1 9F        	LDADY	DSCPNT
0027FE  1  91 98        	STADY	FORPNT
002800  1  60           	RTS
002801  1               ; PAGE
002801  1               ; SUBTTL	PRINT CODE.
002801  1               .IF	EXTIO <> 0
002801  1               PRINTN: JSR	CMD		;DOCMD
002801  1               	JMP	IODONE		;RELEASE CHANNEL.
002801  1               CMD:	JSR	GETBYT
002801  1               	BEQ	SAVEIT
002801  1               	SYNCHK	44		;COMMA?
002801  1               SAVEIT: PHP
002801  1               	JSR	CQOOUT		;CHECK AND OPEN OUTPUT CHANNL.
002801  1               	STX	CHANNL		;CHANNL TO OUTPUT ON.
002801  1               	PLP			;GET STATUS BACK.
002801  1               	JMP	PRINT
002801  1               .ENDIF
002801  1  20 9E 28     STRDON: JSR	STRPRT
002804  1  20 C8 00     NEWCHR: JSR	CHRGOT		;REGET LAST CHARACTER.
002807  1  F0 3C        PRINT:	BEQ	CRDO		;TERMINATOR SO TYPE CRLF.
002809  1  F0 58        PRINTC: BEQ	PRTRTS		;HERE AFTER SEEING TAB(X) OR , OR ;
00280B  1               				;IN WHICH CASE A TERMINATOR DOES NOT
00280B  1               				;MEAN TYPE A CRLF BUT JUST RTS.
00280B  1  C9 9C        	CMP	#TABTK		;TAB FUNCTION?
00280D  1  F0 6C        	BEQ	TABER		;YES.
00280F  1  C9 9F        	CMP	#SPCTK		;SPACE FUNCTION?
002811  1  18           	CLC
002812  1  F0 67        	BEQ	TABER
002814  1  C9 2C        	CMP	#44		;A COMMA?
002816  1  F0 4C        	BEQ	COMPRT		;YES.
002818  1  C9 3B        	CMP	#59		;A SEMICOLON?
00281A  1  F0 74        	BEQ	NOTABR		;YES.
00281C  1  20 BE 2A     	JSR	FRMEVL		;EVALUATE THE FORMULA.
00281F  1  24 11        	BIT	VALTYP		;A STRING?
002821  1  30 DE        	BMI	STRDON		;YES.
002823  1  20 5C 3A     	JSR	FOUT
002826  1  20 04 31     	JSR	STRLIT		;BUILD DESCRIPTOR.
002829  1               .IF	REALIO-3 <> 0
002829  1  A0 00        	LDY	#0		;GET THE POINTER.
00282B  1  B1 B3        	LDADY	FACMO
00282D  1  18           	CLC
00282E  1  65 18        	ADC	TRMPOS		;MAKE SURE LEN+POS.LT.WIDTH.
002830  1  C5 19        	CMP	LINWID		;GREATER THAN LINE LENGTH?
002832  1               				;REMEMBER SPACE PRINTED AFTER NUMBER.
002832  1  90 03        	BCC	LINCHK		;GO TYPE.
002834  1  20 45 28     	JSR	CRDO		;YES, TYPE CRLF FIRST.
002837  1               .ENDIF
002837  1  20 9E 28     LINCHK: JSR	STRPRT		;PRINT THE NUMBER.
00283A  1  20 B8 28 D0  	JSR	OUTSPC		;PRINT A SPACE
00283E  1  C5           
00283F  1               	BNEA	NEWCHR		;ALWAYS GOES.
00283F  1               .IF	REALIO-4 <> 0
00283F  1               .IF	BUFPAG <> 0
00283F  1               FININL: LDA	#0
00283F  1               	STA	BUF,X
00283F  1               	LDXYI	BUF-1
00283F  1               .ENDIF
00283F  1               .IF	BUFPAG = 0
00283F  1  A0 00        FININL: LDY	#0		;PUT A ZERO AT END OF BUF.
002841  1  94 1D        	STY	BUF,X
002843  1  A2 1C        	LDX	#BUF-1		;SETUP POINTER.
002845  1               .ENDIF
002845  1               .IF	EXTIO <> 0
002845  1               	LDA	CHANNL		;NO CRDO IF NOT TERMINAL.
002845  1               	BNE	PRTRTS
002845  1               .ENDIF
002845  1               .ENDIF
002845  1               CRDO:
002845  1               .IF	EXTIO = 0
002845  1  A9 0D        	LDA	#13		;MAKE TRMPOS LESS THAN LINE LENGTH.
002847  1  85 18        	STA	TRMPOS
002849  1               .ENDIF
002849  1               .IF	EXTIO <> 0
002849  1               .IF	REALIO-3 <> 0
002849  1               	LDA	CHANNL
002849  1               	BNE	GOCR
002849  1               	STA	TRMPOS
002849  1               .ENDIF
002849  1               GOCR:	LDA	#13		;X AND Y MUST BE PRESERVED.
002849  1               .ENDIF
002849  1  20 BD 28     	JSR	OUTDO
00284C  1  A9 0A        	LDA	#10
00284E  1  20 BD 28     	JSR	OUTDO
002851  1               CRFIN:
002851  1               .IF	EXTIO <> 0
002851  1               .IF	REALIO-3 <> 0
002851  1               	LDA	CHANNL
002851  1               	BNE	PRTRTS
002851  1               .ENDIF
002851  1               .ENDIF
002851  1               .IF	NULCMD = 0
002851  1               .IF	REALIO-3 <> 0
002851  1               	LDA	#0
002851  1               	STA	TRMPOS
002851  1               .ENDIF
002851  1               	EOR	#255
002851  1               .ENDIF
002851  1               .IF	NULCMD <> 0
002851  1  8A           	TXA			;PRESERVE [ACCX]. SOME NEED IT.
002852  1  48           	PHA
002853  1  A6 17        	LDX	NULCNT		;GET NUMBER OF NULLS.
002855  1  F0 08        	BEQ	CLRPOS
002857  1  A9 00        	LDA	#0
002859  1  20 BD 28     PRTNUL: JSR	OUTDO
00285C  1  CA           	DEX			;DONE WITH NULLS?
00285D  1  D0 FA        	BNE	PRTNUL
00285F  1  86 18        CLRPOS: STX	TRMPOS
002861  1  68           	PLA
002862  1  AA           	TAX
002863  1               .ENDIF
002863  1  60           PRTRTS: RTS
002864  1               
002864  1  A5 18        COMPRT: LDA	TRMPOS
002866  1               NCMPOS .SET (((LINLEN/CLMWID)-1)*CLMWID)	;CLMWID BEYOND WHICH THERE ARE
002866  1               .IF	REALIO-3 <> 0
002866  1               				;NO MORE COMMA FIELDS.
002866  1  C5 1A        	CMP	NCMWID		;SO ALL COMMA DOES IS "CRDO".
002868  1               
002868  1  90 06        	BCC	MORCOM
00286A  1  20 45 28     	JSR	CRDO		;TYPE CRLF.
00286D  1  4C 90 28     	JMP	NOTABR		;AND QUIT IF BEYOND LAST FIELD.
002870  1               .ENDIF
002870  1  38           MORCOM: SEC
002871  1  E9 0E        MORCO1: SBC	#CLMWID		;GET [A] MODULUS CLMWID.
002873  1  B0 FC        	BCS	MORCO1
002875  1  49 FF        	EOR	#255		;FILL PRINT POS OUT TO EVEN CLMWID SO
002877  1  69 01        	ADC	#1
002879  1  D0 10        	BNE	ASPAC		;PRINT [A] SPACES.
00287B  1               
00287B  1  08           TABER:	PHP			;REMEMBER IF SPC OR TAB FUNCTION.
00287C  1  20 19 34     	JSR	GTBYTC		;GET VALUE INTO ACCX.
00287F  1  C9 29        	CMP	#41
002881  1  D0 63        	BNE	SNERR4
002883  1  28           	PLP
002884  1  90 06        	BCC	XSPAC		;PRINT [X] SPACES.
002886  1  8A           	TXA
002887  1  E5 18        	SBC	TRMPOS
002889  1  90 05        	BCC	NOTABR		;NEGATIVE, DON'T PRINT ANY.
00288B  1  AA           ASPAC:	TAX
00288C  1  E8           XSPAC:	INX
00288D  1  CA           XSPAC2: DEX			;DECREMENT THE COUNT.
00288E  1  D0 06        	BNE	XSPAC1
002890  1  20 C2 00     NOTABR: JSR	CHRGET		;REGET LAST CHARACTER.
002893  1  4C 09 28     	JMP	PRINTC		;DON'T CALL CRDO.
002896  1  20 B8 28 D0  XSPAC1: JSR	OUTSPC
00289A  1  F2           
00289B  1               	BNEA	XSPAC2
00289B  1               ;
00289B  1               ; PRINT THE STRING POINTED TO BY [Y,A] WHICH ENDS WITH A ZERO.
00289B  1               ; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE.
00289B  1               ;
00289B  1  20 04 31     STROUT: JSR	STRLIT		;GET A STRING LITERAL.
00289E  1               ;
00289E  1               ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACMO.
00289E  1               ;
00289E  1  20 24 33     STRPRT: JSR	FREFAC		;RETURN TEMP POINTER.
0028A1  1  AA           	TAX			;PUT COUNT INTO COUNTER.
0028A2  1  A0 00        	LDY	#0
0028A4  1  E8           	INX			;MOVE ONE AHEAD.
0028A5  1  CA           STRPR2: DEX
0028A6  1  F0 BB        	BEQ	PRTRTS		;ALL DONE.
0028A8  1  B1 71        	LDADY	INDEX		;PNTR TO ACT STRNG SET BY FREFAC.
0028AA  1  20 BD 28     	JSR	OUTDO
0028AD  1  C8           	INY
0028AE  1  C9 0D        	CMP	#13
0028B0  1  D0 F3        	BNE	STRPR2
0028B2  1  20 51 28     	JSR	CRFIN		;TYPE REST OF CARRIAGE RETURN.
0028B5  1  4C A5 28     	JMP	STRPR2		;AND ON AND ON.
0028B8  1               ;
0028B8  1               ; OUTDO OUTPUTS THE CHARACTER IN ACCA, USING CNTWFL
0028B8  1               ; (SUPPRESS OR NOT), TRMPOS (PRINT HEAD POSITION),
0028B8  1               ; TIMING, ETCQ. NO REGISTERS ARE CHANGED.
0028B8  1               ;
0028B8  1               OUTSPC:
0028B8  1               .IF	REALIO-3 <> 0
0028B8  1  A9 20        	LDA	#' '
0028BA  1               .ENDIF
0028BA  1  2C           .IF	REALIO-3 = 0
0028BB  1               	LDA	CHANNL
0028BB  1               	BEQ	CRTSKP
0028BB  1               	LDA	#' '
0028BB  1               	SKIP2
0028BB  1               CRTSKP: LDA	#29		;COMMODORE'S SKIP CHARACTER.
0028BB  1               .ENDIF
0028BB  1               	SKIP2
0028BB  1  A9 3F        OUTQST: LDA	#'?'
0028BD  1               OUTDO:
0028BD  1               .IF	REALIO <> 0
0028BD  1               	BIT	CNTWFL		;SHOULDN'T AFFECT CHANNEL I/O!
0028BD  1               	BMI	OUTRTS
0028BD  1               .ENDIF
0028BD  1               .IF	REALIO-3 <> 0
0028BD  1  48           	PHA
0028BE  1  C9 20        	CMP	#32		;IS THIS A PRINTING CHAR?
0028C0  1  90 0B        	BCC	TRYOUT		;NO, DON'T INCLUDE IT IN TRMPOS.
0028C2  1  A5 18        	LDA	TRMPOS
0028C4  1  C5 19        	CMP	LINWID		;LENGTH = TERMINAL WIDTH?
0028C6  1  D0 03        	BNE	OUTDO1
0028C8  1  20 45 28     	JSR	CRDO		;YES, TYPE CRLF
0028CB  1               OUTDO1:
0028CB  1               .IF	EXTIO <> 0
0028CB  1               	LDA	CHANNL
0028CB  1               	BNE	TRYOUT
0028CB  1               .ENDIF
0028CB  1  E6 18        INCTRM: INC	TRMPOS		;INCREMENT COUNT.
0028CD  1  68           TRYOUT: PLA			;RESTORE THE A REGISTER
0028CE  1               .ENDIF
0028CE  1               
0028CE  1               .IF	REALIO-1 = 0
0028CE  1               	STY	KIMY		;PRESERVE Y.
0028CE  1               .ENDIF
0028CE  1               .IF	REALIO-4 = 0
0028CE  1               	ORA	#$80	;TURN ON B7 FOR APPLE.
0028CE  1               .ENDIF
0028CE  1               .IF	REALIO <> 0
0028CE  1               OUTLOC: JSR	OUTCH		;OUTPUT THE CHARACTER.
0028CE  1               .ENDIF
0028CE  1               .IF	REALIO-1 = 0
0028CE  1               	LDY	KIMY		;GET Y BACK.
0028CE  1               .ENDIF
0028CE  1               .IF	REALIO-2 = 0
0028CE  1               	REPEAT	4,{NOP}
0028CE  1               .ENDIF
0028CE  1               .IF	REALIO-4 = 0
0028CE  1               	AND	#$7F	;GET [A] BACK FROM APPLE.
0028CE  1               .ENDIF
0028CE  1               
0028CE  1               .IF	REALIO = 0
0028CE  1  8D 00 D0     	SIM_OUTSIM		;CALL SIMULATOR OUTPUT ROUTINE
0028D1  1               .ENDIF
0028D1  1  29 FF        OUTRTS: AND	#255		;SET Z=0.
0028D3  1  60           GETRTS: RTS
0028D4  1               
0028D4  1               ; PAGE
0028D4  1               ; SUBTTL	INPUT AND READ CODE.
0028D4  1               ;
0028D4  1               ; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
0028D4  1               ; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
0028D4  1               ; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
0028D4  1               ;
0028D4  1  A5 15        TRMNOK: LDA	INPFLG
0028D6  1  F0 11        	BEQ	TRMNO1		;IF INPUT TRY AGAIN.
0028D8  1               .IF	GETCMD <> 0
0028D8  1  30 04        	BMI	GETDTL
0028DA  1  A0 FF D0 04  	LDY	#255		;MAKE IT LOOK DIRECT.
0028DE  1               	BNEA	STCURL		;ALWAYS GOES.
0028DE  1               GETDTL:
0028DE  1               .ENDIF
0028DE  1  A5 8E A4 8F  	LDWD	DATLIN		;GET DATA LINE NUMBER.
0028E2  1  85 88 84 89  STCURL: STWD	CURLIN		;MAKE IT CURRENT LINE.
0028E6  1  4C 0F 2C     SNERR4: JMP	SNERR
0028E9  1               TRMNO1:
0028E9  1               .IF	EXTIO <> 0
0028E9  1               	LDA	CHANNL		;IF NOT TERMINAL, GIVE BAD DATA.
0028E9  1               	BEQ	DOAGIN
0028E9  1               	LDX	#ERRBD
0028E9  1               	JMP	ERROR
0028E9  1               .ENDIF
0028E9  1  A9 2C A0 2A  DOAGIN: LDWDI	TRYAGN
0028ED  1  20 9B 28     	JSR	STROUT		;PRINT "?REDO FROM START".
0028F0  1  A5 8C A4 8D  	LDWD	OLDTXT		;POINT AT START
0028F4  1  85 C9 84 CA  	STWD	TXTPTR		;OF THIS CURRENT LINE.
0028F8  1  60           	RTS			;GO TO "NEWSTT".
0028F9  1               .IF	GETCMD <> 0
0028F9  1  20 23 30     GET:	JSR	ERRDIR		;DIRECT IS NOT OK.
0028FC  1               .IF	EXTIO <> 0
0028FC  1               	CMP	#'#'		;SEE IF "GET#".
0028FC  1               	BNE	GETTTY		;NO, JUST GET TTY INPUT.
0028FC  1               	JSR	CHRGET		;MOVE UP TO NEXT BYTE.
0028FC  1               	JSR	GETBYT		;GET CHANNEL INTO X
0028FC  1               	SYNCHK	44		;COMMA?
0028FC  1               	JSR	CQOIN		;GET CHANNEL OPEN FOR INPUT.
0028FC  1               	STX	CHANNL
0028FC  1               .ENDIF
0028FC  1  A2 1E A0 00  GETTTY: LDXYI	BUF+1		;POINT TO 0.
002900  1               .IF	BUFPAG <> 0
002900  1               	LDA	#0		;TO STUFF AND TO POINT.
002900  1               	STA	BUF+1
002900  1               .ENDIF
002900  1               .IF	BUFPAG = 0
002900  1  84 1E        	STY	BUF+1		;ZERO IT.
002902  1               .ENDIF
002902  1  A9 40        	LDA	#64		;TURN ON V-BIT.
002904  1  20 38 29     	JSR	INPCO1		;DO THE GET.
002907  1               .IF	EXTIO <> 0
002907  1               	LDX	CHANNL
002907  1               	BNE	IORELE		;RELEASE.
002907  1               .ENDIF
002907  1  60           	RTS
002908  1               .ENDIF
002908  1               
002908  1               .IF	EXTIO <> 0
002908  1               INPUTN: JSR	GETBYT		;GET CHANNEL NUMBER.
002908  1               	SYNCHK	44		;A COMMA?
002908  1               	JSR	CQOIN		;GO WHERE COMMODORE CHECKS IN OPEN.
002908  1               	STX	CHANNL
002908  1               	JSR	NOTQTI		;DO INPUT TO VARIABLES.
002908  1               IODONE: LDA	CHANNL		;RELEASE CHANNEL.
002908  1               IORELE: JSR	CQCCHN
002908  1               	LDX	#0		;RESET CHANNEL TO TERMINAL.
002908  1               	STX	CHANNL
002908  1               	RTS
002908  1               .ENDIF
002908  1               INPUT:
002908  1               .IF	REALIO <> 0
002908  1               	LSR	CNTWFL		;BE TALKATIVE.
002908  1               .ENDIF
002908  1  C9 22        	CMP	#34		;A QUOTE?
00290A  1  D0 0B        	BNE	NOTQTI		;NO MESSAGE.
00290C  1  20 C4 2B     	JSR	STRTXT		;LITERALIZE THE STRING IN TEXT
00290F  1  A9 3B 20 06  	SYNCHK	59		;MUST END WITH SEMICOLON.
002913  1  2C           
002914  1  20 9E 28     	JSR	STRPRT		;PRINT IT OUT.
002917  1  20 23 30     NOTQTI: JSR	ERRDIR		;USE COMMON ROUTINE SINCE DEF DIRECT
00291A  1  A9 2C        	LDA	#44		;GET COMMA.
00291C  1  85 1C        	STA	BUF-1
00291E  1               				;IS ALSO ILLEGAL.
00291E  1  20 29 29     GETAGN: JSR	QINLIN		;TYPE "?" AND INPUT A LINE OF TEXT.
002921  1               .IF	EXTIO <> 0
002921  1               	LDA	CHANNL
002921  1               	BEQ	BUFFUL
002921  1               	LDA	CQSTAT		;GET STATUS BYTE.
002921  1               	AND	#2
002921  1               	BEQ	BUFFUL		;A-OK.
002921  1               	JSR	IODONE		;BAD. CLOSE CHANNEL.
002921  1               	JMP	DATA		;SKIP REST OF INPUT.
002921  1               BUFFUL:
002921  1               .ENDIF
002921  1  A5 1D        	LDA	BUF		;ANYTHING INPUT?
002923  1  D0 12        	BNE	INPCON		;YES, CONTINUE.
002925  1               .IF	EXTIO <> 0
002925  1               	LDA	CHANNL		;BLANK LINE MEANS GET ANOTHER.
002925  1               	BNE	GETAGN		;IF NOT TERMINAL.
002925  1               .ENDIF
002925  1  18           	CLC			;MAKE SURE DONT PRINT BREAK
002926  1  4C 0D 26     	JMP	STPEND		;NO, STOP.
002929  1               QINLIN:
002929  1               .IF	EXTIO <> 0
002929  1               	LDA	CHANNL
002929  1               	BNE	GINLIN
002929  1               .ENDIF
002929  1  20 BB 28     	JSR	OUTQST
00292C  1  20 B8 28     	JSR	OUTSPC
00292F  1  4C 51 23     GINLIN: JMP	INLIN
002932  1  A6 90 A4 91  READ:	LDXY	DATPTR		;GET LAST DATA LOCATION.
002936  1  A9           	.BYTE	$A9	;LDAI TYA TO MAKE IT NONZERO.
002937  1               .IF	BUFPAG = 0
002937  1               INPCON:
002937  1               .ENDIF
002937  1  98           	TYA
002938  1               .IF	BUFPAG <> 0
002938  1               	SKIP2
002938  1               INPCON: LDA	#0		;SET FLAG THAT THIS IS INPUT
002938  1               .ENDIF
002938  1  85 15        INPCO1: STA	INPFLG		;STORE THE FLAG.
00293A  1               ;
00293A  1               ; IN THE PROCESSING OF DATA AND READ STATEMENTS:
00293A  1               ; ONE POINTER POINTS TO THE DATA (IE, THE NUMBERS BEING FETCHED)
00293A  1               ; AND ANOTHER POINTS TO THE LIST OF VARIABLES.
00293A  1               ;
00293A  1               ; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
00293A  1               ; TERMINATOR -- A , : OR END-OF-LINE.
00293A  1               ;
00293A  1               ; AT THIS POINT TXTPTR POINTS TO LIST OF VARIABLES AND
00293A  1               ; [Y,X] POINTS TO DATA OR INPUT LINE.
00293A  1               ;
00293A  1  86 92 84 93  	STXY	INPPTR
00293E  1  20 23 2D     INLOOP: JSR	PTRGET		;READ VARIABLE LIST.
002941  1  85 98 84 99  	STWD	FORPNT		;SAVE POINTER FOR "LET" STRING STUFFING.
002945  1               				;RETURNS PNTR TOP VAR IN VARPNT.
002945  1  A5 C9 A4 CA  	LDWD	TXTPTR		;SAVE TEXT PNTR.
002949  1  85 9A 84 9B  	STWD	VARTXT
00294D  1  A6 92 A4 93  	LDXY	INPPTR
002951  1  86 C9 84 CA  	STXY	TXTPTR
002955  1  20 C8 00     	JSR	CHRGOT		;GET IT AND SET Z IF TERM.
002958  1  D0 1B        	BNE	DATBK1
00295A  1  24 15        	BIT	INPFLG
00295C  1               .IF	GETCMD <> 0
00295C  1  50 0B        	BVC	QDATA
00295E  1  20 00 D1     	JSR	CZGETL		;DON'T WANT INCHR. JUST ONE.
002961  1               .IF	REALIO-4 = 0
002961  1               	AND	#127
002961  1               .ENDIF
002961  1  85 1D        	STA	BUF		;MAKE IT FIRST CHARACTER.
002963  1  A2 1C A0 00  	LDXYI	BUF-1		;POINT JUST BEFORE IT.
002967  1  F0 08        .IF	BUFPAG = 0
002969  1               	BEQA	DATBK
002969  1               .ENDIF
002969  1               .IF	BUFPAG <> 0
002969  1               	BNEA	DATBK		;GO PROCESS.
002969  1               .ENDIF
002969  1               .ENDIF
002969  1  30 71        QDATA:	BMI	DATLOP		;SEARCH FOR ANOTHER DATA STATEMENT.
00296B  1               .IF	EXTIO <> 0
00296B  1               	LDA	CHANNL
00296B  1               	BNE	GETNTH
00296B  1               .ENDIF
00296B  1  20 BB 28     	JSR	OUTQST
00296E  1  20 29 29     GETNTH: JSR	QINLIN		;GET ANOTHER LINE.
002971  1  86 C9 84 CA  DATBK:	STXY	TXTPTR		;SET FOR "CHRGET".
002975  1  20 C2 00     DATBK1: JSR	CHRGET
002978  1  24 11        	BIT	VALTYP		;GET VALUE TYPE.
00297A  1  10 31        	BPL	NUMINS		;INPUT A NUMBER IF NUMERIC.
00297C  1               .IF	GETCMD <> 0
00297C  1  24 15        	BIT	INPFLG		;GET?
00297E  1  50 09        	BVC	SETQUT		;NO, GO SET QUOTE.
002980  1  E8           	INX
002981  1  86 C9        	STX	TXTPTR
002983  1  A9 00        	LDA	#0		;ZERO TERMINATORS.
002985  1  85 0D F0 0C  	STA	CHARAC
002989  1               	BEQA	RESETC
002989  1               .ENDIF
002989  1  85 0D        SETQUT: STA	CHARAC		;ASSUME QUOTED STRING.
00298B  1  C9 22        	CMP	#34		;TERMINATORS OK?
00298D  1  F0 07        	BEQ	NOWGET		;YES.
00298F  1  A9 3A        	LDA	#':'		;SET TERMINATORS TO ":" AND
002991  1  85 0D        	STA	CHARAC
002993  1  A9 2C        	LDA	#44		;COMMA.
002995  1  18           RESETC: CLC
002996  1  85 0E        NOWGET: STA	ENDCHR
002998  1  A5 C9 A4 CA  	LDWD	TXTPTR
00299C  1  69 00        	ADC	#0		;C IS SET PROPERLY ABOVE.
00299E  1  90 01        	BCC	NOWGE1
0029A0  1  C8           	INY
0029A1  1  20 0A 31     NOWGE1: JSR	STRLT2		;MAKE A STRING DESCRIPTOR FOR THE VALUE
0029A4  1               				;AND COPY IF NECESSARY.
0029A4  1  20 61 34     	JSR	ST2TXT		;SET TEXT POINTER.
0029A7  1  20 AD 27     	JSR	INPCOM		;DO ASSIGNMENT.
0029AA  1  4C B5 29     	JMP	STRDN2
0029AD  1  20 72 39     NUMINS: JSR	FIN
0029B0  1               .IF	INTPRC = 0
0029B0  1               	JSR	MOVVF
0029B0  1               .ENDIF
0029B0  1               .IF	INTPRC <> 0
0029B0  1  A5 12        	LDA	INTFLG		;SET CODES ON FLAG.
0029B2  1  20 95 27     	JSR	QINTGR		;GO DECIDE ON FLOAT.
0029B5  1               .ENDIF
0029B5  1  20 C8 00     STRDN2: JSR	CHRGOT		;READ LAST CHARACTER.
0029B8  1  F0 07        	BEQ	TRMOK		;":" OR EOL IS OK.
0029BA  1  C9 2C        	CMP	#44		;A COMMA?
0029BC  1  F0 03 4C D4  	JNE	TRMNOK
0029C0  1  28           
0029C1  1  A5 C9 A4 CA  TRMOK:	LDWD	TXTPTR
0029C5  1  85 92 84 93  	STWD	INPPTR		;SAVE FOR MORE READS.
0029C9  1  A5 9A A4 9B  	LDWD	VARTXT
0029CD  1  85 C9 84 CA  	STWD	TXTPTR		;POINT TO VARIABLE LIST.
0029D1  1  20 C8 00     	JSR	CHRGOT		;LOOK AT LAST VARIABLE LIST CHARACTER.
0029D4  1  F0 2C        	BEQ	VAREND		;THAT'S THE END OF THE LIST.
0029D6  1  20 04 2C     	JSR	CHKCOM		;NOT END. CHECK FOR COMMA.
0029D9  1  4C 3E 29     	JMP	INLOOP
0029DC  1               ;
0029DC  1               ; SUBROUTINE TO FIND DATA
0029DC  1               ; THE SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA TO
0029DC  1               ; SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
0029DC  1               ; IS COMPARED WITH "DATATK". EACH NEW LINE NUMBER
0029DC  1               ; IS STORED IN "DATLIN" SO THAT IF AN ERROR OCCURS
0029DC  1               ; WHILE READING DATA THE ERROR MESSAGE CAN GIVE THE LINE
0029DC  1               ; NUMBER OF THE ILL-FORMATTED DATA.
0029DC  1               ;
0029DC  1  20 D9 26     DATLOP: JSR	DATAN		;SKIP SOME TEXT.
0029DF  1  C8           	INY
0029E0  1  AA           	TAX			;END OF LINE?
0029E1  1  D0 12        	BNE	NOWLIN		;SHO AIN'T.
0029E3  1  A2 06        	LDX	#ERROD		;YES = "NO DATA" ERROR.
0029E5  1  C8           	INY
0029E6  1  B1 C9        	LDADY	TXTPTR
0029E8  1  F0 69        	BEQ	ERRGO5
0029EA  1  C8           	INY
0029EB  1  B1 C9        	LDADY	TXTPTR		;GET HIGH BYTE OF LINE NUMBER.
0029ED  1  85 8E        	STA	DATLIN
0029EF  1  C8           	INY
0029F0  1  B1 C9        	LDADY	TXTPTR		;GET LOW BYTE.
0029F2  1  C8           	INY
0029F3  1  85 8F        	STA	DATLIN+1
0029F5  1  B1 C9        NOWLIN: LDADY	TXTPTR		;HOW IS IT?
0029F7  1  AA           	TAX
0029F8  1  20 CE 26     	JSR	ADDON		;ADD [Y] TO [TXTPTR].
0029FB  1  E0 83        	CPX	#DATATK		;IS IT A "DATA" STATEMENT.
0029FD  1  D0 DD        	BNE	DATLOP		;NOT QUITE RIGHT. KEEP LOOKING.
0029FF  1  4C 75 29     	JMP	DATBK1		;THIS IS THE ONE !
002A02  1  A5 92 A4 93  VAREND: LDWD	INPPTR		;PUT AWAY A NEW DATA PNTR MAYBE.
002A06  1  A6 15        	LDX	INPFLG
002A08  1  10 03        	BPL	VARY0
002A0A  1  4C F9 25     	JMP	RESFIN
002A0D  1  A0 00        VARY0:	LDY	#0
002A0F  1  B1 92        	LDADY	INPPTR		;LAST DATA CHR COULD HAVE BEEN
002A11  1               				;COMMA OR COLON BUT SHOULD BE NULL.
002A11  1  F0 07        	BEQ	INPRTS		;IT IS NULL.
002A13  1               .IF	EXTIO <> 0
002A13  1               	LDA	CHANNL		;IF NOT TERMINAL, NO TYPE.
002A13  1               	BNE	INPRTS
002A13  1               .ENDIF
002A13  1  A9 1B A0 2A  	LDWDI	EXIGNT
002A17  1  4C 9B 28     	JMP	STROUT		;TYPE "?EXTRA IGNORED"
002A1A  1  60           INPRTS: RTS			;DO NEXT STATEMENT.
002A1B  1  3F 45 58 54  EXIGNT: DT"?EXTRA IGNORED"
002A1F  1  52 41 20 49  
002A23  1  47 4E 4F 52  
002A29  1  0D 0A        	ACRLF
002A2B  1  00           .BYTE	0
002A2C  1  3F 52 45 44  TRYAGN: DT"?REDO FROM START"
002A30  1  4F 20 46 52  
002A34  1  4F 4D 20 53  
002A3C  1  0D 0A        	ACRLF
002A3E  1  00           .BYTE	0
002A3F  1               ; PAGE
002A3F  1               ; SUBTTL	THE NEXT CODE IS THE "NEXT CODE"
002A3F  1               ;
002A3F  1               ; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
002A3F  1               ;
002A3F  1               ; LOW ADDRESS
002A3F  1               ;	TOKEN (FORTK) 1 BYTE
002A3F  1               ;	A POINTER TO THE LOOP VARIABLE 2 BYTES
002A3F  1               ;	THE STEP 4+ADDPRC BYTES
002A3F  1               ;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
002A3F  1               ;	THE UPPER VALUE (PACKED) 4+ADDPRC BYTES
002A3F  1               ;	THE LINE NUMBER OF THE "FOR" STATEMENT 2 BYTES
002A3F  1               ;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
002A3F  1               ; HIGH ADDRESS
002A3F  1               ;
002A3F  1               ; TOTAL 16+2*ADDPRC BYTES.
002A3F  1               ;
002A3F  1  D0 04        NEXT:	BNE	GETFOR
002A41  1  A0 00 F0 03  	LDY	#0		;WITHOUT ARG CALL "FNDFOR" WITH
002A45  1               	BEQA	STXFOR		;[FORPNT]=0.
002A45  1  20 23 2D     GETFOR: JSR	PTRGET		;GET A POINTER TO LOOP VARIABLE
002A48  1  85 98 84 99  STXFOR: STWD	FORPNT		;INTO "FORPNT".
002A4C  1  20 A1 21     	JSR	FNDFOR		;FIND THE MATCHING ENTRY IF ANY.
002A4F  1  F0 04        	BEQ	HAVFOR
002A51  1  A2 00        	LDX	#ERRNF		;"NEXT WITHOUT FOR".
002A53  1  F0 66        ERRGO5: BEQ	ERRGO4
002A55  1  9A           HAVFOR: TXS			;SETUP STACK. CHOP FIRST.
002A56  1  8A           	TXA
002A57  1  18           	CLC
002A58  1  69 04        	ADC	#4		;POINT TO INCREMENT
002A5A  1  48           	PHA			;SAVE THIS POINTER TO RESTORE TO [A]
002A5B  1  69 06        	ADC	#5+ADDPRC	;POINT TO UPPER LIMIT
002A5D  1  85 73        	STA	INDEX2		;SAVE AS INDEX
002A5F  1  68           	PLA			;RESTORE POINTER TO INCREMENT
002A60  1  A0 01        	LDY	#1		;SET HI ADDR OF THING TO MOVE.
002A62  1  20 21 38     	JSR	MOVFM		;GET QUANTITY INTO THE FAC.
002A65  1  BA           	TSX
002A66  1  BD 09 01     	LDA	257+7+ADDPRC,X  ;SET SIGN CORRECTLY.
002A69  1  85 B5        	STA	FACSGN
002A6B  1  A5 98 A4 99  	LDWD	FORPNT
002A6F  1  20 E6 34     	JSR	FADD		;ADD INC TO LOOP VARIABLE.
002A72  1  20 4F 38     	JSR	MOVVF		;PACK THE FAC INTO MEMORY.
002A75  1  A0 01        	LDY	#1
002A77  1  20 DC 38     	JSR	FCOMPN		;COMPARE FAC WITH UPPER VALUE.
002A7A  1  BA           	TSX
002A7B  1  38           	SEC
002A7C  1  FD 09 01     	SBC	257+7+ADDPRC,X  ;SUBTRACT SIGN OF INC FROM SIGN OF
002A7F  1               				;OF (CURRENT VALUE-FINAL VALUE).
002A7F  1  F0 17        	BEQ	LOOPDN		;IF SIGN (FINAL-CURRENT)-SIGN STEP=0
002A81  1               				;THEN LOOP IS DONE.
002A81  1  BD 0F 01     	LDA	2*ADDPRC+12+257,X
002A84  1  85 88        	STA	CURLIN		;STORE LINE NUMBER OF "FOR" STATEMENT.
002A86  1  BD 10 01     	LDA	257+13+(2*ADDPRC),X
002A89  1  85 89        	STA	CURLIN+1
002A8B  1  BD 12 01     	LDA	2*ADDPRC+15+257,X
002A8E  1  85 C9        	STA	TXTPTR		;STORE TEXT PNTR INTO "FOR" STATEMENT.
002A90  1  BD 11 01     	LDA	2*ADDPRC+14+257,X
002A93  1  85 CA        	STA	TXTPTR+1
002A95  1  4C 89 25     NEWSGO: JMP	NEWSTT		;PROCESS NEXT STATEMENT.
002A98  1  8A           LOOPDN: TXA
002A99  1  69 11        	ADC	#2*ADDPRC+15		;ADDS 16 WITH CARRY.
002A9B  1  AA           	TAX
002A9C  1  9A           	TXS			;NEW STACK PNTR.
002A9D  1  20 C8 00     	JSR	CHRGOT
002AA0  1  C9 2C        	CMP	#44		;COMMA AT END?
002AA2  1  D0 F1        	BNE	NEWSGO
002AA4  1  20 C2 00     	JSR	CHRGET
002AA7  1  20 45 2A     	JSR	GETFOR		;DO NEXT BUT DON'T ALLOW BLANK VARIABLE
002AAA  1               				;PNTR. [VARPNT] IS THE STK PNTR WHICH
002AAA  1               				;NEVER MATCHES ANY POINTER.
002AAA  1               				;JSR TO PUT ON DUMMY NEWSTT ADDR.
002AAA  1               ; SUBTTL FORMULA EVALUATION CODE.
002AAA  1               ;
002AAA  1               ; THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
002AAA  1               ; [C] IS NOT PRESERVED.
002AAA  1               ;
002AAA  1  20 BE 2A     FRMNUM: JSR	FRMEVL
002AAD  1  18 24        CHKNUM: CLC
002AAF  1               	SKIP1
002AAF  1  38           CHKSTR: SEC			;SET CARRY.
002AB0  1  24 11        CHKVAL: BIT	VALTYP		;WILL NOT F UP "VALTYP".
002AB2  1  30 03        	BMI	DOCSTR
002AB4  1  B0 03        	BCS	CHKERR
002AB6  1  60           CHKOK:	RTS
002AB7  1  B0 FD        DOCSTR: BCS	CHKOK
002AB9  1  A2 18        CHKERR: LDX	#ERRTM
002ABB  1  4C 4E 22     ERRGO4: JMP	ERROR
002ABE  1               ;
002ABE  1               ; THE FORMULA EVALUATOR STARTS WITH
002ABE  1               ; [TXTPTR] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
002ABE  1               ; AT THE END [TXTPTR] POINTS TO THE TERMINATOR.
002ABE  1               ; THE RESULT IS LEFT IN THE FAC.
002ABE  1               ; ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
002ABE  1               ;
002ABE  1               ; THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
002ABE  1               ; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
002ABE  1               ; EACH OPERATOR.
002ABE  1               ; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
002ABE  1               ;	THE ADDRESS OF THE OPERATOR ROUTINE.
002ABE  1               ;	THE FLOATING POINT TEMPORARY RESULT.
002ABE  1               ;	THE PRECEDENCE OF THE OPERATOR.
002ABE  1               ;
002ABE  1  A6 C9        FRMEVL: LDX	TXTPTR
002AC0  1  D0 02        	BNE	FRMEV1
002AC2  1  C6 CA        	DEC	TXTPTR+1
002AC4  1  C6 C9        FRMEV1: DEC	TXTPTR
002AC6  1  A2 00 24     	LDX	#0		;INITIAL DUMMY PRECEDENCE IS 0.
002AC9  1               	SKIP1
002AC9  1  48           LPOPER: PHA			;SAVE LOW PRECEDENCE. (MASK.)
002ACA  1  8A           	TXA
002ACB  1  48           	PHA			;SAVE HIGH PRECEDENCE.
002ACC  1  A9 01        	LDA	#1
002ACE  1  20 12 22     	JSR	GETSTK		;MAKE SURE THERE IS ROOM FOR
002AD1  1               				;RECURSIVE CALLS.
002AD1  1  20 A3 2B     	JSR	EVAL		;EVALUATE SOMETHING.
002AD4  1  A9 00 85 9C  	CLR	OPMASK		;PREPARE TO BUILD MASK MAYBE.
002AD8  1  20 C8 00     TSTOP:	JSR	CHRGOT		;REGET LAST CHARACTER.
002ADB  1  38           LOPREL: SEC			;PREP TO SUBTRACT.
002ADC  1  E9 AA        	SBC	#GREATK		;IS CURRENT CHARACTER A RELATION?
002ADE  1  90 17        	BCC	ENDREL		;NO. RELATIONS ALL THROUGH.
002AE0  1  C9 03        	CMP	#LESSTK-GREATK+1 ;REALLY RELATIONAL?
002AE2  1  B0 13        	BCS	ENDREL		;NO -- JUST BIG.
002AE4  1  C9 01        	CMP	#1		;RESET CARRY FOR ZERO ONLY.
002AE6  1  2A           	ROL	A 		;0 TO 1, 1 TO 2, 2 TO 4.
002AE7  1  49 01        	EOR	#1
002AE9  1  45 9C        	EOR	OPMASK		;BRING IN THE OLD BITS.
002AEB  1  C5 9C        	CMP	OPMASK		;MAKE SURE THE NEW MASK IS BIGGER.
002AED  1  90 61        	BCC	SNERR5		;SYNTAX ERROR. BECAUSE TWO OF THE SAME.
002AEF  1  85 9C        	STA	OPMASK		;SAVE MASK.
002AF1  1  20 C2 00     	JSR	CHRGET
002AF4  1  4C DB 2A     	JMP	LOPREL		;GET THE NEXT CANDIDATE.
002AF7  1  A6 9C        ENDREL: LDX	OPMASK		;WERE THERE ANY?
002AF9  1  D0 2C        	BNE	FINREL		;YES, HANDLE AS SPECIAL OP.
002AFB  1  B0 7B        	BCS	QOP		;NOT AN OPERATOR.
002AFD  1  69 07        	ADC	#GREATK-PLUSTK
002AFF  1  90 77        	BCC	QOP		;NOT AN OPERATOR.
002B01  1  65 11        	ADC	VALTYP		;[C]=1.
002B03  1  D0 03 4C BB  	JEQ	CAT		;ONLY IF [A]=0 AND [VALTYP]=-1 (A STR).
002B07  1  32           
002B08  1  69 FF        	ADC	#$FF		;GET BACK ORIGINAL [A].
002B0A  1  85 71        	STA	INDEX1
002B0C  1  0A           	ASL	A 		;MULTIPLY BY 2.
002B0D  1  65 71        	ADC	INDEX1		;BY THREE.
002B0F  1  A8           	TAY			;SET UP FOR LATER.
002B10  1  68           QPREC:	PLA			;GET PREVIOUS PRECEDENCE.
002B11  1  D9 66 20     	CMP	OPTAB,Y		;IS OLD PRECEDENCE GREATER OR EQUAL?
002B14  1  B0 67        	BCS	QCHNUM		;YES, GO OPERATE.
002B16  1  20 AD 2A     	JSR	CHKNUM		;CAN'T BE STRING HERE.
002B19  1  48           DOPREC: PHA			;SAVE OLD PRECEDENCE.
002B1A  1  20 40 2B     NEGPRC: JSR	DOPRE1		;SET A RETURN ADDRESS FOR OP.
002B1D  1  68           	PLA			;PULL OFF PREVIOUS PRECEDENCE.
002B1E  1  A4 9A        	LDY	OPPTR		;GET POINTER TO OP.
002B20  1  10 17        	BPL	QPREC1		;THAT'S A REAL OPERATOR.
002B22  1  AA           	TAX			;DONE ?
002B23  1  F0 56        	BEQ	QOPGO		;DONE !
002B25  1  D0 5F        	BNE	PULSTK
002B27  1  46 11        FINREL: LSR	VALTYP		;GET VALUE TYPE INTO "C".
002B29  1  8A           	TXA
002B2A  1  2A           	ROL	A 		;PUT VALTYP INTO LOW ORDER BIT OF MASK.
002B2B  1  A6 C9        	LDX	TXTPTR		;DECREMENT TEXT POINTER.
002B2D  1  D0 02        	BNE	FINRE2
002B2F  1  C6 CA        	DEC	TXTPTR+1
002B31  1  C6 C9        FINRE2: DEC	TXTPTR
002B33  1  A0 1B        	LDY	#PTDORL-OPTAB	;MAKE [YREG] POINT AT OPERATOR ENTRY.
002B35  1  85 9C        	STA	OPMASK		;SAVE THE OPERATION MASK.
002B37  1  D0 D7        	BNE	QPREC		;SAVE IT ALL. BR ALWAYS.
002B39  1               				;NOTE B7(VALTYP)=0 SO CHKNUM CALL IS OK.
002B39  1  D9 66 20     QPREC1: CMP	OPTAB,Y		;LAST PRECEDENCE IS GREATER?
002B3C  1  B0 48        	BCS	PULSTK		;YES, GO OPERATE.
002B3E  1  90 D9        	BCC	DOPREC		;NO SAVE ARGUMENT AND GET OTHER OPERAND.
002B40  1  B9 68 20     DOPRE1: LDA	OPTAB+2,Y
002B43  1  48           	PHA			;DISP ADDR GOES ONTO STACK.
002B44  1  B9 67 20     	LDA	OPTAB+1,Y
002B47  1  48           	PHA
002B48  1  20 53 2B     	JSR	PUSHF1		;SAVE FAC ON STACK UNPACKED.
002B4B  1  A5 9C        	LDA	OPMASK		;[ACCA] MAY BE MASK FOR REL.
002B4D  1  4C C9 2A     	JMP	LPOPER
002B50  1  4C 0F 2C     SNERR5: JMP	SNERR		;GO TO AN ERROR.
002B53  1  A5 B5        PUSHF1: LDA	FACSGN
002B55  1  BE 66 20     	LDX	OPTAB,Y 	;GET HIGH PRECEDENCE.
002B58  1  A8           PUSHF:	TAY			;GET POINTER INTO STACK.
002B59  1  68           	PLA
002B5A  1  85 71        	STA	INDEX1
002B5C  1  E6 71        	INC	INDEX1
002B5E  1  68           	PLA
002B5F  1  85 72        	STA	INDEX1+1
002B61  1  98           	TYA
002B62  1               				;STORE FAC ON STACK UNPACKED.
002B62  1  48           	PHA			;START WITH SIGN SET UP.
002B63  1  20 9A 38     FORPSH: JSR	ROUND		;PUT ROUNDED FAC ON STACK.
002B66  1  A5 B4        	LDA	FACLO		;ENTRY POINT TO SKIP STORING SIGN.
002B68  1  48           	PHA
002B69  1  A5 B3        	LDA	FACMO
002B6B  1  48           	PHA
002B6C  1               .IF	ADDPRC <> 0
002B6C  1  A5 B2        	LDA	FACMOH
002B6E  1  48           	PHA
002B6F  1               .ENDIF
002B6F  1  A5 B1        	LDA	FACHO
002B71  1  48           	PHA
002B72  1  A5 B0        	LDA	FACEXP
002B74  1  48           	PHA
002B75  1  6C 71 00     	JMPD	INDEX1		;RETURN.
002B78  1  A0 FF        QOP:	LDY	#255
002B7A  1  68           	PLA			;GET HIGH PRECEDENCE OF LAST OP.
002B7B  1  F0 23        QOPGO:	BEQ	QOPRTS		;DONE !
002B7D  1  C9 64        QCHNUM: CMP	#100		;RELATIONAL OPERATOR?
002B7F  1  F0 03        	BEQ	UNPSTK		;YES, DON'T CHECK OPERAND.
002B81  1  20 AD 2A     	JSR	CHKNUM		;MUST BE NUMBER.
002B84  1  84 9A        UNPSTK: STY	OPPTR		;SAVE OPERATOR'S POINTER FOR NEXT TIME.
002B86  1  68           PULSTK: PLA			;GET MASK FOR REL OP IF IT IS ONE.
002B87  1  4A           	LSR	A 		;SETUP [C] FOR DOREL'S "CHKVAL".
002B88  1  85 16        	STA	DOMASK		;SAVE FOR "DOCMP".
002B8A  1  68           	PLA			;UNPACK STACK INTO ARG.
002B8B  1  85 B8        	STA	ARGEXP
002B8D  1  68           	PLA
002B8E  1  85 B9        	STA	ARGHO
002B90  1               .IF	ADDPRC <> 0
002B90  1  68           	PLA
002B91  1  85 BA        	STA	ARGMOH
002B93  1               .ENDIF
002B93  1  68           	PLA
002B94  1  85 BB        	STA	ARGMO
002B96  1  68           	PLA
002B97  1  85 BC        	STA	ARGLO
002B99  1  68           	PLA
002B9A  1  85 BD        	STA	ARGSGN
002B9C  1  45 B5        	EOR	FACSGN		;GET PROBABLE RESULT SIGN.
002B9E  1  85 BE        	STA	ARISGN		;ARITHMETIC SIGN. USED BY
002BA0  1               				;ADD, SUB, MULT, DIV.
002BA0  1  A5 B0        QOPRTS: LDA	FACEXP		;GET IT AND SET CODES.
002BA2  1  60           UNPRTS: RTS			;RETURN.
002BA3  1               
002BA3  1  A9 00 85 11  EVAL:	CLR	VALTYP		;ASSUME VALUE WILL BE NUMERIC.
002BA7  1  20 C2 00     EVAL0:	JSR	CHRGET		;GET A CHARACTER.
002BAA  1  B0 03        	BCS	EVAL2
002BAC  1  4C 72 39     EVAL1:	JMP	FIN		;IT IS A NUMBER.
002BAF  1  20 AD 2D     EVAL2:	JSR	ISLETC		;VARIABLE NAME?
002BB2  1  B0 67        	BCS	ISVAR		;YES.
002BB4  1               .IF	REALIO-3 = 0
002BB4  1               	CMP	#PI
002BB4  1               	BNE	QDOT
002BB4  1               	LDWDI	PIVAL
002BB4  1               	JSR	MOVFM		;PUT VALUE IN FOR PI.
002BB4  1               	JMP	CHRGET
002BB4  1               PIVAL:	.BYTE $82
002BB4  1               .BYTE	$49
002BB4  1               .BYTE	$F
002BB4  1               .BYTE	$DA
002BB4  1               .BYTE	$A1
002BB4  1               .ENDIF
002BB4  1  C9 2E        QDOT:	CMP	#'.'		;LEADING CHARACTER OF CONSTANT?
002BB6  1  F0 F4        	BEQ	EVAL1
002BB8  1  C9 A4        	CMP	#MINUTK		;NEGATION?
002BBA  1  F0 58        	BEQ	DOMIN		;SHO IS.
002BBC  1  C9 A3        	CMP	#PLUSTK
002BBE  1  F0 E7        	BEQ	EVAL0
002BC0  1  C9 22        	CMP	#34		;A QUOTE? A STRING?
002BC2  1  D0 0F        	BNE	EVAL3
002BC4  1  A5 C9 A4 CA  STRTXT: LDWD	TXTPTR
002BC8  1  69 00        	ADC	#0		;TO INC, ADD C=1.
002BCA  1  90 01        	BCC	STRTX2
002BCC  1  C8           	INY
002BCD  1  20 04 31     STRTX2: JSR	STRLIT		;YES. GO PROCESS IT.
002BD0  1  4C 61 34     	JMP	ST2TXT
002BD3  1  C9 A1        EVAL3:	CMP	#NOTTK		;CHECK FOR "NOT" OPERATOR.
002BD5  1  D0 13        	BNE	EVAL4
002BD7  1  A0 18        	LDY	#NOTTAB-OPTAB		;"NOT" HAS PRECEDENCE 90.
002BD9  1  D0 3B        	BNE	GONPRC		;GO DO ITS EVALUATION.
002BDB  1  20 3D 2E     NOTOP:	JSR	AYINT		;INTEGERIZE.
002BDE  1  A5 B4        	LDA	FACLO		;GET THE ARGUMENT.
002BE0  1  49 FF        	EOR	#255
002BE2  1  A8           	TAY
002BE3  1  A5 B3        	LDA	FACMO
002BE5  1  49 FF        	EOR	#255
002BE7  1  4C 10 30     	JMP	GIVAYF		;FLOAT [Y,A] AS RESULT IN FAC.
002BEA  1               				;AND RETURN.
002BEA  1  C9 9E        EVAL4:	CMP	#FNTK		;USER-DEFINED FUNCTION?
002BEC  1  D0 03 4C 71  	JEQ	FNDOER
002BF0  1  30           
002BF1  1  C9 AD        	CMP	#ONEFUN		;A FUNCTION NAME?
002BF3  1  90 03        	BCC	PARCHK		;FUNCTIONS ARE THE HIGHEST NUMBERED
002BF5  1  4C 3F 2C     	JMP	ISFUN		;CHARACTERS SO NO NEED TO CHECK
002BF8  1               				;AN UPPER-BOUND.
002BF8  1  20 01 2C     PARCHK: JSR	CHKOPN		;ONLY POSSIBILITY LEFT IS
002BFB  1  20 BE 2A     	JSR	FRMEVL		;A FORMULA IN PARENTHESIS.
002BFE  1               				;RECURSIVELY EVALUATE THE FORMULA.
002BFE  1  A9 29 2C     CHKCLS: LDA	#41		;CHECK FOR A RIGHT PARENTHESE
002C01  1               	SKIP2
002C01  1  A9 28 2C     CHKOPN: LDA	#40
002C04  1               	SKIP2
002C04  1  A9 2C        CHKCOM: LDA	#44
002C06  1               ;
002C06  1               ; "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
002C06  1               ; IS THE SPECIFIC THING LOADED INTO ACCA JUST BEFORE THE CALL TO
002C06  1               ; "SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
002C06  1               ; OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
002C06  1               ;
002C06  1               ; [A]=NEW CHAR AND TXTPTR IS ADVANCED BY "CHRGET".
002C06  1               ;
002C06  1  A0 00        SYNCHR: LDY	#0
002C08  1  D1 C9        	CMPDY	TXTPTR		;CHARACTERS EQUAL?
002C0A  1  D0 03        	BNE	SNERR
002C0C  1  4C C2 00     CHRGO5: JMP	CHRGET
002C0F  1  A2 02        SNERR:	LDX	#ERRSN		;"SYNTAX ERROR"
002C11  1  4C 4E 22     	JMP	ERROR
002C14  1  A0 15        DOMIN:	LDY	#NEGTAB-OPTAB	;A PRECEDENCE BELOW "^".
002C16  1  68           GONPRC: PLA			;GET RID OF RTS ADDR.
002C17  1  68           	PLA
002C18  1  4C 1A 2B     	JMP	NEGPRC		;EVALUTE FOR NEGATION.
002C1B  1               
002C1B  1  20 23 2D     ISVAR:	JSR	PTRGET		;GET A PNTR TO VARIABLE.
002C1E  1  85 B3 84 B4  ISVRET: STWD	FACMO
002C22  1               .IF	(TIME|EXTIO) <> 0
002C22  1               	LDWD	VARNAM		;CHECK TIME,TIME$,STATUS.
002C22  1               .ENDIF
002C22  1  A6 11        	LDX	VALTYP
002C24  1  F0 05        	BEQ	GOOO		;THE STRING IS SET UP.
002C26  1  A2 00        	LDX	#0
002C28  1  86 BF        	STX	FACOV
002C2A  1               .IF	TIME <> 0
002C2A  1               	BIT	FACLO		;AN ARRAY?
002C2A  1               	BPL	STRRTS		;YES.
002C2A  1               	CMP	#'T'		;TI$?
002C2A  1               	BNE	STRRTS
002C2A  1               	CPY	#'I'+128
002C2A  1               	BNE	STRRTS
002C2A  1               	JSR	GETTIM		;YES. PUT TIME IN FACMOH-LO.
002C2A  1               	STY	TENEXP		;Y=0.
002C2A  1               	DEY
002C2A  1               	STY	FBUFPT
002C2A  1               	LDY	#6		;SIX	DIGITS TO PRINT.
002C2A  1               	STY	DECCNT
002C2A  1               	LDY	#FDCEND-FOUTBL
002C2A  1               	JSR	FOUTIM		;CONVERT TO ASCII.
002C2A  1               	JMP	TIMSTR
002C2A  1               .ENDIF
002C2A  1  60           STRRTS: RTS
002C2B  1               GOOO:
002C2B  1               .IF	INTPRC <> 0
002C2B  1  A6 12        	LDX	INTFLG
002C2D  1  10 0D        	BPL	GOOOOO
002C2F  1  A0 00        	LDY	#0
002C31  1  B1 B3        	LDADY	FACMO		;FETCH HIGH.
002C33  1  AA           	TAX
002C34  1  C8           	INY
002C35  1  B1 B3        	LDADY	FACMO
002C37  1  A8           	TAY			;PUT LOW IN Y.
002C38  1  8A           	TXA			;GET HIGH IN A.
002C39  1  4C 10 30     	JMP	GIVAYF		;FLOAT AND RETURN.
002C3C  1               .ENDIF
002C3C  1               GOOOOO:
002C3C  1               .IF	TIME <> 0
002C3C  1               	BIT	FACLO		;AN ARRAY?
002C3C  1               	BPL	GOMOVF		;YES.
002C3C  1               	CMP	#'T'
002C3C  1               	BNE	QSTATV
002C3C  1               	CPY	#'I'
002C3C  1               	BNE	GOMOVF
002C3C  1               	JSR	GETTIM
002C3C  1               	TYA			;FOR FLOATB.
002C3C  1               	LDX	#160		;SET EXPONNENT.
002C3C  1               	JMP	FLOATB
002C3C  1               GETTIM: LDWDI	CQTIMR-2
002C3C  1               	SEI			;TURN OF INT SYS.
002C3C  1               	JSR	MOVFM
002C3C  1               	CLI			;BACK ON.
002C3C  1               	STY	FACHO		;ZERO HIGHEST.
002C3C  1               	RTS
002C3C  1               .ENDIF
002C3C  1               QSTATV:
002C3C  1               .IF	EXTIO <> 0
002C3C  1               	CMP	#'S'
002C3C  1               	BNE	GOMOVF
002C3C  1               	CPY	#'T'
002C3C  1               	BNE	GOMOVF
002C3C  1               	LDA	CQSTAT
002C3C  1               	JMP	FLOAT
002C3C  1               GOMOVF:
002C3C  1               .ENDIF
002C3C  1               .IF	(TIME|EXTIO) <> 0
002C3C  1               	LDWD	FACMO
002C3C  1               .ENDIF
002C3C  1  4C 21 38     	JMP	MOVFM		;MOVE ACTUAL VALUE IN.
002C3F  1               				;AND RETURN.
002C3F  1               
002C3F  1  0A           ISFUN:	ASL	A 		;MULTIPLY BY TWO.
002C40  1  48           	PHA
002C41  1  AA           	TAX
002C42  1  20 C2 00     	JSR	CHRGET		;SET UP FOR SYNCHK.
002C45  1  E0 81        	CPX	#2*LASNUM-256+1	;IS IT PAST "LASNUM"?
002C47  1  90 20        	BCC	OKNORM		;NO, MUST BE NORMAL FUNCTION.
002C49  1               ;
002C49  1               ; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
002C49  1               ; THE RETURN ADDRESS OF THESE FUNCTIONS IS "CHKNUM"
002C49  1               ; WHICH ASCERTAINS THAT [VALTYP]=0  (NUMERIC).
002C49  1               ; NORMAL FUNCTIONS THAT RETURN STRING RESULTS
002C49  1               ; (E.G., CHR$) MUST POP OFF THAT RETURN ADDR AND
002C49  1               ; RETURN DIRECTLY TO "FRMEVL".
002C49  1               ;
002C49  1               ; THE SO-CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT,
002C49  1               ; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
002C49  1               ; MUST BE A NUMBER BETWEEN 0 AND 255.
002C49  1               ; THE CLOSED PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
002C49  1               ; TO "FRMEVL" WITH THE TEXT PNTR POINTING BEYOND THE ")".
002C49  1               ; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
002C49  1               ; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE
002C49  1               ; INTEGER ARGUMENT.
002C49  1               ;
002C49  1  20 01 2C     	JSR	CHKOPN		;CHECK FOR AN OPEN PARENTHESE
002C4C  1  20 BE 2A     	JSR	FRMEVL		;EAT OPEN PAREN AND FIRST ARG.
002C4F  1  20 04 2C     	JSR	CHKCOM		;TWO ARGS SO COMMA MUST DELIMIT.
002C52  1  20 AF 2A     	JSR	CHKSTR		;MAKE SURE FIRST WAS STRING.
002C55  1  68           	PLA			;GET FUNCTION NUMBER.
002C56  1  AA           	TAX
002C57  1  A5 B4 48 A5  	PSHWD	FACMO		;SAVE POINTER AT STRING DESCRIPTOR
002C5B  1  B3 48        
002C5D  1  8A           	TXA
002C5E  1  48           	PHA			;RESAVE FUNCTION NUMBER.
002C5F  1               				;THIS MUST BE ON STACK SINCE RECURSIVE.
002C5F  1  20 1C 34     	JSR	GETBYT		;[X]=VALUE OF FORMULA.
002C62  1  68           	PLA			;GET FUNCTION NUMBER.
002C63  1  A8           	TAY
002C64  1  8A           	TXA
002C65  1  48           	PHA
002C66  1  4C 6E 2C     	JMP	FINGO		;DISPATCH TO FUNCTION.
002C69  1  20 F8 2B     OKNORM: JSR	PARCHK		;READ A FORMULA SURROUNDED BY PARENS.
002C6C  1  68           	PLA			;GET DISPATCH FUNCTION.
002C6D  1  A8           	TAY
002C6E  1               ;	.OUT	.SPRINTF("FUNDSP=%d ONEFUN=%d", FUNDSP, ONEFUN)	;LGB - test point
002C6E  1  B9 DE 1F     FINGO:	LDA	FUNDSP-2*ONEFUN+256,Y 	;MODIFY DISPATCH ADDRESS.
002C71  1  85 A4        	STA	JMPER+1
002C73  1  B9 DF 1F     	LDA	FUNDSP-2*ONEFUN+257,Y
002C76  1  85 A5        	STA	JMPER+2
002C78  1  20 A3 00     	JSR	JMPER		;DISPATCH!
002C7B  1               				;STRING FUNCTIONS REMOVE THIS RET ADDR.
002C7B  1  4C AD 2A     	JMP	CHKNUM		;CHECK IT FOR NUMERICNESS AND RETURN.
002C7E  1               
002C7E  1  A0 FF 2C     OROP:	LDY	#255		;MUST ALWAYS COMPLEMENT..
002C81  1               	SKIP2
002C81  1  A0 00        ANDOP:	LDY	#0
002C83  1  84 0F        	STY	COUNT		;OPERATOR.
002C85  1  20 3D 2E     	JSR	AYINT		;[FACMO&LO]=INT VALUE AND CHECK SIZE.
002C88  1  A5 B3        	LDA	FACMO		;USE DEMORGAN'S LAW ON HIGH
002C8A  1  45 0F        	EOR	COUNT
002C8C  1  85 0D        	STA	INTEGR
002C8E  1  A5 B4        	LDA	FACLO		;AND LOW.
002C90  1  45 0F        	EOR	COUNT
002C92  1  85 0E        	STA	INTEGR+1
002C94  1  20 7B 38     	JSR	MOVFA
002C97  1  20 3D 2E     	JSR	AYINT		;[FACMO&LO]=INT OF ARG.
002C9A  1  A5 B4        	LDA	FACLO
002C9C  1  45 0F        	EOR	COUNT
002C9E  1  25 0E        	AND	INTEGR+1
002CA0  1  45 0F        	EOR	COUNT		;FINISH OUT DEMORGAN.
002CA2  1  A8           	TAY			;SAVE HIGH.
002CA3  1  A5 B3        	LDA	FACMO
002CA5  1  45 0F        	EOR	COUNT
002CA7  1  25 0D        	AND	INTEGR
002CA9  1  45 0F        	EOR	COUNT
002CAB  1  4C 10 30     	JMP	GIVAYF		;FLOAT [A.Y] AND RET TO USER.
002CAE  1               
002CAE  1               ;
002CAE  1               ; TIME TO PERFORM A RELATIONAL OPERATOR.
002CAE  1               ; [DOMASK] CONTAINS THE BITS AS TO WHICH RELATIONAL
002CAE  1               ; OPERATOR IT WAS. CARRY BIT ON=STRING COMPARE.
002CAE  1               ;
002CAE  1  20 B0 2A     DOREL:	JSR	CHKVAL		;CHECK FOR MATCH.
002CB1  1  B0 13        	BCS	STRCMP		;IT IS A STRING.
002CB3  1  A5 BD        	LDA	ARGSGN		;PACK ARG FOR FCOMP.
002CB5  1  09 7F        	ORA	#127
002CB7  1  25 B9        	AND	ARGHO
002CB9  1  85 B9        	STA	ARGHO
002CBB  1  A9 B8 A0 00  	LDWDI	ARGEXP
002CBF  1  20 DA 38     	JSR	FCOMP
002CC2  1  AA           	TAX
002CC3  1  4C F9 2C     	JMP	QCOMP
002CC6  1  A9 00 85 11  STRCMP: CLR	VALTYP		;RESULT WILL BE NUMERIC.
002CCA  1  C6 9C        	DEC	OPMASK		;TURN OFF VALTYP WHICH WAS STRING.
002CCC  1  20 24 33     	JSR	FREFAC		;FREE THE FACLO STRING.
002CCF  1  85 B0        	STA	DSCTMP		;SAVE FOR LATER.
002CD1  1  86 B1 84 B2  	STXY	DSCTMP+1
002CD5  1  A5 BB A4 BC  	LDWD	ARGMO		;GET POINTER TO OTHER STRING.
002CD9  1  20 28 33     	JSR	FRETMP		;FREES FIRST DESC POINTER.
002CDC  1  86 BB 84 BC  	STXY	ARGMO
002CE0  1  AA           	TAX			;COPY COUNT INTO X.
002CE1  1  38           	SEC
002CE2  1  E5 B0        	SBC	DSCTMP		;WHICH IS GREATER. IF 0, ALL SET UP.
002CE4  1  F0 08        	BEQ	STASGN		;JUST PUT SIGN OF DIFFERENCE AWAY.
002CE6  1  A9 01        	LDA	#1
002CE8  1  90 04        	BCC	STASGN		;SIGN IS POSITIVE.
002CEA  1  A6 B0        	LDX	DSCTMP		;LENGTH OF FAC IS SHORTER.
002CEC  1  A9 FF        	LDA	#$FF		;GET A MINUS 1 FOR NEGATIVES.
002CEE  1  85 B5        STASGN: STA	FACSGN		;KEEP FOR LATER.
002CF0  1  A0 FF        	LDY	#255		;SET POINTER TO FIRST STRING. (ARG.)
002CF2  1  E8           	INX			;TO LOOP PROPERLY.
002CF3  1  C8           NXTCMP: INY
002CF4  1  CA           	DEX			;ANY CHARACTERS LEFT TO COMPARE?
002CF5  1  D0 07        	BNE	GETCMP		;NOT DONE YET.
002CF7  1  A6 B5        	LDX	FACSGN		;USE SIGN OF LENGTH DIFFERENCE
002CF9  1               				;SINCE ALL CHARACTERS ARE THE SAME.
002CF9  1  30 0F        QCOMP:	BMI	DOCMP		;C IS ALWAYS SET THEN.
002CFB  1  18           	CLC
002CFC  1  90 0C        	BCC	DOCMP		;ALWAYS BRANCH.
002CFE  1  B1 BB        GETCMP: LDADY	ARGMO		;GET NEXT CHAR TO COMPARE.
002D00  1  D1 B1        	CMPDY	DSCTMP+1	;SAME?
002D02  1  F0 EF        	BEQ	NXTCMP		;YEP. TRY FURTHER.
002D04  1  A2 FF        	LDX	#$FF		;SET A POSITIVE DIFFERENCE.
002D06  1  B0 02        	BCS	DOCMP		;PUT STACK BACK TOGETHER.
002D08  1  A2 01        	LDX	#1		;SET A NEGATIVE DIFFERENCE.
002D0A  1  E8           DOCMP:	INX			;-1 TO 1, 0 TO 2, 1 TO 4.
002D0B  1  8A           	TXA
002D0C  1  2A           	ROL	A
002D0D  1  25 16        	AND	DOMASK
002D0F  1  F0 02        	BEQ	GOFLOT
002D11  1  A9 FF        	LDA	#$FF		;MAP 0 TO 0. ALL OTHERS TO -1.
002D13  1  4C BB 38     GOFLOT: JMP	FLOAT		;FLOAT THE ONE-BYTE RESULT INTO FAC.
002D16  1               
002D16  1               ; PAGE
002D16  1               ; SUBTTL	DIMENSION AND VARIABLE SEARCHING.
002D16  1               ;
002D16  1               ; THE "DIM" CODE SETS [DIMFLG] AND THEN FALLS INTO THE VARIABLE SEARCH
002D16  1               ; ROUTINE, WHICH LOOKS AT DIMFLG AT THREE DIFFERENT POINTS.
002D16  1               ;	1) IF AN ENTRY IS FOUND, "DIMFLG" BEING ON INDICATES
002D16  1               ;		A "DOUBLY" DIMENSIONED VARIABLE.
002D16  1               ;	2) WHEN A NEW ENTRY IS BEING BUILT "DIMFLG" BEING ON
002D16  1               ;		INDICTAES THE INDICES SHOULD BE USED FOR THE
002D16  1               ;		SIZE OF EACH INDEX. OTHERWISE THE DEFAULT OF TEN
002D16  1               ;		IS USED.
002D16  1               ;	3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF "DIMFLG" IS OFF
002D16  1               ;		WILL INDEXING BE DONE.
002D16  1               ;
002D16  1  20 04 2C     DIM3:	JSR	CHKCOM		;MUST BE A COMMA
002D19  1  AA           DIM:	TAX			;SET [ACCX] NONZERO.
002D1A  1               				;[ACCA] MUST BE NONZERO TO WORK RIGHT.
002D1A  1  20 28 2D     DIM1:	JSR	PTRGT1
002D1D  1  20 C8 00     DIMCON: JSR	CHRGOT		;GET LAST CHARACTER.
002D20  1  D0 F4        	BNE	DIM3
002D22  1  60           	RTS
002D23  1               ;
002D23  1               ; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
002D23  1               ; AND  PUT A POINTER TO ITS VALUE IN VARPNT. [TXTPTR]
002D23  1               ; POINTS TO THE TERMINATING CHARCTER.. NOT THAT EVALUATING SUBSCRIPTS
002D23  1               ; IN A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO "PTRGET" SO AT
002D23  1               ; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
002D23  1               ;
002D23  1  A2 00        PTRGET: LDX	#0		;MAKE [ACCX]=0.
002D25  1  20 C8 00     	JSR	CHRGOT		;RETRIEVE LAST CHARACTER.
002D28  1  86 10        PTRGT1: STX	DIMFLG		;STORE FLAG AWAY.
002D2A  1  85 94        PTRGT2: STA	VARNAM
002D2C  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER
002D2F  1               				;MAYBE WITH FUNCTION BIT OFF.
002D2F  1  20 AD 2D     	JSR	ISLETC		;CHECK FOR LETTER.
002D32  1  B0 03        	BCS	PTRGT3		;MUST HAVE A LETTER.
002D34  1  4C 0F 2C     INTERR: JMP	SNERR
002D37  1  A2 00        PTRGT3: LDX	#0		;ASSUME NO SECOND CHARACTER.
002D39  1  86 11        	STX	VALTYP		;DEFAULT IS NUMERIC.
002D3B  1               .IF	INTPRC <> 0
002D3B  1  86 12        	STX	INTFLG		;ASSUME FLOATING.
002D3D  1               .ENDIF
002D3D  1  20 C2 00     	JSR	CHRGET		;GET FOLLOWING CHARACTER.
002D40  1  90 05        	BCC	ISSEC		;CARRY RESET BY CHRGET IF NUMERIC.
002D42  1  20 AD 2D     	JSR	ISLETC		;SET CARRY IF NOT ALPHABETIC.
002D45  1  90 0B        	BCC	NOSEC		;ALLOW ALPHABETICS.
002D47  1  AA           ISSEC:	TAX			;IT IS A NUMBER -- SAVE IN ACCX.
002D48  1  20 C2 00     EATEM:	JSR	CHRGET		;LOOK AT NEXT CHARACTER.
002D4B  1  90 FB        	BCC	EATEM		;SKIP NUMERICS.
002D4D  1  20 AD 2D     	JSR	ISLETC
002D50  1  B0 F6        	BCS	EATEM		;SKIP ALPHABETICS.
002D52  1  C9 24        NOSEC:	CMP	#'$'		;IS IT A STRING?
002D54  1  D0 06        	BNE	NOTSTR		;IF NOT, [VALTYP]=0.
002D56  1  A9 FF        	LDA	#$FF		;SET [VALTYP]=255 (STRING !).
002D58  1  85 11        	STA	VALTYP
002D5A  1  D0 10        .IF	INTPRC <> 0
002D5C  1               	BNEA	TURNON		;ALWAYS GOES.
002D5C  1  C9 25        NOTSTR: CMP	#'%'		;INTEGER VARIABLE?
002D5E  1  D0 13        	BNE	STRNAM		;NO.
002D60  1  A5 14        	LDA	SUBFLG
002D62  1  D0 D0        	BNE	INTERR
002D64  1  A9 80        	LDA	#128
002D66  1  85 12        	STA	INTFLG		;SET FLAG.
002D68  1  05 94        	ORA	VARNAM		;TURN ON BOTH HIGH BITS.
002D6A  1  85 94        	STA	VARNAM
002D6C  1               .ENDIF
002D6C  1  8A           TURNON: TXA
002D6D  1  09 80        	ORA	#128		;TURN ON MSB OF SECOND CHARACTER.
002D6F  1  AA           	TAX
002D70  1  20 C2 00     	JSR	CHRGET		;GET CHARACTER AFTER $.
002D73  1               .IF	INTPRC = 0
002D73  1               NOTSTR:
002D73  1               .ENDIF
002D73  1  86 95        STRNAM: STX	VARNAM+1	;STORE AWAY SECOND CHARACTER.
002D75  1  38           	SEC
002D76  1  05 14        	ORA	SUBFLG		;ADD FLAG WHETHER TO ALLOW ARRAYS.
002D78  1  E9 28        	SBC	#40		;(CHECK FOR "(") WON'T MATCH IF SUBFLG SET.
002D7A  1  D0 03 4C 4F  	JEQ	ISARY		;IT IS!
002D7E  1  2E           
002D7F  1  A9 00 85 14  	CLR	SUBFLG		;ALLOW SUBSCRIPTS AGAIN.
002D83  1  A5 7C        	LDA	VARTAB		;PLACE TO START SEARCH.
002D85  1  A6 7D        	LDX	VARTAB+1
002D87  1  A0 00        	LDY	#0
002D89  1  86 AF        STXFND: STX	LOWTR+1
002D8B  1  85 AE        LOPFND: STA	LOWTR
002D8D  1  E4 7F        	CPX	ARYTAB+1	;AT END OF TABLE YET?
002D8F  1  D0 04        	BNE	LOPFN
002D91  1  C5 7E        	CMP	ARYTAB
002D93  1  F0 22        	BEQ	NOTFNS		;YES. WE COULDN'T FIND IT.
002D95  1  A5 94        LOPFN:	LDA	VARNAM
002D97  1  D1 AE        	CMPDY	LOWTR		;COMPARE HIGH ORDERS.
002D99  1  D0 08        	BNE	NOTIT		;NO COMPARISON.
002D9B  1  A5 95        	LDA	VARNAM+1
002D9D  1  C8           	INY
002D9E  1  D1 AE        	CMPDY	LOWTR		;AND THE LOW PART?
002DA0  1  F0 6A        	BEQ	FINPTR		;THAT'S IT ! THAT'S IT !
002DA2  1  88           	DEY
002DA3  1  18           NOTIT:	CLC
002DA4  1  A5 AE        	LDA	LOWTR
002DA6  1  69 07        	ADC	#6+ADDPRC	;MAKES NO DIF AMONG TYPES.
002DA8  1  90 E1        	BCC	LOPFND
002DAA  1  E8 D0 DC     	INX
002DAD  1               	BNEA	STXFND		;ALWAYS BRANCHES.
002DAD  1               
002DAD  1               ;
002DAD  1               ; TEST FOR A LETTER.	/ CARRY OFF= NOT A LETTER.
002DAD  1               ;			  CARRY ON= A LETTER.
002DAD  1               ;
002DAD  1  C9 41        ISLETC: CMP	#'A'
002DAF  1  90 05        	BCC	ISLRTS		;IF LESS THAN "A", RET.
002DB1  1  E9 5B        	SBC	#'Z'+1
002DB3  1  38           	SEC
002DB4  1  E9 A5        	SBC	#256-'Z'-1	;RESET CARRY IF [A] .GT. "Z".
002DB6  1  60           ISLRTS: RTS			;RETURN TO CALLER.
002DB7  1               
002DB7  1  68           NOTFNS: PLA			;CHECK WHO'S CALLING.
002DB8  1  48           	PHA			;RESTORE IT.
002DB9  1  C9 1D        	CMP	#ISVRET-1-(ISVRET-1)/256*256	;IS EVAL CALLING?
002DBB  1  D0 0D        	BNE	NOTEVL		;NO, CARRY ON.
002DBD  1               .IF	REALIO-3 <> 0
002DBD  1  BA           	TSX
002DBE  1  BD 02 01     	LDA	258,X
002DC1  1  C9 2C        	CMP	#(ISVRET-1)/256
002DC3  1  D0 05        	BNE	NOTEVL
002DC5  1               .ENDIF
002DC5  1  A9 8E A0 3B  LDZR:	LDWDI	ZERO		;SET UP PNTR TO SIMULATED ZERO.
002DC9  1  60           	RTS			;FOR STRINGS OR NUMERIC.
002DCA  1               				;AND FOR INTEGERS TOO.
002DCA  1               NOTEVL:
002DCA  1               .IF	(TIME|EXTIO) <> 0
002DCA  1               	LDWD	VARNAM
002DCA  1               .ENDIF
002DCA  1               .IF	TIME <> 0
002DCA  1               	CMP	#'T'
002DCA  1               	BNE	QSTAVR
002DCA  1               	CPY	#'I'+128
002DCA  1               	BEQ	LDZR
002DCA  1               	CPY	#'I'
002DCA  1               	BNE	QSTAVR
002DCA  1               .ENDIF
002DCA  1               .IF	(EXTIO|TIME) <> 0
002DCA  1               GOBADV: JMP	SNERR
002DCA  1               .ENDIF
002DCA  1               QSTAVR:
002DCA  1               .IF	EXTIO <> 0
002DCA  1               	CMP	#'S'
002DCA  1               	BNE	VAROK
002DCA  1               	CPY	#'T'
002DCA  1               	BEQ	GOBADV
002DCA  1               .ENDIF
002DCA  1  A5 7E A4 7F  VAROK:	LDWD	ARYTAB
002DCE  1  85 AE 84 AF  	STWD	LOWTR		;LOWEST THING TO MOVE.
002DD2  1  A5 80 A4 81  	LDWD	STREND		;GET HIGHEST ADDR TO MOVE.
002DD6  1  85 A9 84 AA  	STWD	HIGHTR
002DDA  1  18           	CLC
002DDB  1  69 07        	ADC	#6+ADDPRC
002DDD  1  90 01        	BCC	NOTEVE
002DDF  1  C8           	INY
002DE0  1  85 A7 84 A8  NOTEVE: STWD	HIGHDS		;PLACE TO STUFF IT.
002DE4  1  20 CF 21     	JSR	BLTU		;MOVE IT ALL.
002DE7  1               				;NOTE [Y,A] HAS [HIGHDS] FOR REASON.
002DE7  1  A5 A7 A4 A8  	LDWD	HIGHDS		;AND SET UP
002DEB  1  C8           	INY
002DEC  1  85 7E 84 7F  	STWD	ARYTAB		;NEW START OF ARRAY TABLE.
002DF0  1  A0 00        	LDY	#0		;GET ADDR OF VARIABLE ENTRY.
002DF2  1  A5 94        	LDA	VARNAM
002DF4  1  91 AE        	STADY	LOWTR
002DF6  1  C8           	INY
002DF7  1  A5 95        	LDA	VARNAM+1
002DF9  1  91 AE        	STADY	LOWTR		;STORE NAME OF VARIABLE.
002DFB  1  A9 00        	LDA	#0
002DFD  1  C8           	INY
002DFE  1  91 AE        	STADY	LOWTR
002E00  1  C8           	INY
002E01  1  91 AE        	STADY	LOWTR
002E03  1  C8           	INY
002E04  1  91 AE        	STADY	LOWTR
002E06  1  C8           	INY
002E07  1  91 AE        	STADY	LOWTR		;FOURTH ZERO FOR DEF FUNC.
002E09  1               .IF	ADDPRC <> 0
002E09  1  C8           	INY
002E0A  1  91 AE        	STADY	LOWTR
002E0C  1               .ENDIF
002E0C  1  A5 AE        FINPTR: LDA	LOWTR
002E0E  1  18           	CLC
002E0F  1  69 02        	ADC	#2
002E11  1  A4 AF        	LDY	LOWTR+1
002E13  1  90 01        	BCC	FINNOW
002E15  1  C8           	INY
002E16  1  85 96 84 97  FINNOW: STWD	VARPNT		;THIS IS IT.
002E1A  1  60           	RTS
002E1B  1               ; PAGE
002E1B  1               ; SUBTTL	MULTIPLE DIMENSION CODE.
002E1B  1  A5 0F        FMAPTR: LDA	COUNT
002E1D  1  0A           	ASL	A
002E1E  1  69 05        	ADC	#5		;POINT TO ENTRIES. C CLR'D BY ASL.
002E20  1  65 AE        	ADC	LOWTR
002E22  1  A4 AF        	LDY	LOWTR+1
002E24  1  90 01        	BCC	JSRGM
002E26  1  C8           	INY
002E27  1  85 A7 84 A8  JSRGM:	STWD	ARYPNT
002E2B  1  60           	RTS
002E2C  1               
002E2C  1  90 80 00 00  N32768: .BYTE	144,128,0,0	;-32768.	;LGB was "EXP" here
002E30  1               
002E30  1               ;
002E30  1               ; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
002E30  1               ; TURNS IT INTO A POSITIVE INTEGER
002E30  1               ; LEAVING THE RESULT IN FACMO&LO. NEGATIVE ARGUMENTS
002E30  1               ; ARE NOT ALLOWED.
002E30  1               ;
002E30  1  20 C2 00     INTIDX: JSR	CHRGET
002E33  1  20 BE 2A     	JSR	FRMEVL		;GET A NUMBER
002E36  1  20 AD 2A     POSINT: JSR	CHKNUM
002E39  1  A5 B5        	LDA	FACSGN
002E3B  1  30 0D        	BMI	NONONO		;IF NEGATIVE, BLOW HIM OUT.
002E3D  1  A5 B0        AYINT:	LDA	FACEXP
002E3F  1  C9 90        	CMP	#144		;FAC .GT. 32767?
002E41  1  90 09        	BCC	QINTGO
002E43  1  A9 2C A0 2E  	LDWDI	N32768		;GET ADDR OF -32768.
002E47  1  20 DA 38     	JSR	FCOMP		;SEE IF FAC=[[Y,A]].
002E4A  1  D0 7A        NONONO: BNE	FCERR		;NO, FAC IS TOO BIG.
002E4C  1  4C 1A 39     QINTGO: JMP	QINT		;GO TO QINT AND SHOVE IT.
002E4F  1               ;
002E4F  1               ; FORMAT OF ARRAYS IN CORE.
002E4F  1               ;
002E4F  1               ; DESCRIPTOR:
002E4F  1               ;	LOWBYTE = FIRST CHARACTER.
002E4F  1               ;	HIGHBYTE = SECOND CHARACTER (200 BIT IS STRING FLAG).
002E4F  1               ; LENGTH OF ARRAY IN CORE IN BYTES (INCLUDES EVERYTHING).
002E4F  1               ; NUMBER OF DIMENSIONS.
002E4F  1               ; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
002E4F  1               ; (2 BYTES EACH) OF THE MAX INDICE+1
002E4F  1               ; THE VALUES
002E4F  1               ;
002E4F  1  A5 10        ISARY:	LDA	DIMFLG
002E51  1               .IF	INTPRC <> 0
002E51  1  05 12        	ORA	INTFLG
002E53  1               .ENDIF
002E53  1  48           	PHA			;SAVE [DIMFLG] FOR RECURSION.
002E54  1  A5 11        	LDA	VALTYP
002E56  1  48           	PHA			;SAVE [VALTYP] FOR RECURSION.
002E57  1  A0 00        	LDY	#0		;SET NUMBER OF DIMENSIONS TO ZERO.
002E59  1  98           INDLOP: TYA			;SAVE NUMBER OF DIMS.
002E5A  1  48           	PHA
002E5B  1  A5 95 48 A5  	PSHWD	VARNAM		;SAVE LOOKS.
002E5F  1  94 48        
002E61  1  20 30 2E     	JSR	INTIDX		;EVALUATE INDICE INTO FACMO&LO.
002E64  1  68 85 94 68  	PULWD	VARNAM		;GET BACK ALL... WE'RE HOME.
002E68  1  85 95        
002E6A  1  68           	PLA			;(# OF DIMS).
002E6B  1  A8           	TAY
002E6C  1  BA           	TSX
002E6D  1  BD 02 01     	LDA	258,X
002E70  1  48           	PHA			;PUSH DIMFLG AND VALTYP FURTHER.
002E71  1  BD 01 01     	LDA	257,X
002E74  1  48           	PHA
002E75  1  A5 B3        	LDA	INDICE		;PUT INDICE ONTO STACK.
002E77  1  9D 02 01     	STA	258,X 		;UNDER DIMFLG AND VALTYP.
002E7A  1  A5 B4        	LDA	INDICE+1
002E7C  1  9D 01 01     	STA	257,X
002E7F  1  C8           	INY			;INCREMENT # OF DIMS.
002E80  1  20 C8 00     	JSR	CHRGOT		;GET TERMINATING CHARACTER.
002E83  1  C9 2C        	CMP	#44		;A COMMA?
002E85  1  F0 D2        	BEQ	INDLOP		;YES.
002E87  1  84 0F        	STY	COUNT		;SAVE COUNT OF DIMS.
002E89  1  20 FE 2B     	JSR	CHKCLS		;MUST BE CLOSED PAREN.
002E8C  1  68           	PLA
002E8D  1  85 11        	STA	VALTYP		;GET VALTYP AND
002E8F  1  68           	PLA
002E90  1               .IF	INTPRC <> 0
002E90  1  85 12        	STA	INTFLG
002E92  1  29 7F        	AND	#127
002E94  1               .ENDIF
002E94  1  85 10        	STA	DIMFLG		;DIMFLG OFF STACK.
002E96  1  A6 7E        	LDX	ARYTAB		;PLACE TO START SEARCH.
002E98  1  A5 7F        	LDA	ARYTAB+1
002E9A  1  86 AE        LOPFDA: STX	LOWTR
002E9C  1  85 AF        	STA	LOWTR+1
002E9E  1  C5 81        	CMP	STREND+1	;END OF ARRAYS?
002EA0  1  D0 04        	BNE	LOPFDV
002EA2  1  E4 80        	CPX	STREND
002EA4  1  F0 39        	BEQ	NOTFDD		;A FINE THING! NO ARRAY!.
002EA6  1  A0 00        LOPFDV: LDY	#0
002EA8  1  B1 AE        	LDADY	LOWTR
002EAA  1  C8           	INY
002EAB  1  C5 94        	CMP	VARNAM		;COMPARE HIGH ORDERS.
002EAD  1  D0 06        	BNE	NMARY1		;NO WAY IS IT THIS. GET OUT OF HERE.
002EAF  1  A5 95        	LDA	VARNAM+1
002EB1  1  D1 AE        	CMPDY	LOWTR		;LOW ORDERS?
002EB3  1  F0 16        	BEQ	GOTARY		;WELL, HERE IT IS !!
002EB5  1  C8           NMARY1: INY
002EB6  1  B1 AE        	LDADY	LOWTR		;GET LENGTH.
002EB8  1  18           	CLC
002EB9  1  65 AE        	ADC	LOWTR
002EBB  1  AA           	TAX
002EBC  1  C8           	INY
002EBD  1  B1 AE        	LDADY	LOWTR
002EBF  1  65 AF        	ADC	LOWTR+1
002EC1  1  90 D7        	BCC	LOPFDA		;ALWAYS BRANCHES.
002EC3  1  A2 10 2C     BSERR:	LDX	#ERRBS		;GET BAD SUB ERROR NUMBER.
002EC6  1               	SKIP2
002EC6  1  A2 08        FCERR:	LDX	#ERRFC		;TOO BIG. "FUNCTION CALL" ERROR.
002EC8  1  4C 4E 22     ERRGO3: JMP	ERROR
002ECB  1  A2 12        GOTARY: LDX	#ERRDD		;PERHAPS A "RE-DIMENSION" ERROR
002ECD  1  A5 10        	LDA	DIMFLG		;TEST THE DIMFLG
002ECF  1  D0 F7        	BNE	ERRGO3
002ED1  1  20 1B 2E     	JSR	FMAPTR
002ED4  1  A5 0F        	LDA	COUNT		;GET NUMBER OF DIMS INPUT.
002ED6  1  A0 04        	LDY	#4
002ED8  1  D1 AE        	CMPDY	LOWTR		;# OF DIMS THE SAME?
002EDA  1  D0 E7        	BNE	BSERR		;SAME SO GO GET DEFINITION.
002EDC  1  4C 69 2F     	JMP	GETDEF
002EDF  1               
002EDF  1               ;
002EDF  1               ; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE.
002EDF  1               ;
002EDF  1               ; BUILDING AN ENTRY.
002EDF  1               ;
002EDF  1               ;	PUT DOWN THE DESCRIPTOR.
002EDF  1               ;	SETUP NUMBER OF DIMENSIONS.
002EDF  1               ;	MAKE SURE THERE IS ROOM FOR THE NEW ENTRY.
002EDF  1               ;	REMEMBER "VARPNT".
002EDF  1               ;	TALLY=4.
002EDF  1               ;	SKIP 2 LOCS FOR LATER FILL IN OF SIZE.
002EDF  1               ; LOOP: GET AN INDICE
002EDF  1               ;	PUT DOWN NUMBER+1 AND INCREMENT VARPTR.
002EDF  1               ;	TALLY=TALLY*NUMBER+1.
002EDF  1               ;	DECREMENT NUMBER-DIMS.
002EDF  1               ;	BNE LOOP
002EDF  1               ;	CALL "REASON" WITH [Y,A] REFLECTING LAST LOC OF VARIABLE.
002EDF  1               ;	UPDATE STREND.
002EDF  1               ;	ZERO ALL.
002EDF  1               ;	MAKE TALLY INCLUDE MAXDIMS AND DESCRIPTOR.
002EDF  1               ;	PUT DOWN TALLY.
002EDF  1               ;	IF CALLED BY DIMENSION, RETURN.
002EDF  1               ;	OTHERWISE INDEX INTO THE VARIABLE AS IF IT
002EDF  1               ;	 WERE FOUND ON THE INITIAL SEARCH.
002EDF  1               ;
002EDF  1  20 1B 2E     NOTFDD: JSR	FMAPTR		;FORM ARYPNT.
002EE2  1  20 1F 22     	JSR	REASON
002EE5  1  A9 00        	LDA	#0
002EE7  1  A8           	TAY
002EE8  1  85 C1        	STA	CURTOL+1
002EEA  1               .IF	ADDPRC = 0
002EEA  1               	LDX	#4
002EEA  1               .ENDIF
002EEA  1               .IF	ADDPRC <> 0
002EEA  1  A2 05        	LDX	#5
002EEC  1               .ENDIF
002EEC  1  A5 94        	LDA	VARNAM		;THIS CODE ONLY WORKS FOR INTPRC=1
002EEE  1  91 AE        	STADY	LOWTR		;IF ADDPRC=1.
002EF0  1               .IF	ADDPRC <> 0
002EF0  1  10 01        	BPL	NOTFLT
002EF2  1  CA           	DEX
002EF3  1               .ENDIF
002EF3  1  C8           NOTFLT: INY
002EF4  1  A5 95        	LDA	VARNAM+1
002EF6  1  91 AE        	STADY	LOWTR
002EF8  1  10 02        	BPL	STOMLT
002EFA  1  CA           	DEX
002EFB  1               .IF	ADDPRC <> 0
002EFB  1  CA           	DEX
002EFC  1               .ENDIF
002EFC  1  86 C0        STOMLT: STX	CURTOL
002EFE  1  A5 0F        	LDA	COUNT
002F00  1  C8 C8 C8     	REPEAT	3,{INY}
002F03  1  91 AE        	STADY	LOWTR		;SAVE NUMBER OF DIMENSIONS.
002F05  1  A2 0B        LOPPTA: LDX	#11		;DEFAULT SIZE.
002F07  1  A9 00        	LDA	#0
002F09  1  24 10        	BIT	DIMFLG
002F0B  1  50 08        	BVC	NOTDIM		;NOT IN A DIM STATEMENT.
002F0D  1  68           	PLA			;GET LOW ORDER OF INDICE.
002F0E  1  18           	CLC
002F0F  1  69 01        	ADC	#1
002F11  1  AA           	TAX
002F12  1  68           	PLA			;GET HIGH PART OF INDICE.
002F13  1  69 00        	ADC	#0
002F15  1  C8           NOTDIM: INY
002F16  1  91 AE        	STADY	LOWTR		;STORE HIGH PART OF INDICE.
002F18  1  C8           	INY
002F19  1  8A           	TXA
002F1A  1  91 AE        	STADY	LOWTR		;STORE LOW ORDER OF INDICE.
002F1C  1  20 CB 2F     	JSR	UMULT		;[X,A]=[CURTOL]*[LOWTR,Y]
002F1F  1  86 C0        	STX	CURTOL		;SAVE NEW TALLY.
002F21  1  85 C1        	STA	CURTOL+1
002F23  1  A4 71        	LDY	INDEX
002F25  1  C6 0F        	DEC	COUNT		;ANY MORE INDICES LEFT?
002F27  1  D0 DC        	BNE	LOPPTA		;YES.
002F29  1  65 A8        	ADC	ARYPNT+1
002F2B  1  B0 5D        	BCS	OMERR1		;OVERFLOW.
002F2D  1  85 A8        	STA	ARYPNT+1	;COMPUTE WHERE TO ZERO.
002F2F  1  A8           	TAY
002F30  1  8A           	TXA
002F31  1  65 A7        	ADC	ARYPNT
002F33  1  90 03        	BCC	GREASE
002F35  1  C8           	INY
002F36  1  F0 52        	BEQ	OMERR1
002F38  1  20 1F 22     GREASE: JSR	REASON		;GET ROOM.
002F3B  1  85 80 84 81  	STWD	STREND		;NEW END OF STORAGE.
002F3F  1  A9 00        	LDA	#0		;STORING [ACCA] IS FASTER THAN CLEAR.
002F41  1  E6 C1        	INC	CURTOL+1
002F43  1  A4 C0        	LDY	CURTOL
002F45  1  F0 05        	BEQ	DECCUR
002F47  1  88           ZERITA: DEY
002F48  1  91 A7        	STADY	ARYPNT
002F4A  1  D0 FB        	BNE	ZERITA		;NO. CONTINUE.
002F4C  1  C6 A8        DECCUR: DEC	ARYPNT+1
002F4E  1  C6 C1        	DEC	CURTOL+1
002F50  1  D0 F5        	BNE	ZERITA		;DO ANOTHER BLOCK.
002F52  1  E6 A8        	INC	ARYPNT+1	;BUMP BACK UP. WILL USE LATER.
002F54  1  38           	SEC
002F55  1  A5 80        	LDA	STREND		;RESTORE [ACCA].
002F57  1  E5 AE        	SBC	LOWTR		;DETERMINE LENGTH.
002F59  1  A0 02        	LDY	#2
002F5B  1  91 AE        	STADY	LOWTR		;LOW.
002F5D  1  A5 81        	LDA	STREND+1
002F5F  1  C8           	INY
002F60  1  E5 AF        	SBC	LOWTR+1
002F62  1  91 AE        	STADY	LOWTR		;HIGH.
002F64  1  A5 10        	LDA	DIMFLG
002F66  1  D0 62        	BNE	DIMRTS		;BYE.
002F68  1  C8           	INY
002F69  1               ;
002F69  1               ; AT THIS POINT [LOWTR,Y] POINTS BEYOND THE SIZE TO THE NUMBER OF
002F69  1               ; DIMENSIONS. STRATEGY:
002F69  1               ;	NUMDIM=NUMBER OF DIMENSIONS.
002F69  1               ;	CURTOL=0.
002F69  1               ; INLPNM:GET A NEW INDICE.
002F69  1               ;	MAKE SURE INDICE IS NOT TOO BIG.
002F69  1               ;	MULTIPLY CURTOL BY CURMAX.
002F69  1               ;	ADD INDICE TO CURTOL.
002F69  1               ;	NUMDIM=NUMDIM-1.
002F69  1               ;	BNE	INLPNM.
002F69  1               ;	USE [CURTOL]*4 AS OFFSET.
002F69  1               ;
002F69  1  B1 AE        GETDEF: LDADY	LOWTR
002F6B  1  85 0F        	STA	COUNT		;SAVE A COUNTER.
002F6D  1  A9 00        	LDA	#0		;ZERO [CURTOL].
002F6F  1  85 C0        	STA	CURTOL
002F71  1  85 C1        INLPNM: STA	CURTOL+1
002F73  1  C8           	INY
002F74  1  68           	PLA			;GET LOW INDICE.
002F75  1  AA           	TAX
002F76  1  85 B3        	STA	INDICE
002F78  1  68           	PLA			;AND THE HIGH PART
002F79  1  85 B4        	STA	INDICE+1
002F7B  1  D1 AE        	CMPDY	LOWTR		;COMPARE WITH MAX INDICE.
002F7D  1  90 0E        	BCC	INLPN2
002F7F  1  D0 06        	BNE	BSERR7		;IF GREATER, "BAD SUBSCRIPT" ERROR.
002F81  1  C8           	INY
002F82  1  8A           	TXA
002F83  1  D1 AE        	CMPDY	LOWTR
002F85  1  90 07        	BCC	INLPN1
002F87  1  4C C3 2E     BSERR7: JMP	BSERR
002F8A  1  4C 4C 22     OMERR1: JMP	OMERR
002F8D  1  C8           INLPN2: INY
002F8E  1  A5 C1        INLPN1: LDA	CURTOL+1	;DON'T MULTIPLY IF CURTOL=0.
002F90  1  05 C0        	ORA	CURTOL
002F92  1  18           	CLC			;PREPARE TO GET INDICE BACK.
002F93  1  F0 0A        	BEQ	ADDIND		;GET HIGH PART OF INDICE BACK.
002F95  1  20 CB 2F     	JSR	UMULT		;MULTIPLY [CURTOL] BY [LOWTR,Y,Y+1].
002F98  1  8A           	TXA
002F99  1  65 B3        	ADC	INDICE		;ADD IN [INDICE].
002F9B  1  AA           	TAX
002F9C  1  98           	TYA
002F9D  1  A4 71        	LDY	INDEX1
002F9F  1  65 B4        ADDIND: ADC	INDICE+1
002FA1  1  86 C0        	STX	CURTOL
002FA3  1  C6 0F        	DEC	COUNT		;ANY MORE?
002FA5  1  D0 CA        	BNE	INLPNM		;YES.
002FA7  1  85 C1        	STA	CURTOL+1	;FIX ARRAY BUG ****
002FA9  1               .IF	ADDPRC = 0
002FA9  1               	LDX	#4
002FA9  1               .ENDIF
002FA9  1               .IF	ADDPRC <> 0
002FA9  1  A2 05        	LDX	#5		;THIS CODE ONLY WORKS FOR INTPRC=1
002FAB  1  A5 94        	LDA	VARNAM		;IF ADDPRC=1.
002FAD  1  10 01        	BPL	NOTFL1
002FAF  1  CA           	DEX
002FB0  1               .ENDIF
002FB0  1  A5 95        NOTFL1: LDA	VARNAM+1
002FB2  1  10 02        	BPL	STOML1
002FB4  1  CA           	DEX
002FB5  1               .IF	ADDPRC <> 0
002FB5  1  CA           	DEX
002FB6  1               .ENDIF
002FB6  1  86 77        STOML1: STX	ADDEND
002FB8  1  A9 00        	LDA	#0
002FBA  1  20 D4 2F     	JSR	UMULTD		;ON RTS, A&Y=HI . X=LO.
002FBD  1  8A           	TXA
002FBE  1  65 A7        	ADC	ARYPNT
002FC0  1  85 96        	STA	VARPNT
002FC2  1  98           	TYA
002FC3  1  65 A8        	ADC	ARYPNT+1
002FC5  1  85 97        	STA	VARPNT+1
002FC7  1  A8           	TAY
002FC8  1  A5 96        	LDA	VARPNT
002FCA  1  60           DIMRTS: RTS			;RETURN TO CALLER.
002FCB  1               ; SUBTTL	INTEGER ARITHMETIC ROUTINES.
002FCB  1               	;TWO BYTE UNSIGNED INTEGER MULTIPLY.
002FCB  1               	;THIS IS FOR MULTIPLY DIMENSIONED ARRAYS.
002FCB  1               	; [X,Y]=[X,A]=[CURTOL]*[LOWTR,Y,Y+1].
002FCB  1  84 71        UMULT:	STY	INDEX
002FCD  1  B1 AE        	LDADY	LOWTR
002FCF  1  85 77        	STA	ADDEND		;LOW, THEN HIGH.
002FD1  1  88           	DEY
002FD2  1  B1 AE        	LDADY	LOWTR		;PUT [LOWTR,Y,Y+1] IN FASTER MEMORY.
002FD4  1  85 78        UMULTD: STA	ADDEND+1
002FD6  1  A9 10        	LDA	#16
002FD8  1  85 AC        	STA	DECCNT
002FDA  1  A2 00        	LDX	#0		;CLR THE ACCS.
002FDC  1  A0 00        	LDY	#0		;RESULT INITIALLY ZERO.
002FDE  1  8A           UMULTC: TXA
002FDF  1  0A           	ASL	A 		;MULTIPLY BY TWO.
002FE0  1  AA           	TAX
002FE1  1  98           	TYA
002FE2  1  2A           	ROL	A
002FE3  1  A8           	TAY
002FE4  1  B0 A4        	BCS	OMERR1		;TWO MUCH !
002FE6  1  06 C0        	ASL	CURTOL
002FE8  1  26 C1        	ROL	CURTOL+1
002FEA  1  90 0B        	BCC	UMLCNT		;NOTHING IN THIS POSITION TO MULTIPLY.
002FEC  1  18           	CLC
002FED  1  8A           	TXA
002FEE  1  65 77        	ADC	ADDEND
002FF0  1  AA           	TAX
002FF1  1  98           	TYA
002FF2  1  65 78        	ADC	ADDEND+1
002FF4  1  A8           	TAY
002FF5  1  B0 93        	BCS	OMERR1		;MAN, JUST TOO MUCH !
002FF7  1  C6 AC        UMLCNT: DEC	DECCNT		;DONE?
002FF9  1  D0 E3        	BNE	UMULTC		;KEEP IT UP.
002FFB  1  60           UMLRTS: RTS			;YES, ALL DONE.
002FFC  1               ; PAGE
002FFC  1               ; SUBTTL	FRE FUNCTION AND INTEGER TO FLOATING ROUTINES.
002FFC  1  A5 11        FRE:	LDA	VALTYP
002FFE  1  F0 03        	BEQ	NOFREF
003000  1  20 24 33     	JSR	FREFAC
003003  1  20 9F 31     NOFREF: JSR	GARBA2
003006  1  38           	SEC
003007  1  A5 82        	LDA	FRETOP		;WE WANT
003009  1  E5 80        	SBC	STREND		;[FRETOP]-[STREND].
00300B  1  A8           	TAY
00300C  1  A5 83        	LDA	FRETOP+1
00300E  1  E5 81        	SBC	STREND+1
003010  1               
003010  1  A2 00        GIVAYF: LDX	#0
003012  1  86 11        	STX	VALTYP
003014  1  85 B1 84 B2  	STWD	FACHO
003018  1  A2 90        	LDX	#144		;SET EXPONENT TO 2^16.
00301A  1  4C C3 38     	JMP	FLOATS		;TURN IT TO A FLOATING PNT #.
00301D  1               
00301D  1  A4 18        POS:	LDY	TRMPOS		;GET POSITION.
00301F  1  A9 00 F0 ED  SNGFLT: LDA	#0
003023  1               	BEQA	GIVAYF		;FLOAT IT.
003023  1               ; PAGE
003023  1               ; SUBTTL	SIMPLE-USER-DEFINED-FUNCTION CODE.
003023  1               ;
003023  1               ; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
003023  1               ; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
003023  1               ;	DEF FNA(X)=X^2+X-2
003023  1               ; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS.
003023  1               ;
003023  1               ; IDEA: CREATE A SIMPLE VARIABLE ENTRY
003023  1               ; WHOSE FIRST CHARACTER HAS THE 200 BIT SET.
003023  1               ; THE VALUE WILL BE:
003023  1               ;
003023  1               ;	A TEXT PNTR TO THE FORMULA.
003023  1               ;	A PNTR TO THE ARGUMENT VARIABLE.
003023  1               ;
003023  1               ; FUNCTION NAMES CAN BE LIKE "FNA4".
003023  1               ;
003023  1               ;
003023  1               ; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE.
003023  1               ; AND COMPLAIN IF SO.
003023  1               ;
003023  1  A6 89        ERRDIR: LDX	CURLIN+1	;DIR MODE HAS [CURLIN]=0,255
003025  1  E8           	INX			;SO NOW, IS RESULT ZERO?
003026  1  D0 A2        	BNE	DIMRTS		;YES.
003028  1  A2 16 2C     	LDX	#ERRID		;INPUT DIRECT ERROR CODE.
00302B  1               	SKIP2
00302B  1  A2 20        ERRGUF: LDX	#ERRUF		;USER DEFINED FUNCTION NEVER DEFINED
00302D  1  4C 4E 22     ERRGO1: JMP	ERROR
003030  1               
003030  1  20 5E 30     DEF:	JSR	GETFNM		;GET A PNTR TO THE FUNCTION.
003033  1  20 23 30     	JSR	ERRDIR
003036  1  20 01 2C     	JSR	CHKOPN		;MUST HAVE "(".
003039  1  A9 80        	LDA	#128
00303B  1  85 14        	STA	SUBFLG		;PROHIBIT SUBSCRIPTED VARIABLES.
00303D  1  20 23 2D     	JSR	PTRGET		;GET PNTR TO ARGUMENT.
003040  1  20 AD 2A     	JSR	CHKNUM		;IS IT A NUMBER?
003043  1  20 FE 2B     	JSR	CHKCLS		;MUST HAVE ")"
003046  1  A9 AB 20 06  	SYNCHK	EQULTK		;MUST HAVE "=".
00304A  1  2C           
00304B  1               .IF	ADDPRC <> 0
00304B  1  48           	PHA			;PUT CRAZY BYTE ON.
00304C  1               .ENDIF
00304C  1  A5 97 48 A5  	PSHWD	VARPNT
003050  1  96 48        
003052  1  A5 CA 48 A5  	PSHWD	TXTPTR
003056  1  C9 48        
003058  1  20 CB 26     	JSR	DATA
00305B  1  4C CC 30     	JMP	DEFFIN
00305E  1               ;
00305E  1               ; SUBROUTINE TO GET A PNTR TO A FUNCTION NAME.
00305E  1               ;
00305E  1  A9 9E 20 06  GETFNM: SYNCHK	FNTK		;MUST START WITH FN.
003062  1  2C           
003063  1  09 80        	ORA	#128		;PUT FUNCTION BIT ON.
003065  1  85 14        	STA	SUBFLG
003067  1  20 2A 2D     	JSR	PTRGT2		;GET POINTER TO FUNCTION OR CREATE ANEW.
00306A  1  85 9D 84 9E  	STWD	DEFPNT
00306E  1  4C AD 2A     	JMP	CHKNUM		;MAKE SURE IT'S NOT A STRING AND RETURN.
003071  1               
003071  1  20 5E 30     FNDOER: JSR	GETFNM		;GET THE FUNCTION'S NAME.
003074  1  A5 9E 48 A5  	PSHWD	DEFPNT
003078  1  9D 48        
00307A  1  20 F8 2B     	JSR	PARCHK		;EVALUATE PARAMETER.
00307D  1  20 AD 2A     	JSR	CHKNUM
003080  1  68 85 9D 68  	PULWD	DEFPNT
003084  1  85 9E        
003086  1  A0 02        	LDY	#2
003088  1  B1 9D        	LDADY	DEFPNT		;GET POINTER TO VARIABLE.
00308A  1  85 96        	STA	VARPNT		;SAVE VARIABLE POINTER.
00308C  1  AA           	TAX
00308D  1  C8           	INY
00308E  1  B1 9D        	LDADY	DEFPNT
003090  1  F0 99        	BEQ	ERRGUF
003092  1  85 97        	STA	VARPNT+1
003094  1               .IF	ADDPRC <> 0
003094  1  C8           	INY			;SINCE DEF USES ONLY 4.
003095  1               .ENDIF
003095  1  B1 96        DEFSTF: LDADY	VARPNT
003097  1  48           	PHA			;PUSH IT ALL ON STACK.
003098  1  88           	DEY			;SINCE WE ARE RECURSING MAYBE.
003099  1  10 FA        	BPL	DEFSTF
00309B  1  A4 97        	LDY	VARPNT+1
00309D  1  20 53 38     	JSR	MOVMF		;PUT CURRENT FAC INTO OUR ARG VARIABLE.
0030A0  1  A5 CA 48 A5  	PSHWD	TXTPTR		;SAVE TEXT POINTER.
0030A4  1  C9 48        
0030A6  1  B1 9D        	LDADY	DEFPNT		;PNTR TO FUNCTION.
0030A8  1  85 C9        	STA	TXTPTR
0030AA  1  C8           	INY
0030AB  1  B1 9D        	LDADY	DEFPNT
0030AD  1  85 CA        	STA	TXTPTR+1
0030AF  1  A5 97 48 A5  	PSHWD	VARPNT		;SAVE VARIABLE POINTER.
0030B3  1  96 48        
0030B5  1  20 AA 2A     	JSR	FRMNUM		;EVALUATE FORMULA AND CHECK NUMERIC.
0030B8  1  68 85 9D 68  	PULWD	DEFPNT
0030BC  1  85 9E        
0030BE  1  20 C8 00     	JSR	CHRGOT
0030C1  1  F0 03 4C 0F  	JNE	SNERR		;IT DIDN'T TERMINATE. HUH?
0030C5  1  2C           
0030C6  1  68 85 C9 68  	PULWD	TXTPTR		;RESTORE TEXT PNTR.
0030CA  1  85 CA        
0030CC  1  A0 00        DEFFIN: LDY	#0
0030CE  1  68           	PLA			;GET OLD ARG VALUE OFF STACK
0030CF  1  91 9D        	STADY	DEFPNT		;AND PUT IT BACK IN VARIABLE.
0030D1  1  68           	PLA
0030D2  1  C8           	INY
0030D3  1  91 9D        	STADY	DEFPNT
0030D5  1  68           	PLA
0030D6  1  C8           	INY
0030D7  1  91 9D        	STADY	DEFPNT
0030D9  1  68           	PLA
0030DA  1  C8           	INY
0030DB  1  91 9D        	STADY	DEFPNT
0030DD  1               .IF	ADDPRC <> 0
0030DD  1  68           	PLA
0030DE  1  C8           	INY
0030DF  1  91 9D        	STADY	DEFPNT
0030E1  1               .ENDIF
0030E1  1  60           DEFRTS: RTS
0030E2  1               ; 	PAGE
0030E2  1               ; SUBTTL	STRING FUNCTIONS.
0030E2  1               ;
0030E2  1               ; THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING
0030E2  1               ; WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
0030E2  1               ; WOULD HAVE GIVEN.
0030E2  1               ;
0030E2  1  20 AD 2A     STR:	JSR	CHKNUM		;ARG HAS TO BE NUMERIC.
0030E5  1  A0 00        	LDY	#0
0030E7  1  20 5E 3A     	JSR	FOUTC		;DO ITS OUTPUT.
0030EA  1  68           	PLA
0030EB  1  68           	PLA
0030EC  1  A9 FF A0 00  TIMSTR: LDWDI	LOFBUF
0030F0  1  F0 12        
0030F2  1               	BEQA	STRLIT		;SCAN IT AND TURN IT INTO A STRING.
0030F2  1               ;
0030F2  1               ; "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND
0030F2  1               ; CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
0030F2  1               ;
0030F2  1  A6 B3 A4 B4  STRINI: LDXY	FACMO		;GET FACMO TO STORE IN DSCPNT.
0030F6  1  86 9F 84 A0  	STXY	DSCPNT		;RETAIN THE DESCRIPTOR POINTER.
0030FA  1  20 6D 31     STRSPA: JSR	GETSPA		;GET STRING SPACE.
0030FD  1  86 B1 84 B2  	STXY	DSCTMP+1	;SAVE LOCATION.
003101  1  85 B0        	STA	DSCTMP		;SAVE LENGTH.
003103  1  60           	RTS			;ALL DONE.
003104  1               ;
003104  1               ; "STRLT2" TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
003104  1               ; IS POINTED TO BY [Y,A] AND BUILDS A DESCRIPTOR FOR IT.
003104  1               ; THE DESCRIPTOR IS INITIALLY BUILT IN "DSCTMP", BUT "PUTNEW"
003104  1               ; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
003104  1               ; AT THE TEMPORARY IN FACMO&LO. THE CHARACTERS OTHER THAN
003104  1               ; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN "CHARAC"
003104  1               ; AND "ENDCHR". IF THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
003104  1               ; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE JSR. ON RETURN
003104  1               ; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
003104  1               ; BY [STRNG2].
003104  1               ;
003104  1  A2 22        STRLIT: LDX	#34		;ASSUME STRING ENDS ON QUOTE.
003106  1  86 0D        	STX	CHARAC
003108  1  86 0E        	STX	ENDCHR
00310A  1  85 BE 84 BF  STRLT2: STWD	STRNG1		;SAVE POINTER TO STRING.
00310E  1  85 B1 84 B2  	STWD	DSCTMP+1	;IN CASE NO STRCPY.
003112  1  A0 FF        	LDY	#255		;INITIALIZE CHARACTER COUNT.
003114  1  C8           STRGET: INY
003115  1  B1 BE        	LDADY	STRNG1		;GET CHARACTER.
003117  1  F0 0C        	BEQ	STRFI1		;IF ZERO.
003119  1  C5 0D        	CMP	CHARAC		;THIS TERMINATOR?
00311B  1  F0 04        	BEQ	STRFIN		;YES.
00311D  1  C5 0E        	CMP	ENDCHR
00311F  1  D0 F3        	BNE	STRGET		;LOOK FURTHER.
003121  1  C9 22        STRFIN: CMP	#34		;QUOTE?
003123  1  F0 01        	BEQ	STRFI2
003125  1  18           STRFI1: CLC			;NO, BACK UP.
003126  1  84 B0        STRFI2: STY	DSCTMP		;RETAIN COUNT.
003128  1  98           	TYA
003129  1  65 BE        	ADC	STRNG1		;WISHING TO SET [TXTPTR].
00312B  1  85 C0        	STA	STRNG2
00312D  1  A6 BF        	LDX	STRNG1+1
00312F  1  90 01        	BCC	STRST2
003131  1  E8           	INX
003132  1  86 C1        STRST2: STX	STRNG2+1
003134  1  A5 BF        	LDA	STRNG1+1	;IF PAGE 0, COPY SINCE IT IS EITHER
003136  1               				;A STRING CONSTANT IN BUF OR A STR$
003136  1               				;RESULT IN LOFBUF
003136  1               .IF	BUFPAG <> 0
003136  1               	BEQ	STRCP
003136  1               	CMP	#BUFPAG
003136  1               .ENDIF
003136  1  D0 0B        	BNE	PUTNEW
003138  1  98           STRCP:	TYA
003139  1  20 F2 30     	JSR	STRINI
00313C  1  A6 BE A4 BF  	LDXY	STRNG1
003140  1  20 06 33     	JSR	MOVSTR		;MOVE STRING.
003143  1               ;
003143  1               ; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP.
003143  1               ; SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT.
003143  1               ; PUT A POINTER TO THE DESCRIPTOR IN FACMO&LO AND FLAG THE
003143  1               ; RESULT AS TYPE STRING.
003143  1               ;
003143  1  A6 65        PUTNEW: LDX	TEMPPT		;POINTER TO FIRST FREE TEMP.
003145  1  E0 71        	CPX	#TEMPST+STRSIZ*NUMTMP
003147  1  D0 05        	BNE	PUTNW1
003149  1  A2 1C        	LDX	#ERRST		;STRING TEMPORARY ERROR.
00314B  1  4C 4E 22     ERRGO2: JMP	ERROR		;GO TELL HIM.
00314E  1  A5 B0        PUTNW1: LDA	DSCTMP
003150  1  95 00        	STA	0,X
003152  1  A5 B1        	LDA	DSCTMP+1
003154  1  95 01        	STA	1,X
003156  1  A5 B2        	LDA	DSCTMP+2
003158  1  95 02        	STA	2,X
00315A  1  A0 00        	LDY	#0
00315C  1  86 B3 84 B4  	STXY	FACMO
003160  1  84 BF        	STY	FACOV
003162  1  88           	DEY
003163  1  84 11        	STY	VALTYP		;TYPE IS "STRING".
003165  1  86 66        	STX	LASTPT		;SET POINTER TO LAST-USED TEMP.
003167  1  E8           	INX
003168  1  E8           	INX
003169  1  E8           	INX			;POINT FURTHER.
00316A  1  86 65        	STX	TEMPPT		;SAVE POINTER TO NEXT TEMP IF ANY.
00316C  1  60           	RTS			;ALL DONE.
00316D  1               
00316D  1               ;
00316D  1               ; GETSPA - GET SPACE FOR CHARACTER STRING.
00316D  1               ; MAY FORCE GARBAGE COLLECTION.
00316D  1               ;
00316D  1               ; # OF CHARACTERS (BYTES) IN ACCA.
00316D  1               ; RETURNS WITH POINTER IN [Y,X]. OTHERWISE (IF CAN'T GET
00316D  1               ; SPACE) BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
00316D  1               ; ALSO PRESERVES [ACCA] AND SETS [FRESPC]=[Y,X]=PNTR AT SPACE.
00316D  1               ;
00316D  1  46 13        GETSPA: LSR	GARBFL		;SIGNAL NO GARBAGE COLLECTION YET.
00316F  1  48           TRYAG2: PHA			;SAVE FOR LATER.
003170  1  49 FF        	EOR	#255
003172  1  38           	SEC			;ADD ONE TO COMPLETE NEGATION.
003173  1  65 82        	ADC	FRETOP
003175  1  A4 83        	LDY	FRETOP+1
003177  1  B0 01        	BCS	TRYAG3
003179  1  88           	DEY
00317A  1  C4 81        TRYAG3: CPY	STREND+1	;COMPARE HIGH ORDERS.
00317C  1  90 11        	BCC	GARBAG		;MAKE ROOM FOR MORE.
00317E  1  D0 04        	BNE	STRFRE		;SAVE NEW FRETOP.
003180  1  C5 80        	CMP	STREND		;COMPARE LOW ORDERS.
003182  1  90 0B        	BCC	GARBAG		;CLEAN UP.
003184  1  85 82 84 83  STRFRE: STWD	FRETOP		;SAVE NEW [FRETOP].
003188  1  85 84 84 85  	STWD	FRESPC		;PUT IT THERE OLD MAN.
00318C  1  AA           	TAX			;PRESERVE A IN X.
00318D  1  68           	PLA			;GET COUNT BACK IN ACCA.
00318E  1  60           	RTS			;ALL DONE.
00318F  1  A2 0C        GARBAG: LDX	#ERROM		;"OUT OF STRING SPACE"
003191  1  A5 13        	LDA	GARBFL
003193  1  30 B6        	BMI	ERRGO2
003195  1  20 9F 31     	JSR	GARBA2
003198  1  A9 80        	LDA	#128
00319A  1  85 13        	STA	GARBFL
00319C  1  68           	PLA			;GET BACK STRING LENGTH.
00319D  1  D0 D0        	BNE	TRYAG2		;ALWAYS BRANCHES.
00319F  1               GARBA2:				;START FROM TOP DOWN.
00319F  1               .IF	(REALIO|DISKO) = 0
00319F  1  A9 07        	LDA	#7		;TYPE "BELL".
0031A1  1  20 BD 28     	JSR	OUTDO
0031A4  1               .ENDIF
0031A4  1  A6 86        	LDX	MEMSIZ
0031A6  1  A5 87        	LDA	MEMSIZ+1
0031A8  1  86 82        FNDVAR: STX	FRETOP		;LIKE SO.
0031AA  1  85 83        	STA	FRETOP+1
0031AC  1  A0 00        	LDY	#0
0031AE  1  84 9E        	STY	GRBPNT+1
0031B0  1  84 9D        	STY	GRBPNT		;BOTH BYTES SET TO ZERO (FIX BUG)
0031B2  1  A5 80 A6 81  	LDWX	STREND
0031B6  1  85 AE 86 AF  	STWX	GRBTOP
0031BA  1  A9 68 A2 00  	LDWXI	TEMPST
0031BE  1  85 71 86 72  	STWX	INDEX1
0031C2  1  C5 65        TVAR:	CMP	TEMPPT		;DONE WITH TEMPS?
0031C4  1  F0 05        	BEQ	SVARS		;YEP.
0031C6  1  20 45 32     	JSR	DVAR
0031C9  1  F0 F7        	BEQ	TVAR		;LOOP.
0031CB  1  A9 07        SVARS:	LDA	#6+ADDPRC
0031CD  1  85 A2        	STA	FOUR6
0031CF  1  A5 7C A6 7D  	LDWX	VARTAB		;GET START OF SIMPLE VARIABLES.
0031D3  1  85 71 86 72  	STWX	INDEX1
0031D7  1  E4 7F        SVAR:	CPX	ARYTAB+1	;DONE WITH SIMPLE VARIABLES?
0031D9  1  D0 04        	BNE	SVARGO		;NO.
0031DB  1  C5 7E        	CMP	ARYTAB
0031DD  1  F0 05        	BEQ	ARYVAR		;YEP.
0031DF  1  20 3B 32     SVARGO: JSR	DVARS		;DO IT , AGAIN.
0031E2  1  F0 F3        	BEQ	SVAR		;LOOP.
0031E4  1  85 A7 86 A8  ARYVAR: STWX	ARYPNT		;SAVE FOR ADDITION.
0031E8  1  A9 03        	LDA	#STRSIZ
0031EA  1  85 A2        	STA	FOUR6
0031EC  1  A5 A7 A6 A8  ARYVA2: LDWX	ARYPNT		;GET THE POINTER TO VARIABLE.
0031F0  1  E4 81        ARYVA3: CPX	STREND+1	;DONE WITH ARRAYS?
0031F2  1  D0 07        	BNE	ARYVGO		;NO.
0031F4  1  C5 80        	CMP	STREND
0031F6  1  D0 03 4C 84  	JEQ	GRBPAS		;YES, GO FINISH UP.
0031FA  1  32           
0031FB  1  85 71 86 72  ARYVGO: STWX	INDEX1
0031FF  1  A0 00        	LDY	#1-ADDPRC
003201  1               .IF	ADDPRC <> 0
003201  1  B1 71        	LDADY	INDEX1
003203  1  AA           	TAX
003204  1  C8           	INY
003205  1               .ENDIF
003205  1  B1 71        	LDADY	INDEX1
003207  1  08           	PHP
003208  1  C8           	INY
003209  1  B1 71        	LDADY	INDEX1
00320B  1  65 A7        	ADC	ARYPNT
00320D  1  85 A7        	STA	ARYPNT		;FORM POINTER TO NEXT ARRAY VAR.
00320F  1  C8           	INY
003210  1  B1 71        	LDADY	INDEX1
003212  1  65 A8        	ADC	ARYPNT+1
003214  1  85 A8        	STA	ARYPNT+1
003216  1  28           	PLP
003217  1  10 D3        	BPL	ARYVA2
003219  1               .IF	ADDPRC <> 0
003219  1  8A           	TXA
00321A  1  30 D0        	BMI	ARYVA2
00321C  1               .ENDIF
00321C  1  C8           	INY
00321D  1  B1 71        	LDADY	INDEX1
00321F  1  A0 00        	LDY	#0		;RESET INDEX Y.
003221  1  0A           	ASL	A
003222  1  69 05        	ADC	#5		;CARRY IS OFF AND OFF AFTER ADD.
003224  1  65 71        	ADC	INDEX1
003226  1  85 71        	STA	INDEX1
003228  1  90 02        	BCC	ARYGET
00322A  1  E6 72        	INC	INDEX1+1
00322C  1  A6 72        ARYGET: LDX	INDEX1+1
00322E  1  E4 A8        ARYSTR: CPX	ARYPNT+1	;END OF THE ARRAY?
003230  1  D0 04        	BNE	GOGO
003232  1  C5 A7        	CMP	ARYPNT
003234  1  F0 BA        	BEQ	ARYVA3		;YES.
003236  1  20 45 32     GOGO:	JSR	DVAR
003239  1  F0 F3        	BEQ	ARYSTR		;CYCLE.
00323B  1               DVARS:
00323B  1               .IF	INTPRC <> 0
00323B  1  B1 71        	LDADY	INDEX1
00323D  1  30 35        	BMI	DVARTS
00323F  1               .ENDIF
00323F  1  C8           	INY
003240  1  B1 71        	LDADY	INDEX1
003242  1  10 30        	BPL	DVARTS
003244  1  C8           	INY
003245  1  B1 71        DVAR:	LDADY	INDEX1		;IS LENGTH=0?
003247  1  F0 2B        	BEQ	DVARTS		;YES, RETURN.
003249  1  C8           	INY
00324A  1  B1 71        	LDADY	INDEX1		;GET LOW(ADR).
00324C  1  AA           	TAX
00324D  1  C8           	INY
00324E  1  B1 71        	LDADY	INDEX1
003250  1  C5 83        	CMP	FRETOP+1	;COMPARE HIGHS.
003252  1  90 06        	BCC	DVAR2		;IF THIS STRING'S PNTR .GE. [FRETOP]
003254  1  D0 1E        	BNE	DVARTS		;NO NEED TO MESS WITH IT FURTHER.
003256  1  E4 82        	CPX	FRETOP		;COMPARE LOWS.
003258  1  B0 1A        	BCS	DVARTS
00325A  1  C5 AF        DVAR2:	CMP	GRBTOP+1
00325C  1  90 16        	BCC	DVARTS		;IF THIS STRING IS BELOW PREVIOUS,
00325E  1               				;FORGET IT.
00325E  1  D0 04        	BNE	DVAR3
003260  1  E4 AE        	CPX	GRBTOP		;COMPARE LOW ORDERS.
003262  1  90 10        	BCC	DVARTS		;[X,A] .LE. [GRBTOP].
003264  1  86 AE        DVAR3:	STX	GRBTOP
003266  1  85 AF        	STA	GRBTOP+1
003268  1  A5 71 A6 72  	LDWX	INDEX1
00326C  1  85 9D 86 9E  	STWX	GRBPNT
003270  1  A5 A2        	LDA	FOUR6
003272  1  85 A4        	STA	SIZE
003274  1  A5 A2        DVARTS: LDA	FOUR6
003276  1  18           	CLC
003277  1  65 71        	ADC	INDEX1
003279  1  85 71        	STA	INDEX1
00327B  1  90 02        	BCC	GRBRTS
00327D  1  E6 72        	INC	INDEX1+1
00327F  1  A6 72        GRBRTS: LDX	INDEX1+1
003281  1  A0 00        	LDY	#0
003283  1  60           	RTS			;DONE.
003284  1               ;
003284  1               ; HERE WHEN MADE ONE COMPLETE PASS THROUGH STRING VARIABLES.
003284  1               ;
003284  1  A5 9E        GRBPAS: LDA	GRBPNT+1	;VARIABLE POINTER.
003286  1  05 9D        	ORA	GRBPNT
003288  1  F0 F5        	BEQ	GRBRTS		;ALL DONE.
00328A  1  A5 A4        	LDA	SIZE
00328C  1  29 04        	AND	#4		;LEAVES C OFF.
00328E  1  4A           	LSR	A
00328F  1  A8           	TAY
003290  1  85 A4        	STA	SIZE
003292  1  B1 9D        	LDADY	GRBPNT
003294  1               				;NOTE: GRBTOP=LOWTR SO NO NEED TO SET LOWTR.
003294  1  65 AE        	ADC	LOWTR
003296  1  85 A9        	STA	HIGHTR
003298  1  A5 AF        	LDA	LOWTR+1
00329A  1  69 00        	ADC	#0
00329C  1  85 AA        	STA	HIGHTR+1
00329E  1  A5 82 A6 83  	LDWX	FRETOP
0032A2  1  85 A7 86 A8  	STWX	HIGHDS		;WHERE IT ALL GOES.
0032A6  1  20 D6 21     	JSR	BLTUC
0032A9  1  A4 A4        	LDY	SIZE
0032AB  1  C8           	INY
0032AC  1  A5 A7        	LDA	HIGHDS		;GET POSITION OF START OF RESULT.
0032AE  1  91 9D        	STADY	GRBPNT
0032B0  1  AA           	TAX
0032B1  1  E6 A8        	INC	HIGHDS+1
0032B3  1  A5 A8        	LDA	HIGHDS+1
0032B5  1  C8           	INY
0032B6  1  91 9D        	STADY	GRBPNT		;CHANGE ADDR OF STRING IN VAR.
0032B8  1  4C A8 31     	JMP	FNDVAR		;GO TO FNDVAR WITH SOMETHING FOR
0032BB  1               				;[FRETOP].
0032BB  1               ;
0032BB  1               ; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS.
0032BB  1               ; THE FAC CONTAINS THE FIRST ONE AT THIS POINT.
0032BB  1               ; [TXTPTR] POINTS TO THE + SIGN.
0032BB  1               ;
0032BB  1  A5 B4        CAT:	LDA	FACLO		;PSH HIGH ORDER ONTO STACK.
0032BD  1  48           	PHA
0032BE  1  A5 B3        	LDA	FACMO		;AND THE LOW.
0032C0  1  48           	PHA
0032C1  1  20 A3 2B     	JSR	EVAL		;CAN COME BACK HERE SINCE
0032C4  1               				;OPERATOR IS KNOWN.
0032C4  1  20 AF 2A     	JSR	CHKSTR		;RESULT MUST BE STRING.
0032C7  1  68           	PLA
0032C8  1  85 BE        	STA	STRNG1		;GET HIGH ORDER OF OLD DESC.
0032CA  1  68           	PLA
0032CB  1  85 BF        	STA	STRNG1+1
0032CD  1  A0 00        	LDY	#0
0032CF  1  B1 BE        	LDADY	STRNG1		;GET LENGTH OF OLD STRING.
0032D1  1  18           	CLC
0032D2  1  71 B3        	ADCDY	FACMO
0032D4  1  90 05        	BCC	SIZEOK		;RESULT IS LESS THAN 256.
0032D6  1  A2 1A        	LDX	#ERRLS		;ERROR "LONG STRING".
0032D8  1  4C 4E 22     	JMP	ERROR
0032DB  1  20 F2 30     SIZEOK: JSR	STRINI		;INITIALIZE STRING.
0032DE  1  20 F8 32     	JSR	MOVINS		;MOVE IT.
0032E1  1  A5 9F A4 A0  	LDWD	DSCPNT		;GET POINTER TO SECOND.
0032E5  1  20 28 33     	JSR	FRETMP		;FREE IT.
0032E8  1  20 0A 33     	JSR	MOVDO
0032EB  1  A5 BE A4 BF  	LDWD	STRNG1
0032EF  1  20 28 33     	JSR	FRETMP
0032F2  1  20 43 31     	JSR	PUTNEW
0032F5  1  4C D8 2A     	JMP	TSTOP		;"CAT" REENTERS FORM EVAL AT TSTOP.
0032F8  1               
0032F8  1  A0 00        MOVINS: LDY	#0		;GET ADDR OF STRING.
0032FA  1  B1 BE        	LDADY	STRNG1
0032FC  1  48           	PHA
0032FD  1  C8           	INY
0032FE  1  B1 BE        	LDADY	STRNG1
003300  1  AA           	TAX
003301  1  C8           	INY
003302  1  B1 BE        	LDADY	STRNG1
003304  1  A8           	TAY
003305  1  68           	PLA
003306  1  86 71 84 72  MOVSTR: STXY	INDEX
00330A  1  A8           MOVDO:	TAY
00330B  1  F0 0A        	BEQ	MVDONE
00330D  1  48           	PHA
00330E  1  88           MOVLP:	DEY
00330F  1  B1 71        	LDADY	INDEX
003311  1  91 84        	STADY	FRESPC
003313  1  98           QMOVE:	TYA
003314  1  D0 F8        	BNE	MOVLP
003316  1  68           	PLA
003317  1  18           MVDONE: CLC
003318  1  65 84        	ADC	FRESPC
00331A  1  85 84        	STA	FRESPC
00331C  1  90 02        	BCC	MVSTRT
00331E  1  E6 85        	INC	FRESPC+1
003320  1  60           MVSTRT: RTS
003321  1               ;
003321  1               ; "FRETMP" IS PASSED A STRING DESCRIPTOR PNTR IN [Y,A].
003321  1               ; A CHECK IS MADE TO SEE IF THE STRING DESCRIPTOR POINTS TO THE LAST
003321  1               ; TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
003321  1               ; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF [TEMPPT].
003321  1               ; IF A TEMP IS FREED UP, A FURTHER CHECK SEES IF THE STRING DATA THAT
003321  1               ; THAT STRING TEMP PNT'D TO IS THE LOWEST PART OF STRING SPACE IN USE.
003321  1               ; IF SO, [FRETOP] IS UPDATED TO REFLECT THE FACT THE FACT THAT THE SPACE
003321  1               ; IS NO LONGER IN USE.
003321  1               ; THE ADDR OF THE ACTUAL STRING IS RETURNED IN [Y,X] AND
003321  1               ; ITS LENGTH IN ACCA.
003321  1               ;
003321  1  20 AF 2A     FRESTR: JSR	CHKSTR		;MAKE SURE ITS A STRING.
003324  1  A5 B3 A4 B4  FREFAC: LDWD	FACMO		;FREE UP STR PNT'D TO BY FAC.
003328  1  85 71 84 72  FRETMP: STWD	INDEX		;GET LENGTH FOR LATER.
00332C  1  20 59 33     	JSR	FRETMS		;FREE UP THE TEMPORARY DESC.
00332F  1  08           	PHP			;SAVE CODES.
003330  1  A0 00        	LDY	#0		;PREP TO GET STUFF.
003332  1  B1 71        	LDADY	INDEX		;GET COUNT AND
003334  1  48           	PHA			;SAVE IT.
003335  1  C8           	INY
003336  1  B1 71        	LDADY	INDEX
003338  1  AA           	TAX			;SAVE LOW ORDER.
003339  1  C8           	INY
00333A  1  B1 71        	LDADY	INDEX
00333C  1  A8           	TAY			;SAVE HIGH ORDER.
00333D  1  68           	PLA
00333E  1  28           	PLP			;RETURN STATUS.
00333F  1  D0 13        	BNE	FRETRT
003341  1  C4 83        	CPY	FRETOP+1	;STRING IS LAST ONE IN?
003343  1  D0 0F        	BNE	FRETRT
003345  1  E4 82        	CPX	FRETOP
003347  1  D0 0B        	BNE	FRETRT
003349  1  48           	PHA
00334A  1  18           	CLC
00334B  1  65 82        	ADC	FRETOP
00334D  1  85 82        	STA	FRETOP
00334F  1  90 02        	BCC	FREPLA
003351  1  E6 83        	INC	FRETOP+1
003353  1  68           FREPLA: PLA			;GET COUNT BACK.
003354  1  86 71 84 72  FRETRT: STXY	INDEX		;SAVE FOR LATER USE.
003358  1  60           	RTS
003359  1  C4 67        FRETMS: CPY	LASTPT+1	;LAST ENTRY TO TEMP?
00335B  1  D0 0C        	BNE	FRERTS
00335D  1  C5 66        	CMP	LASTPT
00335F  1  D0 08        	BNE	FRERTS
003361  1  85 65        	STA	TEMPPT
003363  1  E9 03        	SBC	#STRSIZ		;POINT TO LAST ONE.
003365  1  85 66        	STA	LASTPT		;UPDATE TEMP PNTR.
003367  1  A0 00        	LDY	#0		;ALSO CLEARS ZFLG SO WE DO REST OF FRETMP.
003369  1  60           FRERTS: RTS			;ALL DONE.
00336A  1               ;
00336A  1               ; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
00336A  1               ; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARGUMENT (#)
00336A  1               ; WHICH MUST BE .LT. 255.
00336A  1               ;
00336A  1  20 1F 34     CHR:	JSR	CONINT		;GET INTEGER IN RANGE.
00336D  1  8A           	TXA
00336E  1  48           	PHA
00336F  1  A9 01        	LDA	#1		;ONE-CHARACTER STRING.
003371  1  20 FA 30     	JSR	STRSPA		;GET SPACE FOR STRING.
003374  1  68           	PLA
003375  1  A0 00        	LDY	#0
003377  1  91 B1        	STADY	DSCTMP+1
003379  1  68           	PLA			;GET RID OF "CHKNUM" RETURN ADDR.
00337A  1  68           	PLA
00337B  1  4C 43 31     RLZRET: JMP	PUTNEW		;SETUP FAC TO POINT TO DESC.
00337E  1               ;
00337E  1               ; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
00337E  1               ; IT TAKES THE LEFTMOST # CHARACTERS OF THE STRING.
00337E  1               ; IF # .GT. THE LEN OF THE STRING, IT RETURNS THE WHOLE STRING.
00337E  1               ;
00337E  1  20 DF 33     LEFT:	JSR	PREAM		;TEST PARAMETERS.
003381  1  D1 9F        	CMPDY	DSCPNT
003383  1  98           	TYA
003384  1  90 04        RLEFT:	BCC	RLEFT1
003386  1  B1 9F        	LDADY	DSCPNT
003388  1  AA           	TAX			;PUT LENGTH INTO X.
003389  1  98           	TYA			;ZERO A, THE OFFSET.
00338A  1  48           RLEFT1: PHA			;SAVE OFFSET.
00338B  1  8A           RLEFT2: TXA
00338C  1  48           RLEFT3: PHA			;SAVE LENGTH.
00338D  1  20 FA 30     	JSR	STRSPA		;GET SPACE.
003390  1  A5 9F A4 A0  	LDWD	DSCPNT
003394  1  20 28 33     	JSR	FRETMP
003397  1  68           	PLA
003398  1  A8           	TAY
003399  1  68           	PLA
00339A  1  18           	CLC
00339B  1  65 71        	ADC	INDEX		;COMPUTE WHERE TO COPY.
00339D  1  85 71        	STA	INDEX
00339F  1  90 02        	BCC	PULMOR
0033A1  1  E6 72        	INC	INDEX+1
0033A3  1  98           PULMOR: TYA
0033A4  1  20 0A 33     	JSR	MOVDO		;GO MOVE IT.
0033A7  1  4C 43 31     	JMP	PUTNEW
0033AA  1  20 DF 33     RIGHT:	JSR	PREAM
0033AD  1  18           	CLC			;[LENGTH DES'D]-[LENGTH]-1.
0033AE  1  F1 9F        	SBCDY	DSCPNT
0033B0  1  49 FF        	EOR	#255		;NEGATE.
0033B2  1  4C 84 33     	JMP	RLEFT
0033B5  1               ;
0033B5  1               ; MID ($,#) RETURNS STRING WITH CHARS FROM # POSITION
0033B5  1               ; ONWARD. IF # .GT. LEN ($) THEN RETURN NULL STRING.
0033B5  1               ; MID ($,#,#) RETURNS STRING WITH CHARACTERS FROM
0033B5  1               ; # POSITION FOR #2 CHARACTERS. IF #2 GOES PAST END OF STRING
0033B5  1               ; RETURN AS MUCH AS POSSIBLE.
0033B5  1               ;
0033B5  1  A9 FF        MID:	LDA	#255		;DEFAULT.
0033B7  1  85 B4        	STA	FACLO		;SAVE FOR LATER COMPARE.
0033B9  1  20 C8 00     	JSR	CHRGOT		;GET CURRENT CHARACTER.
0033BC  1  C9 29        	CMP	#41		;IS IT A RIGHT PAREN )?
0033BE  1  F0 06        	BEQ	MID2		;NO THIRD PARAM.
0033C0  1  20 04 2C     	JSR	CHKCOM		;MUST HAVE COMMA.
0033C3  1  20 1C 34     	JSR	GETBYT		;GET THE LENGTH INTO "FACLO".
0033C6  1  20 DF 33     MID2:	JSR	PREAM		;CHECK IT OUT.
0033C9  1  F0 4B        	BEQ	GOFUC		;THERE IS NO POSTION 0
0033CB  1  CA           	DEX			;COMPUTE OFFSET.
0033CC  1  8A           	TXA
0033CD  1  48           	PHA			;PRSERVE AWHILE.
0033CE  1  18           	CLC
0033CF  1  A2 00        	LDX	#0
0033D1  1  F1 9F        	SBCDY	DSCPNT		;GET LENGTH OF WHAT'S LEFT.
0033D3  1  B0 B6        	BCS	RLEFT2		;GIVE NULL STRING.
0033D5  1  49 FF        	EOR	#255		;IN SUB C WAS 0 SO JUST COMPLEMENT.
0033D7  1  C5 B4        	CMP	FACLO		;GREATER THAN WHAT'S DESIRED?
0033D9  1  90 B1        	BCC	RLEFT3		;NO, COPY THAT MUCH.
0033DB  1  A5 B4        	LDA	FACLO		;GET LENGTH OF WHAT'S DESIRED.
0033DD  1  B0 AD        	BCS	RLEFT3		;COPY IT.
0033DF  1               
0033DF  1               ;
0033DF  1               ; USED BY RIGHT$, LEFT$, MID$ FOR PARAMETER CHECKING AND SETUP.
0033DF  1               ;
0033DF  1  20 FE 2B     PREAM:	JSR	CHKCLS		;PARAM LIST SHOULD END.
0033E2  1  68           	PLA			;GET THE RETURN ADDRESS INTO
0033E3  1  A8           	TAY			;[JMPER+1,Y]
0033E4  1  68           	PLA
0033E5  1  85 A4        	STA	JMPER+1
0033E7  1  68           	PLA			;GET RID OF FINGO'S JSR RET ADDR.
0033E8  1  68           	PLA
0033E9  1  68           	PLA			;GET LENGTH.
0033EA  1  AA           	TAX
0033EB  1  68 85 9F 68  	PULWD	DSCPNT
0033EF  1  85 A0        
0033F1  1  A5 A4        	LDA	JMPER+1		;PUT RETURN ADDRESS BACK ON
0033F3  1  48           	PHA
0033F4  1  98           	TYA
0033F5  1  48           	PHA
0033F6  1  A0 00        	LDY	#0
0033F8  1  8A           	TXA
0033F9  1  60           	RTS
0033FA  1               ;
0033FA  1               ; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE STRING
0033FA  1               ; PASSED AS AN ARGUMENT.
0033FA  1               ;
0033FA  1  20 00 34     LEN:	JSR	LEN1
0033FD  1  4C 1F 30     	JMP	SNGFLT
003400  1  20 21 33     LEN1:	JSR	FRESTR		;FREE UP STRING.
003403  1  A2 00        	LDX	#0
003405  1  86 11        	STX	VALTYP		;FORCE NUMERIC.
003407  1  A8           	TAY			;SET CODES ON LENGTH.
003408  1  60           	RTS			;DONE.
003409  1               ;
003409  1               ; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS
003409  1               ; AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT.
003409  1               ;
003409  1  20 00 34     ASC:	JSR	LEN1
00340C  1  F0 08        	BEQ	GOFUC		;NULL STRING, BAD ARG.
00340E  1  A0 00        	LDY	#0
003410  1  B1 71        	LDADY	INDEX1		;GET CHARACTER.
003412  1  A8           	TAY
003413  1  4C 1F 30     	JMP	SNGFLT
003416  1  4C C6 2E     GOFUC:	JMP	FCERR		;YES.
003419  1               
003419  1  20 C2 00     GTBYTC: JSR	CHRGET
00341C  1  20 AA 2A     GETBYT: JSR	FRMNUM		;READ FORMULA INTO FAC.
00341F  1  20 36 2E     CONINT: JSR	POSINT		;CONVERT THE FAC TO A SINGLE BYTE INT.
003422  1  A6 B3        	LDX	FACMO
003424  1  D0 F0        	BNE	GOFUC		;RESULT MUST BE .LE. 255.
003426  1  A6 B4        	LDX	FACLO
003428  1  4C C8 00     CHRGO2: JMP	CHRGOT		;SET CONDITION CODES ON TERMINATOR.
00342B  1               ;
00342B  1               ; THE "VAL" FUNCTION TAKES A STRING AND TURNS IT INTO
00342B  1               ; A NUMBER BY INTERPRETING THE ASCII DIGITS ETCQ
00342B  1               ; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
00342B  1               ; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL IS MERELY
00342B  1               ; A CALL TO FLOATING POINT INPUT ("FIN").
00342B  1               ;
00342B  1  20 00 34     VAL:	JSR	LEN1		;DO SETUP. SET RESULT=NUMERIC.
00342E  1  D0 03 4C 76  	JEQ	ZEROFC		;ZERO THE FAC ON A NULL STRING
003432  1  35           
003433  1  A6 C9 A4 CA  	LDXY	TXTPTR
003437  1  86 C0 84 C1  	STXY	STRNG2		;SAVE FOR LATER.
00343B  1  A6 71        	LDX	INDEX1
00343D  1  86 C9        	STX	TXTPTR
00343F  1  18           	CLC
003440  1  65 71        	ADC	INDEX1
003442  1  85 73        	STA	INDEX2
003444  1  A6 72        	LDX	INDEX1+1
003446  1  86 CA        	STX	TXTPTR+1
003448  1  90 01        	BCC	VAL2		;NO CARRY, NO INC.
00344A  1  E8           	INX
00344B  1  86 74        VAL2:	STX	INDEX2+1
00344D  1  A0 00        	LDY	#0
00344F  1  B1 73        	LDADY	INDEX2		;PRESERVE CHARACTER.
003451  1  48           	PHA
003452  1  A9 00        	LDA	#0		;SET A TERMINATOR.
003454  1  91 73        	STADY	INDEX2
003456  1  20 C8 00     	JSR	CHRGOT		;GET CHARACTER PNT'D TO AND SET FLAGS.
003459  1  20 72 39     	JSR	FIN
00345C  1  68           	PLA			;GET PRES'D CHARACTER.
00345D  1  A0 00        	LDY	#0
00345F  1  91 73        	STADY	INDEX2		;STUFF IT BACK.
003461  1  A6 C0 A4 C1  ST2TXT: LDXY	STRNG2
003465  1  86 C9 84 CA  	STXY	TXTPTR
003469  1  60           VALRTS: RTS			;ALL DONE WITH STRINGS.
00346A  1               ; PAGE
00346A  1               ; SUBTTL	PEEK, POKE, AND FNWAIT.
00346A  1               
00346A  1  20 AA 2A     GETNUM: JSR	FRMNUM		;GET ADDRESS.
00346D  1  20 76 34     	JSR	GETADR		;GET THAT LOCATION.
003470  1  20 04 2C     COMBYT: JSR	CHKCOM		;CHECK FOR A COMMA.
003473  1  4C 1C 34     	JMP	GETBYT		;GET SOMETHING TO STORE AND RETURN.
003476  1  A5 B5        GETADR: LDA	FACSGN		;EXAMINE SIGN.
003478  1  30 9C        	BMI	GOFUC		;FUNCTION CALL ERROR.
00347A  1  A5 B0        	LDA	FACEXP		;EXAMINE EXPONENT.
00347C  1  C9 91        	CMP	#145
00347E  1  B0 96        	BCS	GOFUC		;FUNCTION CALL ERROR.
003480  1  20 1A 39     	JSR	QINT		;INTEGERIZE IT.
003483  1  A5 B3 A4 B4  	LDWD	FACMO
003487  1  84 1B        	STY	POKER
003489  1  85 1C        	STA	POKER+1
00348B  1  60           	RTS			;IT'S DONE !.
00348C  1               
00348C  1  A5 1C 48 A5  PEEK:	PSHWD	POKER
003490  1  1B 48        
003492  1  20 76 34     	JSR	GETADR
003495  1  A0 00        	LDY	#0
003497  1               .IF	REALIO-3 = 0
003497  1               	CMP	#ROMLOC/256	;IF WITHIN BASIC,
003497  1               	BCC	GETCON
003497  1               	CMP	#LASTWR/256
003497  1               	BCC	DOSGFL		;GIVE HIM ZERO FOR AN ANSWER.
003497  1               .ENDIF
003497  1  B1 1B        GETCON: LDADY	POKER		;GET THAT BYTE.
003499  1  A8           	TAY
00349A  1  68 85 1B 68  DOSGFL: PULWD	POKER
00349E  1  85 1C        
0034A0  1  4C 1F 30     	JMP	SNGFLT		;FLOAT IT.
0034A3  1               
0034A3  1  20 6A 34     POKE:	JSR	GETNUM
0034A6  1  8A           	TXA
0034A7  1  A0 00        	LDY	#0
0034A9  1  91 1B        	STADY	POKER		;STORE VALUE AWAY.
0034AB  1  60           	RTS			;SCANNED  EVERYTHING.
0034AC  1               
0034AC  1               ; THE WAIT LOCATION,MASK1,MASK2 STATEMENT WAITS UNTIL THE CONTENTS
0034AC  1               ; OF LOCATION IS NONZERO WHEN XORED WITH MASK2
0034AC  1               ; AND THEN ANDED WITH MASK1. IF MASK2 IS NOT PRESENT, IT
0034AC  1               ; IS ASSUMED TO BE ZERO.
0034AC  1               
0034AC  1  20 6A 34     FNWAIT: JSR	GETNUM
0034AF  1  86 98        	STX	ANDMSK
0034B1  1  A2 00        	LDX	#0
0034B3  1  20 C8 00     	JSR	CHRGOT
0034B6  1  F0 03        	BEQ	ZSTORDO
0034B8  1  20 70 34     	JSR	COMBYT		;GET MASK2.
0034BB  1  86 99        STORDO: STX	EORMSK
0034BD  1  A0 00        	LDY	#0
0034BF  1  B1 1B        WAITER: LDADY	POKER
0034C1  1  45 99        	EOR	EORMSK
0034C3  1  25 98        	AND	ANDMSK
0034C5  1  F0 F8        	BEQ	WAITER
0034C7  1  60           ZERRTS: RTS			;GOT A NONZERO.
0034C8  1               ; SUBTTL FLOATING POINT MATH PACKAGE CONFIGURATION.
0034C8  1               
0034C8  1               ; RADIX	8			;!!!! ALERT !!!!
0034C8  1               				;THROUGHOUT THE MATH PACKAGE.
0034C8  1               
0034C8  1               ; THE FLOATING POINT FORMAT IS AS FOLLOWS:
0034C8  1               ;
0034C8  1               ; THE SIGN IS THE FIRST BIT OF THE MANTISSA.
0034C8  1               ; THE MANTISSA IS 24 BITS LONG.
0034C8  1               ; THE BINARY POINT IS TO THE LEFT OF THE MSB.
0034C8  1               ; NUMBER = MANTISSA * 2 ^ EXPONENT.
0034C8  1               ; THE MANTISSA IS POSITIVE WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS.
0034C8  1               ; THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT.
0034C8  1               ; THE EXPONENT IS STORED IN EXCESS 200, I.E. WITH A BIAS OF +200.
0034C8  1               ; SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT.
0034C8  1               ; AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO.
0034C8  1               ; THE OTHER BYTES MAY NOT BE ASSUMED TO BE ZERO.
0034C8  1               ; TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING,
0034C8  1               ; 	TO SHIFT RIGHT, EXP:=EXP+1
0034C8  1               ; 	TO SHIFT LEFT,	EXP:=EXP-1
0034C8  1               ;
0034C8  1               ; IN MEMORY THE NUMBER LOOKS LIKE THIS:
0034C8  1               ; 	[THE EXPONENT AS A SIGNED NUMBER +200]
0034C8  1               ; 	[THE SIGN BIT IN 7, BITS 2-8 OF MANTISSA ARE IN BITS 6-0].
0034C8  1               ; 		(REMEMBER BIT 1 OF MANTISSA IS ALWAYS A ONE.)
0034C8  1               ; 	[BITS 9-16 OF THE MANTISSA]
0034C8  1               ; 	[BITS 17-24] OF THE MANTISSA]
0034C8  1               ;
0034C8  1               ; ARITHMETIC ROUTINE CALLING CONVENTIONS:
0034C8  1               ;
0034C8  1               ; FOR ONE ARGUMENT FUNCTIONS:
0034C8  1               ; 	THE ARGUMENT IS IN THE FAC.
0034C8  1               ; 	THE RESULT IS LEFT IN THE FAC.
0034C8  1               ; FOR TWO ARGUMENT OPERATIONS:
0034C8  1               ; 	THE FIRST ARGUMENT IS IN ARG (ARGEXP,HO,MO,LO AND ARGSGN).
0034C8  1               ; 	THE SECOND ARGUMENT IS IN THE FAC.
0034C8  1               ; 	THE RESULT IS LEFT IN THE FAC.
0034C8  1               ;
0034C8  1               ; THE "T" ENTRY POINTS TO THE TWO-ARGUMENT OPERATIONS HAVE BOTH ARGUMENTS
0034C8  1               ; SETUP IN THE RESPECTIVE REGISTERS. BEFORE CALLING ARG MAY HAVE BEEN
0034C8  1               ; POPPED OFF THE STACK AND INTO ARG, FOR EXAMPLE.
0034C8  1               ; THE OTHER ENTRY POINT ASSUMES [Y,A] POINTS TO THE ARGUMENT
0034C8  1               ; SOMEWHERE IN MEMORY. IT IS UNPACKED INTO ARG BY "CONUPK".
0034C8  1               ;
0034C8  1               ; ON THE STACK, THE SGN IS PUSHED ON FIRST, THE LO,MO,HO AND FINALLY EXP.
0034C8  1               ; NOTE ALL THINGS ARE KEPT UNPACKED IN ARG, FAC AND ON THE STACK.
0034C8  1               ;
0034C8  1               ; IT IS ONLY WHEN SOMETHING IS STORED AWAY THAT IT IS PACKED TO FOUR
0034C8  1               ; BYTES. THE UNPACKED FORMAT HAS A SGN BYTE REFLECTING THE SIGN OF THE
0034C8  1               ; NUMBER (POSITIVE=0, NEGATIVE=-1) A HO,MO AND LO WITH THE HIGH BIT
0034C8  1               ; OF THE HO TURNED ON. THE EXP IS THE SAME AS STORED FORMAT.
0034C8  1               ; THIS IS DONE FOR SPEED OF OPERATION.
0034C8  1               
0034C8  1               ; PAGE
0034C8  1               ; SUBTTL	FLOATING POINT ADDITION AND SUBTRACTION.
0034C8  1  A9 8C A0 3B  FADDH:	LDWDI	FHALF		;ENTRY TO ADD 1/2.
0034CC  1  4C E6 34     	JMP	FADD		;UNPACK AND GO ADD IT.
0034CF  1  20 0B 37     FSUB:	JSR	CONUPK		;UNPACK ARGUMENT INTO ARG.
0034D2  1  A5 B5        FSUBT:	LDA	FACSGN
0034D4  1  49 FF        	EOR	#$FF		;COMPLEMENT IT.
0034D6  1  85 B5        	STA	FACSGN
0034D8  1  45 BD        	EOR	ARGSGN		;COMPLEMENT ARISGN.
0034DA  1  85 BE        	STA	ARISGN
0034DC  1  A5 B0        	LDA	FACEXP		;SET CODES ON FACEXP.
0034DE  1  4C E9 34     	JMP	FADDT		;[Y]=ARGEXP..
0034E1  1               ;	XLIST ; LGB
0034E1  1               ;.XCREF	; LGB
0034E1  1               .IF	REALIO-3  <> 0
0034E1  1               	ZSTORDO=STORDO
0034E1  1               .ENDIF
0034E1  1               .IF	REALIO-3 = 0
0034E1  1               ZSTORDO:			; LGB: probably again the 6 char max name problem, give alternative name for CA65
0034E1  1               ZSTORD:	LDA	POKER		; LGB: was: ZSTORD:!
0034E1  1               	CMP	#$66
0034E1  1               	BNE	STORDO
0034E1  1               	LDA	POKER+1
0034E1  1               	SBC	#$19
0034E1  1               	BNE	STORDO
0034E1  1               	STA	POKER
0034E1  1               	TAY
0034E1  1               	LDA	#$80
0034E1  1               	STA	POKER+1
0034E1  1               MRCHKR: LDX	#$A
0034E1  1               ;LGB IF1,<
0034E1  1               ;LGB MRCHR: LDA	60000,X,>	;
0034E1  1               ;LGB IF2,<
0034E1  1               MRCHR:	LDA	SINCON+$1E,X
0034E1  1               	AND	#$3F
0034E1  1               	STADY	POKER
0034E1  1               	INY
0034E1  1               	BNE	PKINC
0034E1  1               	INC	POKER+1
0034E1  1               PKINC:	DEX
0034E1  1               	BNE	MRCHR
0034E1  1               	DEC	ANDMSK
0034E1  1               	BNE	MRCHKR
0034E1  1               	RTS
0034E1  1               ; LGB IF2,<PURGE ZSTORD>	;
0034E1  1               .ENDIF
0034E1  1               ;.CREF	; LGB
0034E1  1               ;LIST ; LGB
0034E1  1  20 18 36     FADD5:	JSR	SHIFTR		;DO A LONG SHIFT.
0034E4  1  90 3C        	BCC	FADD4		;CONTINUE WITH ADDITION.
0034E6  1  20 0B 37     FADD:	JSR	CONUPK
0034E9  1  D0 03 4C 7B  FADDT:	JEQ	MOVFA		;IF FAC=0, RESULT IS IN ARG.
0034ED  1  38           
0034EE  1  A6 BF        	LDX	FACOV
0034F0  1  86 A5        	STX	OLDOV
0034F2  1  A2 B8        	LDX	#ARGEXP		;DEFAULT IS SHIFT ARGUMENT.
0034F4  1  A5 B8        	LDA	ARGEXP		;IF ARG=0, FAC IS RESULT.
0034F6  1  A8           FADDC:	TAY			;ALSO COPY ACCA INTO ACCY.
0034F7  1  F0 CE        	BEQ	ZERRTS		;RETURN.
0034F9  1  38           	SEC
0034FA  1  E5 B0        	SBC	FACEXP
0034FC  1  F0 24        	BEQ	FADD4		;NO SHIFTING.
0034FE  1  90 12        	BCC	FADDA		;BR IF ARGEXP.LT.FACEXP.
003500  1  84 B0        	STY	FACEXP		;RESULTING EXPONENT.
003502  1  A4 BD        	LDY	ARGSGN		;SINCE ARG IS BIGGER, IT'S
003504  1  84 B5        	STY	FACSGN		;SIGN IS SIGN OF RESULT.
003506  1  49 FF        	EOR	#$FF		;SHIFT A NEGATIVE NUMBER OF PLACES.
003508  1  69 00        	ADC	#0		;COMPLETE NEGATION. W/ C=1.
00350A  1  A0 00        	LDY	#0		;ZERO OLDOV.
00350C  1  84 A5        	STY	OLDOV
00350E  1  A2 B0        	LDX	#FAC		;SHIFT THE FAC INSTEAD.
003510  1  D0 04        	BNE	FADD1
003512  1  A0 00        FADDA:	LDY	#0
003514  1  84 BF        	STY	FACOV
003516  1  C9 A7        FADD1:	CMP	#$AE-7		;FOR SPEED AND NECESSITY.  GETS
003518  1               				;MOST LIKELY CASE TO SHIFTR FASTEST
003518  1               				;AND ALLOWS SHIFTING OF NEG NUMS
003518  1               				;BY "QINT".
003518  1  30 C7        	BMI	FADD5		;SHIFT BIG.
00351A  1  A8           	TAY
00351B  1  A5 BF        	LDA	FACOV		;SET FACOV.
00351D  1  56 01        	LSR	1,X 		;GETS 0 IN MOST SIG BIT.
00351F  1  20 2F 36     	JSR	ROLSHF		;DO THE ROLLING.
003522  1  24 BE        FADD4:	BIT	ARISGN		;GET RESULTING SIGN.
003524  1  10 57        	BPL	FADD2		;IF POSITIVE, ADD.
003526  1               				;CARRY IS CLEAR.
003526  1  A0 B0        FADD3:	LDY	#FACEXP
003528  1  E0 B8        	CPX	#ARGEXP		;FAC IS BIGGER.
00352A  1  F0 02        	BEQ	SUBIT
00352C  1  A0 B8        	LDY	#ARGEXP		;ARG IS BIGGER.
00352E  1  38           SUBIT:	SEC
00352F  1  49 FF        	EOR	#$FF
003531  1  65 A5        	ADC	OLDOV
003533  1  85 BF        	STA	FACOV
003535  1  B9 04 00     	LDA	3+ADDPRC,Y
003538  1  F5 04        	SBC	3+ADDPRC,X
00353A  1  85 B4        	STA	FACLO
00353C  1  B9 03 00     	LDA	2+ADDPRC,Y
00353F  1  F5 03        	SBC	2+ADDPRC,X
003541  1  85 B3        	STA	FACMO
003543  1               .IF	ADDPRC <> 0
003543  1  B9 02 00     	LDA	2,Y
003546  1  F5 02        	SBC	2,X
003548  1  85 B2        	STA	FACMOH
00354A  1               .ENDIF
00354A  1  B9 01 00     	LDA	1,Y
00354D  1  F5 01        	SBC	1,X
00354F  1  85 B1        	STA	FACHO
003551  1  B0 03        FADFLT: BCS	NORMAL		;HERE IF SIGNS DIFFER. IF CARRY,
003553  1               				;FAC IS SET OK.
003553  1  20 C6 35     	JSR	NEGFAC		;NEGATE [FAC].
003556  1  A0 00        NORMAL: LDY	#0
003558  1  98           	TYA
003559  1  18           	CLC
00355A  1  A6 B1        NORM3:	LDX	FACHO
00355C  1  D0 4A        	BNE	NORM1
00355E  1  A6 B2        	LDX	FACHO+1		;SHIFT 8 BITS AT A TIME FOR SPEED.
003560  1  86 B1        	STX	FACHO
003562  1               .IF	ADDPRC <> 0
003562  1  A6 B3        	LDX	FACMOH+1
003564  1  86 B2        	STX	FACMOH
003566  1               .ENDIF
003566  1  A6 B4        	LDX	FACMO+1
003568  1  86 B3        	STX	FACMO
00356A  1  A6 BF        	LDX	FACOV
00356C  1  86 B4        	STX	FACLO
00356E  1  84 BF        	STY	FACOV
003570  1  69 08        	ADC	#$8
003572  1  C9 20        	CMP	#$8*ADDPRC+$18
003574  1  D0 E4        	BNE	NORM3
003576  1  A9 00        ZEROFC: LDA	#0		;NOT NEED BY NORMAL BUT BY OTHERS.
003578  1  85 B0        ZEROF1: STA	FACEXP		;NUMBER MUST BE ZERO.
00357A  1  85 B5        ZEROML: STA	FACSGN		;MAKE SIGN POSITIVE.
00357C  1  60           	RTS			;ALL DONE.
00357D  1  65 A5        FADD2:	ADC	OLDOV
00357F  1  85 BF        	STA	FACOV
003581  1  A5 B4        	LDA	FACLO
003583  1  65 BC        	ADC	ARGLO
003585  1  85 B4        	STA	FACLO
003587  1  A5 B3        	LDA	FACMO
003589  1  65 BB        	ADC	ARGMO
00358B  1  85 B3        	STA	FACMO
00358D  1               .IF	ADDPRC <> 0
00358D  1  A5 B2        	LDA	FACMOH
00358F  1  65 BA        	ADC	ARGMOH
003591  1  85 B2        	STA	FACMOH
003593  1               .ENDIF
003593  1  A5 B1        	LDA	FACHO
003595  1  65 B9        	ADC	ARGHO
003597  1  85 B1        	STA	FACHO
003599  1  4C B5 35     	JMP	SQUEEZ		;GO ROUND IF SIGNS SAME.
00359C  1               
00359C  1  69 01        NORM2:	ADC	#1		;DECREMENT SHIFT COUNT.
00359E  1  06 BF        	ASL	FACOV		;SHIFT ALL LEFT ONE BIT.
0035A0  1  26 B4        	ROL	FACLO
0035A2  1  26 B3        	ROL	FACMO
0035A4  1               .IF	ADDPRC <> 0
0035A4  1  26 B2        	ROL	FACMOH
0035A6  1               .ENDIF
0035A6  1  26 B1        	ROL	FACHO
0035A8  1  10 F2        NORM1:	BPL	NORM2		;IF MSB=0 SHIFT AGAIN.
0035AA  1  38           	SEC
0035AB  1  E5 B0        	SBC	FACEXP
0035AD  1  B0 C7        	BCS	ZEROFC
0035AF  1  49 FF        	EOR	#$FF
0035B1  1  69 01        	ADC	#1		;COMPLEMENT.
0035B3  1  85 B0        	STA	FACEXP
0035B5  1  90 0E        SQUEEZ: BCC	RNDRTS		;BITS TO SHIFT?
0035B7  1  E6 B0        RNDSHF: INC	FACEXP
0035B9  1  F0 42        	BEQ	OVERR
0035BB  1  66 B1        	ROR	FACHO
0035BD  1               .IF	ADDPRC <> 0
0035BD  1  66 B2        	ROR	FACMOH
0035BF  1               .ENDIF
0035BF  1  66 B3        	ROR	FACMO
0035C1  1  66 B4        	ROR	FACLO
0035C3  1  66 BF        	ROR	FACOV
0035C5  1  60           RNDRTS: RTS			;ALL DONE ADDING.
0035C6  1               
0035C6  1  A5 B5 49 FF  NEGFAC: COM	FACSGN		;COMPLEMENT FAC	 ENTIRELY.
0035CA  1  85 B5        
0035CC  1  A5 B1 49 FF  NEGFCH: COM	FACHO		;COMPLEMENT JUST THE NUMBER.
0035D0  1  85 B1        
0035D2  1               .IF	ADDPRC <> 0
0035D2  1  A5 B2 49 FF  	COM	FACMOH
0035D6  1  85 B2        
0035D8  1               .ENDIF
0035D8  1  A5 B3 49 FF  	COM	FACMO
0035DC  1  85 B3        
0035DE  1  A5 B4 49 FF  	COM	FACLO
0035E2  1  85 B4        
0035E4  1  A5 BF 49 FF  	COM	FACOV
0035E8  1  85 BF        
0035EA  1  E6 BF        	INC	FACOV
0035EC  1  D0 0E        	BNE	INCFRT
0035EE  1  E6 B4        INCFAC: INC	FACLO
0035F0  1  D0 0A        	BNE	INCFRT
0035F2  1  E6 B3        	INC	FACMO
0035F4  1  D0 06        	BNE	INCFRT		;IF NO CARRY, RETURN.
0035F6  1               .IF	ADDPRC <> 0
0035F6  1  E6 B2        	INC	FACMOH
0035F8  1  D0 02        	BNE	INCFRT
0035FA  1               .ENDIF
0035FA  1  E6 B1        	INC	FACHO		;CARRY INCREMENT.
0035FC  1  60           INCFRT: RTS
0035FD  1               
0035FD  1  A2 0A        OVERR:	LDX	#ERROV
0035FF  1  4C 4E 22     	JMP	ERROR		;TELL USER.
003602  1               ;
003602  1               ; "SHIFTR" SHIFTS [X+1:X+3] [-ACCA]  BITS RIGHT.
003602  1               ; SHIFTS BYTES TO START WITH IF POSSIBLE.
003602  1               ;
003602  1  A2 74        MULSHF: LDX	#RESHO-1		;ENTRY POINT FOR MULTIPLIER.
003604  1  B4 04        SHFTR2: LDY	3+ADDPRC,X 	;SHIFT BYTES FIRST.
003606  1  84 BF        	STY	FACOV
003608  1               .IF	ADDPRC <> 0
003608  1  B4 03        	LDY	3,X
00360A  1  94 04        	STY	4,X
00360C  1               .ENDIF
00360C  1  B4 02        	LDY	2,X 		;GET MO.
00360E  1  94 03        	STY	3,X 		;STORE LO.
003610  1  B4 01        	LDY	1,X 		;GET HO.
003612  1  94 02        	STY	2,X 		;STORE MO.
003614  1  A4 B7        	LDY	BITS
003616  1  94 01        	STY	1,X 		;STORE HO.
003618  1  69 08        SHIFTR: ADC	#$8
00361A  1  30 E8        	BMI	SHFTR2
00361C  1  F0 E6        	BEQ	SHFTR2
00361E  1  E9 08        	SBC	#$8		;C CAN BE EITHER 1,0 AND IT WORKS.
003620  1  A8           	TAY
003621  1  A5 BF        	LDA	FACOV
003623  1  B0 14        	BCS	SHFTRT		;EQUIV TO BEQ HERE.
003625  1               .IF	RORSW <> 0
003625  1  16 01        SHFTR3: ASL	1,X
003627  1  90 02        	BCC	SHFTR4
003629  1  F6 01        	INC	1,X
00362B  1  76 01        SHFTR4: ROR	1,X
00362D  1  76 01        	ROR	1,X		;YES, TWO OF THEM.
00362F  1               .ENDIF
00362F  1               .IF	RORSW = 0
00362F  1               SHFTR3: PHA
00362F  1               	LDA	1,X
00362F  1               	AND	#$80
00362F  1               	LSR	1,X
00362F  1               	ORA	1,X
00362F  1               	STA	1,X
00362F  1               	SKIP1
00362F  1               .ENDIF
00362F  1               ROLSHF:
00362F  1               .IF	RORSW <> 0
00362F  1  76 02        	ROR	2,X
003631  1  76 03        	ROR	3,X
003633  1               .IF	ADDPRC <> 0
003633  1  76 04        	ROR	4,X	;ONE MO TIME.
003635  1               .ENDIF
003635  1               .ENDIF
003635  1               .IF	RORSW = 0
003635  1               	PHA
003635  1               	LDA	#0
003635  1               	BCC	SHFTR5
003635  1               	LDA	#$80
003635  1               SHFTR5: LSR	2,X
003635  1               	ORA	2,X
003635  1               	STA	2,X
003635  1               	LDA	#0
003635  1               	BCC	SHFTR6
003635  1               	LDA	#$80
003635  1               SHFTR6: LSR	3,X
003635  1               	ORA	3,X
003635  1               	STA	3,X
003635  1               .IF	ADDPRC <> 0
003635  1               	LDA	#0
003635  1               	BCC	SHFT6A
003635  1               	LDA	#$80
003635  1               SHFT6A: LSR	4,X
003635  1               	ORA	4,X
003635  1               	STA	4,X
003635  1               .ENDIF
003635  1               .ENDIF
003635  1               .IF	RORSW <> 0
003635  1  6A           	ROR	A 	;ROTATE ARGUMENT 1 BIT RIGHT.
003636  1               .ENDIF
003636  1               .IF	RORSW = 0
003636  1               	PLA
003636  1               	PHP
003636  1               	LSR	A
003636  1               	PLP
003636  1               	BCC	SHFTR7
003636  1               	ORA	#$80
003636  1               .ENDIF
003636  1  C8           SHFTR7: INY
003637  1  D0 EC        	BNE	SHFTR3		;$$$ ( MOST EXPENSIVE ! )
003639  1  18           SHFTRT: CLC			;CLEAR OUTPUT OF FACOV.
00363A  1  60           	RTS
00363B  1               ; PAGE
00363B  1               ; SUBTTL	NATURAL LOG FUNCTION.
00363B  1               ;
00363B  1               ; CALCULATION IS BY:
00363B  1               ; LN(F*2^N)=(N+LOG2(F))*LN(2)
00363B  1               ; AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F).
00363B  1               ;  CONSTANTS USED BY LOG:
00363B  1  81           FONE:	.BYTE $81	; 1.0
00363C  1  00           .BYTE	0
00363D  1  00           .BYTE	0
00363E  1  00           .BYTE	0
00363F  1               .IF	ADDPRC <> 0
00363F  1  00           .BYTE	0
003640  1               .ENDIF
003640  1               .IF	ADDPRC = 0
003640  1               LOGCN2: .BYTE 2	; DEGREE-1
003640  1               .BYTE	$80	; 0.59897437
003640  1               .BYTE	$19
003640  1               .BYTE	$56
003640  1               .BYTE	$62
003640  1               .BYTE	$80	; 0.96147080
003640  1               .BYTE	$76
003640  1               .BYTE	$22
003640  1               .BYTE	$F3
003640  1               .BYTE	$82	; 2.88539129
003640  1               .BYTE	$38
003640  1               .BYTE	$AA
003640  1               .BYTE	$40
003640  1               .ENDIF
003640  1               
003640  1               .IF	ADDPRC <> 0
003640  1  03           LOGCN2: .BYTE 3	;DEGREE-1
003641  1  7F           .BYTE	$7F	;.43425594188
003642  1  5E           .BYTE	$5E
003643  1  56           .BYTE	$56
003644  1  CB           .BYTE	$CB
003645  1  79           .BYTE	$79
003646  1  80           .BYTE	$80	; .57658454134
003647  1  13           .BYTE	$13
003648  1  9B           .BYTE	$9B
003649  1  0B           .BYTE	$B
00364A  1  64           .BYTE	$64
00364B  1  80           .BYTE	$80	; .96180075921
00364C  1  76           .BYTE	$76
00364D  1  38           .BYTE	$38
00364E  1  93           .BYTE	$93
00364F  1  16           .BYTE	$16
003650  1  82           .BYTE	$82	; 2.8853900728
003651  1  38           .BYTE	$38
003652  1  AA           .BYTE	$AA
003653  1  3B           .BYTE	$3B
003654  1  20           .BYTE	$20
003655  1               .ENDIF
003655  1  80           SQRHLF: .BYTE $80	; SQR(0.5)
003656  1  35           .BYTE	$35
003657  1  04           .BYTE	4
003658  1  F3           .BYTE	$F3
003659  1               .IF	ADDPRC <> 0
003659  1  34           .BYTE	$34
00365A  1               .ENDIF
00365A  1  81           SQRTWO: .BYTE $81	; SQR(2.0)
00365B  1  35           .BYTE	$35
00365C  1  04           .BYTE	4
00365D  1  F3           .BYTE	$F3
00365E  1               .IF	ADDPRC <> 0
00365E  1  34           .BYTE	$34
00365F  1               .ENDIF
00365F  1  80           NEGHLF: .BYTE $80	; -1/2
003660  1  80           .BYTE	$80
003661  1  00           .BYTE	0
003662  1  00           .BYTE	0
003663  1               .IF	ADDPRC <> 0
003663  1  00           .BYTE	0
003664  1               .ENDIF
003664  1  80           LOG2:	.BYTE $80	; LN(2)
003665  1  31           .BYTE	$31
003666  1  72           .BYTE	$72
003667  1               .IF	ADDPRC = 0
003667  1               .BYTE	$18
003667  1               .ENDIF
003667  1               .IF	ADDPRC <> 0
003667  1  17           .BYTE	$17
003668  1  F8           .BYTE	$F8
003669  1               .ENDIF
003669  1               
003669  1  20 AA 38     LOG:	JSR	SIGN		;IS IT POSITIVE?
00366C  1  F0 02        	BEQ	LOGERR
00366E  1  10 03        	BPL	LOG1
003670  1  4C C6 2E     LOGERR: JMP	FCERR		;CAN'T TOLERATE NEG OR ZERO.
003673  1  A5 B0        LOG1:	LDA	FACEXP		;GET EXPONENT INTO ACCA.
003675  1  E9 7F        	SBC	#$7F		;REMOVE BIAS. (CARRY IS OFF)
003677  1  48           	PHA			;SAVE AWHILE.
003678  1  A9 80        	LDA	#$80
00367A  1  85 B0        	STA	FACEXP		;RESULT IS FAC IN RANGE [0.5,1].
00367C  1  A9 55 A0 36  	LDWDI	SQRHLF		;GET POINTER TO SQR(0.5).
003680  1               
003680  1               ; CALCULATE (F-SQR(.5))/(F+SQR(.5))
003680  1               
003680  1  20 E6 34     	JSR	FADD		;ADD TO FAC.
003683  1  A9 5A A0 36  	LDWDI	SQRTWO		;GET SQR(2.).
003687  1  20 8E 37     	JSR	FDIV
00368A  1  A9 3B A0 36  	LDWDI	FONE
00368E  1  20 CF 34     	JSR	FSUB
003691  1  A9 40 A0 36  	LDWDI	LOGCN2
003695  1  20 84 3C     	JSR	POLYX		;EVALUATE APPROXIMATION POLYNOMIAL.
003698  1  A9 5F A0 36  	LDWDI	NEGHLF		;ADD IN LAST CONSTANT.
00369C  1  20 E6 34     	JSR	FADD
00369F  1  68           	PLA			;GET EXPONENT BACK.
0036A0  1  20 FD 39     	JSR	FINLOG		;ADD IT IN.
0036A3  1  A9 64 A0 36  MULLN2: LDWDI	LOG2		;MULTIPLY RESULT BY LOG(2.0).
0036A7  1               ;	JMP	FMULT		;MULTIPLY TOGETHER.
0036A7  1               ; PAGE
0036A7  1               ; SUBTTL	FLOATING MULTIPLICATION AND DIVISION.
0036A7  1               	;MULTIPLICATION		FAC:=ARG*FAC.
0036A7  1  20 0B 37     FMULT:	JSR	CONUPK		;UNPACK THE CONSTANT INTO ARG FOR USE.
0036AA  1  D0 03 4C 0A  FMULTT: JEQ	MULTRT		;IF FAC=0, RETURN. FAC IS SET.
0036AE  1  37           
0036AF  1  20 36 37     	JSR	MULDIV		;FIX UP THE EXPONENTS.
0036B2  1  A9 00        	LDA	#0		;TO CLEAR RESULT.
0036B4  1  85 75        	STA	RESHO
0036B6  1               .IF	ADDPRC <> 0
0036B6  1  85 76        	STA	RESMOH
0036B8  1               .ENDIF
0036B8  1  85 77        	STA	RESMO
0036BA  1  85 78        	STA	RESLO
0036BC  1  A5 BF        	LDA	FACOV
0036BE  1  20 D8 36     	JSR	MLTPLY
0036C1  1  A5 B4        	LDA	FACLO		;MLTPLY ARG BY FACLO.
0036C3  1  20 D8 36     	JSR	MLTPLY
0036C6  1  A5 B3        	LDA	FACMO		;MLTPLY ARG BY FACMO.
0036C8  1  20 D8 36     	JSR	MLTPLY
0036CB  1               .IF	ADDPRC <> 0
0036CB  1  A5 B2        	LDA	FACMOH
0036CD  1  20 D8 36     	JSR	MLTPLY
0036D0  1               .ENDIF
0036D0  1  A5 B1        	LDA	FACHO		;MLTPLY ARG BY FACHO.
0036D2  1  20 DD 36     	JSR	MLTPL1
0036D5  1  4C 0E 38     	JMP	MOVFR		;MOVE RESULT INTO FAC,
0036D8  1               				;NORMALIZE RESULT, AND RETURN.
0036D8  1  D0 03 4C 02  MLTPLY: JEQ	MULSHF		;SHIFT RESULT RIGHT 1 BYTE.
0036DC  1  36           
0036DD  1  4A           MLTPL1: LSR	A
0036DE  1  09 80        	ORA	#$80
0036E0  1  A8           MLTPL2: TAY
0036E1  1  90 19        	BCC	MLTPL3		;IT MULT BIT=0, JUST SHIFT.
0036E3  1  18           	CLC
0036E4  1  A5 78        	LDA	RESLO
0036E6  1  65 BC        	ADC	ARGLO
0036E8  1  85 78        	STA	RESLO
0036EA  1  A5 77        	LDA	RESMO
0036EC  1  65 BB        	ADC	ARGMO
0036EE  1  85 77        	STA	RESMO
0036F0  1               .IF	ADDPRC <> 0
0036F0  1  A5 76        	LDA	RESMOH
0036F2  1  65 BA        	ADC	ARGMOH
0036F4  1  85 76        	STA	RESMOH
0036F6  1               .ENDIF
0036F6  1  A5 75        	LDA	RESHO
0036F8  1  65 B9        	ADC	ARGHO
0036FA  1  85 75        	STA	RESHO
0036FC  1  66 75        MLTPL3: ROR	RESHO
0036FE  1               .IF	ADDPRC <> 0
0036FE  1  66 76        	ROR	RESMOH
003700  1               .ENDIF
003700  1  66 77        	ROR	RESMO
003702  1  66 78        	ROR	RESLO
003704  1  66 BF        	ROR	FACOV		;SAVE FOR ROUNDING.
003706  1  98           	TYA
003707  1  4A           	LSR	A 		;CLEAR MSB SO WE GET A CLOSER TO 0.
003708  1  D0 D6        	BNE	MLTPL2		;SLOW AS A TURTLE !
00370A  1  60           MULTRT: RTS
00370B  1               
00370B  1               	;ROUTINE TO UNPACK MEMORY INTO ARG.
00370B  1  85 71 84 72  CONUPK: STWD	INDEX1
00370F  1  A0 04        	LDY	#3+ADDPRC
003711  1  B1 71        	LDADY	INDEX1
003713  1  85 BC        	STA	ARGLO
003715  1  88           	DEY
003716  1  B1 71        	LDADY	INDEX1
003718  1  85 BB        	STA	ARGMO
00371A  1  88           	DEY
00371B  1               .IF	ADDPRC <> 0
00371B  1  B1 71        	LDADY	INDEX1
00371D  1  85 BA        	STA	ARGMOH
00371F  1  88           	DEY
003720  1               .ENDIF
003720  1  B1 71        	LDADY	INDEX1
003722  1  85 BD        	STA	ARGSGN
003724  1  45 B5        	EOR	FACSGN
003726  1  85 BE        	STA	ARISGN
003728  1  A5 BD        	LDA	ARGSGN
00372A  1  09 80        	ORA	#$80
00372C  1  85 B9        	STA	ARGHO
00372E  1  88           	DEY
00372F  1  B1 71        	LDADY	INDEX1
003731  1  85 B8        	STA	ARGEXP
003733  1  A5 B0        	LDA	FACEXP		;SET CODES OF FACEXP.
003735  1  60           	RTS
003736  1               
003736  1               	;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV.
003736  1  A5 B8        MULDIV: LDA	ARGEXP		;EXP OF ARG=0?
003738  1  F0 1F        MLDEXP: BEQ	ZEREMV		;SO WE GET ZERO EXPONENT.
00373A  1  18           	CLC
00373B  1  65 B0        	ADC	FACEXP		;RESULT IS IN ACCA.
00373D  1  90 04        	BCC	TRYOFF		;FIND [C] XOR [N].
00373F  1  30 1D        	BMI	GOOVER		;OVERFLOW IF BITS MATCH.
003741  1  18 2C        	CLC
003743  1               	SKIP2
003743  1  10 14        TRYOFF: BPL	ZEREMV		;UNDERFLOW.
003745  1  69 80        	ADC	#$80		;ADD BIAS.
003747  1  85 B0        	STA	FACEXP
003749  1  D0 03 4C 7A  	JEQ	ZEROML		;ZERO THE REST OF IT.
00374D  1  35           
00374E  1  A5 BE        	LDA	ARISGN
003750  1  85 B5        	STA	FACSGN		;ARISGN IS RESULT'S SIGN.
003752  1  60           	RTS			;DONE.
003753  1  A5 B5        MLDVEX: LDA	FACSGN		;GET SIGN.
003755  1  49 FF        	EOR	#$FF		;COMPLEMENT IT.
003757  1  30 05        	BMI	GOOVER
003759  1  68           ZEREMV: PLA			;GET ADDR OFF STACK.
00375A  1  68           	PLA
00375B  1  4C 76 35     	JMP	ZEROFC		;UNDERFLOW.
00375E  1  4C FD 35     GOOVER: JMP	OVERR		;OVERFLOW.
003761  1               
003761  1               	;MULTIPLY FAC BY 10.
003761  1  20 8B 38     MUL10:	JSR	MOVAF		;COPY FAC INTO ARG.
003764  1  AA           	TAX
003765  1  F0 10        	BEQ	MUL10R		;IF [FAC]=0, GOT ANSWER.
003767  1  18           	CLC
003768  1  69 02        	ADC	#2		;AUGMENT EXP BY 2.
00376A  1  B0 F2        	BCS	GOOVER		;OVERFLOW.
00376C  1  A2 00        FINML6: LDX	#0
00376E  1  86 BE        	STX	ARISGN		;SIGNS ARE SAME.
003770  1  20 F6 34     	JSR	FADDC		;ADD TOGETHER.
003773  1  E6 B0        	INC	FACEXP		;MULTIPLY BY TWO.
003775  1  F0 E7        	BEQ	GOOVER		;OVERFLOW.
003777  1  60           MUL10R: RTS
003778  1               
003778  1               	; DIVIDE FAC BY 10.
003778  1  84           TENZC:	.BYTE $84
003779  1  20           .BYTE	$20
00377A  1  00           .BYTE	0
00377B  1  00           .BYTE	0
00377C  1               .IF	ADDPRC <> 0
00377C  1  00           .BYTE	0
00377D  1               .ENDIF
00377D  1  20 8B 38     DIV10:	JSR	MOVAF		;MOVE FAC TO ARG.
003780  1  A9 78 A0 37  	LDWDI	TENZC		;POINT TO CONSTANT OF 10.0
003784  1  A2 00        	LDX	#0		;SIGNS ARE BOTH POSITIVE.
003786  1  86 BE        FDIVF:	STX	ARISGN
003788  1  20 21 38     	JSR	MOVFM		;PUT IT INTO FAC.
00378B  1  4C 91 37     	JMP	FDIVT		;SKIP OVER NEXT TWO BYTES.
00378E  1  20 0B 37     FDIV:	JSR	CONUPK		;UNPACK CONSTANT.
003791  1  F0 76        FDIVT:	BEQ	DV0ERR		;CAN'T DIVIDE BY ZERO !
003793  1               				;(NOT ENOUGH ROOM TO STORE RESULT.)
003793  1  20 9A 38     	JSR	ROUND		;TAKE FACOV INTO ACCT IN FAC.
003796  1  A9 00        	LDA	#0		;NEGATE FACEXP.
003798  1  38           	SEC
003799  1  E5 B0        	SBC	FACEXP
00379B  1  85 B0        	STA	FACEXP
00379D  1  20 36 37     	JSR	MULDIV		;FIX UP EXPONENTS.
0037A0  1  E6 B0        	INC	FACEXP		;SCALE IT RIGHT.
0037A2  1  F0 BA        	BEQ	GOOVER		;OVERFLOW.
0037A4  1  A2 AA        	LDX	#$AE-3-ADDPRC	;SETUP PROCEDURE.
0037A6  1  A9 01        	LDA	#1
0037A8  1               DIVIDE:				;THIS IS THE BEST CODE IN THE WHOLE PILE.
0037A8  1  A4 B9        	LDY	ARGHO		;SEE WHAT RELATION HOLDS.
0037AA  1  C4 B1        	CPY	FACHO
0037AC  1  D0 10        	BNE	SAVQUO		;[C]=0,1. N(C=0)=0.
0037AE  1               .IF	ADDPRC <> 0
0037AE  1  A4 BA        	LDY	ARGMOH
0037B0  1  C4 B2        	CPY	FACMOH
0037B2  1  D0 0A        	BNE	SAVQUO
0037B4  1               .ENDIF
0037B4  1  A4 BB        	LDY	ARGMO
0037B6  1  C4 B3        	CPY	FACMO
0037B8  1  D0 04        	BNE	SAVQUO
0037BA  1  A4 BC        	LDY	ARGLO
0037BC  1  C4 B4        	CPY	FACLO
0037BE  1  08           SAVQUO: PHP
0037BF  1  2A           	ROL	A 		;SAVE RESULT.
0037C0  1  90 09        	BCC	QSHFT		;IF NOT DONE, CONTINUE.
0037C2  1  E8           	INX
0037C3  1  95 78        	STA	RESLO,X
0037C5  1  F0 32        	BEQ	LD100
0037C7  1  10 34        	BPL	DIVNRM		;NOTE THIS REQ 1 MO RAM THEN NECESS.
0037C9  1  A9 01        	LDA	#1
0037CB  1  28           QSHFT:	PLP			;RETURN CONDITION CODES.
0037CC  1  B0 0E        	BCS	DIVSUB		;FAC .LE. ARG.
0037CE  1  06 BC        SHFARG: ASL	ARGLO		;SHIFT ARG ONE PLACE LEFT.
0037D0  1  26 BB        	ROL	ARGMO
0037D2  1               .IF	ADDPRC <> 0
0037D2  1  26 BA        	ROL	ARGMOH
0037D4  1               .ENDIF
0037D4  1  26 B9        	ROL	ARGHO
0037D6  1  B0 E6        	BCS	SAVQUO		;SAVE A RESULT OF ONE FOR THIS POSITION
0037D8  1               				;AND DIVIDE.
0037D8  1  30 CE        	BMI	DIVIDE		;IF MSB ON, GO DECIDE WHETHER TO SUB.
0037DA  1  10 E2        	BPL	SAVQUO
0037DC  1  A8           DIVSUB: TAY			;NOTICE C MUST BE ON HERE.
0037DD  1  A5 BC        	LDA	ARGLO
0037DF  1  E5 B4        	SBC	FACLO
0037E1  1  85 BC        	STA	ARGLO
0037E3  1  A5 BB        	LDA	ARGMO
0037E5  1  E5 B3        	SBC	FACMO
0037E7  1  85 BB        	STA	ARGMO
0037E9  1               .IF	ADDPRC <> 0
0037E9  1  A5 BA        	LDA	ARGMOH
0037EB  1  E5 B2        	SBC	FACMOH
0037ED  1  85 BA        	STA	ARGMOH
0037EF  1               .ENDIF
0037EF  1  A5 B9        	LDA	ARGHO
0037F1  1  E5 B1        	SBC	FACHO
0037F3  1  85 B9        	STA	ARGHO
0037F5  1  98           	TYA
0037F6  1  4C CE 37     	JMP	SHFARG
0037F9  1  A9 40        LD100:	LDA	#$40		;ONLY WANT TWO MORE BITS.
0037FB  1  D0 CE        	BNE	QSHFT		;ALWAYS BRANCHES.
0037FD  1  0A 0A 0A 0A  DIVNRM: REPEAT	6,{ASL A}	;GET LAST TWO BITS INTO MSB AND B6.
003801  1  0A 0A        
003803  1  85 BF        	STA	FACOV
003805  1  28           	PLP			;TO GET GARBAGE OFF STACK.
003806  1  4C 0E 38     	JMP	MOVFR		;MOVE RESULT INTO FAC, THEN
003809  1               				;NORMALIZE RESULT AND RETURN.
003809  1  A2 14        DV0ERR: LDX	#ERRDV0
00380B  1  4C 4E 22     	JMP	ERROR
00380E  1               ; PAGE
00380E  1               ; SUBTTL	FLOATING POINT MOVEMENT ROUTINES.
00380E  1               	;MOVE RESULT TO FAC.
00380E  1  A5 75        MOVFR:	LDA	RESHO
003810  1  85 B1        	STA	FACHO
003812  1               .IF	ADDPRC <> 0
003812  1  A5 76        	LDA	RESMOH
003814  1  85 B2        	STA	FACMOH
003816  1               .ENDIF
003816  1  A5 77        	LDA	RESMO
003818  1  85 B3        	STA	FACMO
00381A  1  A5 78        	LDA	RESLO		;MOVE LO AND SGN.
00381C  1  85 B4        	STA	FACLO
00381E  1  4C 56 35     	JMP	NORMAL		;ALL DONE.
003821  1               
003821  1               	;MOVE MEMORY INTO FAC (UNPACKED).
003821  1  85 71 84 72  MOVFM:	STWD	INDEX1
003825  1  A0 04        	LDY	#3+ADDPRC
003827  1  B1 71        	LDADY	INDEX1
003829  1  85 B4        	STA	FACLO
00382B  1  88           	DEY
00382C  1  B1 71        	LDADY	INDEX1
00382E  1  85 B3        	STA	FACMO
003830  1  88           	DEY
003831  1               .IF	ADDPRC <> 0
003831  1  B1 71        	LDADY	INDEX1
003833  1  85 B2        	STA	FACMOH
003835  1  88           	DEY
003836  1               .ENDIF
003836  1  B1 71        	LDADY	INDEX1
003838  1  85 B5        	STA	FACSGN
00383A  1  09 80        	ORA	#$80
00383C  1  85 B1        	STA	FACHO
00383E  1  88           	DEY
00383F  1  B1 71        	LDADY	INDEX1
003841  1  85 B0        	STA	FACEXP		;LEAVE SWITCHES SET ON EXP.
003843  1  84 BF        	STY	FACOV
003845  1  60           	RTS
003846  1               
003846  1               	;MOVE NUMBER FROM FAC TO MEMORY.
003846  1  A2 AB 2C     MOV2F:	LDX	#TEMPF2
003849  1               	SKIP2
003849  1  A2 A6        MOV1F:	LDX	#TEMPF1
00384B  1  A0 00        MOVML:	LDY	#0
00384D  1  F0 04        	BEQ	MOVMF		;ALWAYS BRANCHES.
00384F  1  A6 98 A4 99  MOVVF:	LDXY	FORPNT
003853  1  20 9A 38     MOVMF:	JSR	ROUND
003856  1  86 71 84 72  	STXY	INDEX1
00385A  1  A0 04        	LDY	#3+ADDPRC
00385C  1  A5 B4        	LDA	FACLO
00385E  1  91 71        	STADY	INDEX
003860  1  88           	DEY
003861  1  A5 B3        	LDA	FACMO
003863  1  91 71        	STADY	INDEX
003865  1  88           	DEY
003866  1               .IF	ADDPRC <> 0
003866  1  A5 B2        	LDA	FACMOH
003868  1  91 71        	STADY	INDEX
00386A  1  88           	DEY
00386B  1               .ENDIF
00386B  1  A5 B5        	LDA	FACSGN		;INCLUDE SIGN IN HO.
00386D  1  09 7F        	ORA	#$7F
00386F  1  25 B1        	AND	FACHO
003871  1  91 71        	STADY	INDEX
003873  1  88           	DEY
003874  1  A5 B0        	LDA	FACEXP
003876  1  91 71        	STADY	INDEX
003878  1  84 BF        	STY	FACOV		;ZERO IT SINCE ROUNDED.
00387A  1  60           	RTS			;[Y]=0.
00387B  1               
00387B  1               	;MOVE ARG INTO FAC.
00387B  1  A5 BD        MOVFA:	LDA	ARGSGN
00387D  1  85 B5        MOVFA1: STA	FACSGN
00387F  1  A2 05        	LDX	#4+ADDPRC
003881  1  B5 B7        MOVFAL: LDA	ARGEXP-1,X
003883  1  95 AF        	STA	FACEXP-1,X
003885  1  CA           	DEX
003886  1  D0 F9        	BNE	MOVFAL
003888  1  86 BF        	STX	FACOV
00388A  1  60           	RTS
00388B  1               
00388B  1               	;MOVE FAC INTO ARG.
00388B  1  20 9A 38     MOVAF:	JSR	ROUND
00388E  1  A2 06        MOVEF:	LDX	#5+ADDPRC
003890  1  B5 AF        MOVAFL: LDA	FACEXP-1,X
003892  1  95 B7        	STA	ARGEXP-1,X
003894  1  CA           	DEX
003895  1  D0 F9        	BNE	MOVAFL
003897  1  86 BF        	STX	FACOV		;ZERO IT SINCE ROUNDED.
003899  1  60           MOVRTS: RTS
00389A  1               
00389A  1  A5 B0        ROUND:	LDA	FACEXP		;ZERO?
00389C  1  F0 FB        	BEQ	MOVRTS		;YES. DONE ROUNDING.
00389E  1  06 BF        	ASL	FACOV		;ROUND?
0038A0  1  90 F7        	BCC	MOVRTS		;NO. MSB OFF.
0038A2  1  20 EE 35     INCRND: JSR	INCFAC		;YES, ADD ONE TO LSB(FAC).
0038A5  1  D0 F2        	BNE	MOVRTS		;NO CARRY MEANS DONE.
0038A7  1  4C B7 35     	JMP	RNDSHF		;SQUEEZ MSB IN AND RTS.
0038AA  1               				;NOTE [C]=1 SINCE INCFAC DOESNT TOUCH C.
0038AA  1               ; PAGE
0038AA  1               ; SUBTTL	SIGN, SGN, FLOAT, NEG, ABS.
0038AA  1               
0038AA  1               	;PUT SIGN OF FAC IN ACCA.
0038AA  1  A5 B0        SIGN:	LDA	FACEXP
0038AC  1  F0 09        	BEQ	SIGNRT		;IF NUMBER IS ZERO, SO IS RESULT.
0038AE  1  A5 B5        FCSIGN: LDA	FACSGN
0038B0  1  2A           FCOMPS: ROL	A
0038B1  1  A9 FF        	LDA	#$FF		;ASSUME NEGATIVE.
0038B3  1  B0 02        	BCS	SIGNRT
0038B5  1  A9 01        	LDA	#1		;GET +1.
0038B7  1  60           SIGNRT: RTS
0038B8  1               
0038B8  1               	;SGN FUNCTION.
0038B8  1  20 AA 38     SGN:	JSR	SIGN
0038BB  1               
0038BB  1               	;FLOAT THE SIGNED INTEGER IN ACCA.
0038BB  1  85 B1        FLOAT:	STA	FACHO		;PUT [ACCA] IN HIGH ORDER.
0038BD  1  A9 00        	LDA	#0
0038BF  1  85 B2        	STA	FACHO+1
0038C1  1  A2 88        	LDX	#$88		;GET THE EXPONENT.
0038C3  1               
0038C3  1               	;FLOAT THE SIGNED NUMBER IN FAC.
0038C3  1  A5 B1        FLOATS: LDA	FACHO
0038C5  1  49 FF        	EOR	#$FF
0038C7  1  2A           	ROL	A 		;GET COMP OF SIGN IN CARRY.
0038C8  1  A9 00        FLOATC: LDA	#0		;ZERO [ACCA] BUT NOT CARRY.
0038CA  1  85 B4        	STA	FACLO
0038CC  1               .IF	ADDPRC <> 0
0038CC  1  85 B3        	STA	FACMO
0038CE  1               .ENDIF
0038CE  1  86 B0        FLOATB: STX	FACEXP
0038D0  1  85 BF        	STA	FACOV
0038D2  1  85 B5        	STA	FACSGN
0038D4  1  4C 51 35     	JMP	FADFLT
0038D7  1               
0038D7  1               	;ABSOLUTE VALUE OF FAC.
0038D7  1  46 B5        ABS:	LSR	FACSGN
0038D9  1  60           	RTS
0038DA  1               
0038DA  1               ; PAGE
0038DA  1               ; SUBTTL	COMPARE TWO NUMBERS.
0038DA  1               	;A=1 IF ARG .LT. FAC.
0038DA  1               	;A=0 IF ARG=FAC.
0038DA  1               	;A=-1 IF ARG .GT. FAC.
0038DA  1  85 73        FCOMP:	STA	INDEX2
0038DC  1  84 74        FCOMPN: STY	INDEX2+1
0038DE  1  A0 00        	LDY	#0
0038E0  1  B1 73        	LDADY	INDEX2		;HAS ARGEXP.
0038E2  1  C8           	INY			;BUMP PNTR UP.
0038E3  1  AA           	TAX			;SAVE A IN X AND RESET CODES.
0038E4  1  F0 C4        	BEQ	SIGN
0038E6  1  B1 73        	LDADY	INDEX2
0038E8  1  45 B5        	EOR	FACSGN		;SIGNS THE SAME.
0038EA  1  30 C2        	BMI	FCSIGN		;SIGNS DIFFER SO RESULT IS
0038EC  1               				;SIGN OF FAC AGAIN.
0038EC  1  E4 B0        FOUTCP: CPX	FACEXP
0038EE  1  D0 21        	BNE	FCOMPC
0038F0  1  B1 73        	LDADY	INDEX2
0038F2  1  09 80        	ORA	#$80
0038F4  1  C5 B1        	CMP	FACHO
0038F6  1  D0 19        	BNE	FCOMPC
0038F8  1  C8           	INY
0038F9  1               .IF	ADDPRC <> 0
0038F9  1  B1 73        	LDADY	INDEX2
0038FB  1  C5 B2        	CMP	FACMOH
0038FD  1  D0 12        	BNE	FCOMPC
0038FF  1  C8           	INY
003900  1               .ENDIF
003900  1  B1 73        	LDADY	INDEX2
003902  1  C5 B3        	CMP	FACMO
003904  1  D0 0B        	BNE	FCOMPC
003906  1  C8           	INY
003907  1  A9 7F        	LDA	#$7F
003909  1  C5 BF        	CMP	FACOV
00390B  1  B1 73        	LDADY	INDEX2
00390D  1  E5 B4        	SBC	FACLO		;GET ZERO IF EQUAL.
00390F  1  F0 28        	BEQ	QINTRT
003911  1  A5 B5        FCOMPC: LDA	FACSGN
003913  1  90 02        	BCC	FCOMPD
003915  1  49 FF        	EOR	#$FF
003917  1  4C B0 38     FCOMPD: JMP	FCOMPS		;A PART OF SIGN SETS ACCA UP.
00391A  1               
00391A  1               ; PAGE
00391A  1               ; SUBTTL	GREATEST INTEGER FUNCTION.
00391A  1               	;QUICK GREATEST INTEGER FUNCTION.
00391A  1               	;LEAVES INT(FAC) IN FACHO&MO&LO SIGNED.
00391A  1               	;ASSUMES FAC .LT. 2^23 = 8388608
00391A  1  A5 B0        QINT:	LDA	FACEXP
00391C  1  F0 4A        	BEQ	CLRFAC		;IF ZERO, GOT IT.
00391E  1  38           	SEC
00391F  1  E9 A0        	SBC	#8*ADDPRC+$98	;GET NUMBER OF PLACES TO SHIFT.
003921  1  24 B5        	BIT	FACSGN
003923  1  10 09        	BPL	QISHFT
003925  1  AA           	TAX
003926  1  A9 FF        	LDA	#$FF
003928  1  85 B7        	STA	BITS		;PUT 377 IN WHEN SHFTR SHIFTS BYTES.
00392A  1  20 CC 35     	JSR	NEGFCH		;TRULY NEGATE QUANTITY IN FAC.
00392D  1  8A           	TXA
00392E  1  A2 B0        QISHFT: LDX	#FAC
003930  1  C9 A7        	CMP	#$AE-7
003932  1  10 06        	BPL	QINT1		;IF NUMBER OF PLACES .GE. 7
003934  1               				;SHIFT 1 PLACE AT A TIME.
003934  1  20 18 36     	JSR	SHIFTR		;START SHIFTING BYTES, THEN BITS.
003937  1  84 B7        	STY	BITS		;ZERO BITS SINCE ADDER WANTS ZERO.
003939  1  60           QINTRT: RTS
00393A  1  A8           QINT1:	TAY			;PUT COUNT IN COUNTER.
00393B  1  A5 B5        	LDA	FACSGN
00393D  1  29 80        	AND	#$80		;GET SIGN BIT.
00393F  1  46 B1        	LSR	FACHO		;SAVE FIRST SHIFTED BYTE.
003941  1  05 B1        	ORA	FACHO
003943  1  85 B1        	STA	FACHO
003945  1  20 2F 36     	JSR	ROLSHF		;SHIFT THE REST.
003948  1  84 B7        	STY	BITS		;ZERO [BITS].
00394A  1  60           	RTS
00394B  1               
00394B  1               	;GREATEST INTEGER FUNCTION.
00394B  1  A5 B0        INT:	LDA	FACEXP
00394D  1  C9 A0        	CMP	#8*ADDPRC+$98
00394F  1  B0 20        	BCS	INTRTS		;FORGET IT.
003951  1  20 1A 39     	JSR	QINT
003954  1  84 BF        	STY	FACOV		;CLR OVERFLOW BYTE.
003956  1  A5 B5        	LDA	FACSGN
003958  1  84 B5        	STY	FACSGN		;MAKE FAC LOOK POSITIVE.
00395A  1  49 80        	EOR	#$80		;GET COMPLEMENT OF SIGN IN CARRY.
00395C  1  2A           	ROL	A
00395D  1  A9 A0        	LDA	#8*ADDPRC+$98
00395F  1  85 B0        	STA	FACEXP
003961  1  A5 B4        	LDA	FACLO
003963  1  85 0D        	STA	INTEGR
003965  1  4C 51 35     	JMP	FADFLT
003968  1  85 B1        CLRFAC: STA	FACHO		;MAKE IT REALLY ZERO.
00396A  1               .IF	ADDPRC <> 0
00396A  1  85 B2        	STA FACMOH
00396C  1               .ENDIF
00396C  1  85 B3        	STA	FACMO
00396E  1  85 B4        	STA	FACLO
003970  1  A8           	TAY
003971  1  60           INTRTS: RTS
003972  1               ; PAGE
003972  1               ; SUBTTL	FLOATING POINT INPUT ROUTINE.
003972  1               	;NUMBER INPUT IS LEFT IN FAC.
003972  1               	;AT ENTRY [TXTPTR] POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
003972  1               	;THE FIRST CHARACTER IS ALSO IN ACCA. FIN PACKS THE DIGITS
003972  1               	;INTO THE FAC AS AN INTEGER AND KEEPS TRACK OF WHERE THE
003972  1               	;DECIMAL POINT IS. [DPTFLG] TELL WHETHER A DP HAS BEEN
003972  1               	;SEEN. [DECCNT] IS THE NUMBER OF DIGITS AFTER THE DP.
003972  1               	;AT THE END [DECCNT] AND THE EXPONENT ARE USED TO
003972  1               	;DETERMINE HOW MANY TIMES TO MULTIPLY OR DIVIDE BY TEN
003972  1               	;TO GET THE CORRECT NUMBER.
003972  1  A0 00        FIN:	LDY	#0		;ZERO FACSGN&SGNFLG.
003974  1  A2 0A        	LDX	#$9+ADDPRC	;ZERO EXP AND HO (AND MOH).
003976  1  94 AC        FINZLP: STY	DECCNT,X	;ZERO MO AND LO.
003978  1  CA           	DEX			;ZERO TENEXP AND EXPSGN
003979  1  10 FB        	BPL	FINZLP		;ZERO DECCNT, DPTFLG.
00397B  1  90 0F        	BCC	FINDGQ		;FLAGS STILL SET FROM CHRGET.
00397D  1  C9 2D        	CMP	#'-'		;A NEGATIVE SIGN?
00397F  1  D0 04        	BNE	QPLUS		;NO, TRY PLUS SIGN.
003981  1  86 B6        	STX	SGNFLG		;IT'S NEGATIVE. (X=377).
003983  1  F0 04        	BEQ	FINC		;ALWAYS BRANCHES.
003985  1  C9 2B        QPLUS:	CMP	#'+'		;PLUS SIGN?
003987  1  D0 05        	BNE	FIN1		;YES, SKIP IT.
003989  1  20 C2 00     FINC:	JSR	CHRGET
00398C  1  90 5B        FINDGQ: BCC	FINDIG
00398E  1  C9 2E        FIN1:	CMP	#'.'		;THE DP?
003990  1  F0 2E        	BEQ	FINDP		;NO KIDDING.
003992  1  C9 45        	CMP	#'E'		;EXPONENT FOLLOWS.
003994  1  D0 30        	BNE	FINE		;NO.
003996  1               	;HERE TO CHECK FOR SIGN OF EXP.
003996  1  20 C2 00     	JSR	CHRGET		;YES. GET ANOTHER.
003999  1  90 17        	BCC	FNEDG1		;IT IS A DIGIT. (EASIER THAN
00399B  1               				;BACKING UP POINTER.)
00399B  1  C9 A4        	CMP	#MINUTK		;MINUS?
00399D  1  F0 0E        	BEQ	FINEC1		;NEGATE.
00399F  1  C9 2D        	CMP	#'-'		;MINUS SIGN?
0039A1  1  F0 0A        	BEQ	FINEC1
0039A3  1  C9 A3        	CMP	#PLUSTK		;PLUS?
0039A5  1  F0 08        	BEQ	FINEC
0039A7  1  C9 2B        	CMP	#'+'		;PLUS SIGN?
0039A9  1  F0 04        	BEQ	FINEC
0039AB  1  D0 07        	BNE	FINEC2
0039AD  1  66 AF        FINEC1: ROR	EXPSGN		;TURN IT ON.
0039AF  1  20 C2 00     FINEC:	JSR	CHRGET		;GET ANOTHER.
0039B2  1  90 5C        FNEDG1: BCC	FINEDG		;IT IS A DIGIT.
0039B4  1  24 AF        FINEC2: BIT	EXPSGN
0039B6  1  10 0E        	BPL	FINE
0039B8  1  A9 00        	LDA	#0
0039BA  1  38           	SEC
0039BB  1  E5 AD        	SBC	TENEXP
0039BD  1  4C C8 39     	JMP	FINE1
0039C0  1  66 AE        FINDP:	ROR	DPTFLG
0039C2  1  24 AE        	BIT	DPTFLG
0039C4  1  50 C3        	BVC	FINC
0039C6  1  A5 AD        FINE:	LDA	TENEXP
0039C8  1  38           FINE1:	SEC
0039C9  1  E5 AC        	SBC	DECCNT		;GET NUMBER OF PLACES TO SHIFT.
0039CB  1  85 AD        	STA	TENEXP
0039CD  1  F0 12        	BEQ	FINQNG		;NEGATE?
0039CF  1  10 09        	BPL	FINMUL		;POSITIVE SO MULTIPLY.
0039D1  1  20 7D 37     FINDIV: JSR	DIV10
0039D4  1  E6 AD        	INC	TENEXP		;DONE?
0039D6  1  D0 F9        	BNE	FINDIV		;NO.
0039D8  1  F0 07        	BEQ	FINQNG		;YES.
0039DA  1  20 61 37     FINMUL: JSR	MUL10
0039DD  1  C6 AD        	DEC	TENEXP		;DONE?
0039DF  1  D0 F9        	BNE	FINMUL		;NO
0039E1  1  A5 B6        FINQNG: LDA	SGNFLG
0039E3  1  30 01        	BMI	NEGXQS		;IF POSITIVE, RETURN.
0039E5  1  60           	RTS
0039E6  1  4C F8 3B     NEGXQS: JMP	NEGOP		;OTHERWISE, NEGATE AND RETURN.
0039E9  1               
0039E9  1  48           FINDIG: PHA
0039EA  1  24 AE        	BIT	DPTFLG
0039EC  1  10 02        	BPL	FINDG1
0039EE  1  E6 AC        	INC	DECCNT
0039F0  1  20 61 37     FINDG1: JSR	MUL10
0039F3  1  68           	PLA			;GET IT BACK.
0039F4  1  38           	SEC
0039F5  1  E9 30        	SBC	#'0'
0039F7  1  20 FD 39     	JSR	FINLOG		;ADD IT IN.
0039FA  1  4C 89 39     	JMP	FINC
0039FD  1               
0039FD  1  48           FINLOG: PHA
0039FE  1  20 8B 38     	JSR	MOVAF		;SAVE FAC FOR LATER.
003A01  1  68           	PLA
003A02  1  20 BB 38     	JSR	FLOAT		;FLOAT THE VALUE IN ACCA.
003A05  1  A5 BD        	LDA	ARGSGN
003A07  1  45 B5        	EOR	FACSGN
003A09  1  85 BE        	STA	ARISGN		;RESULTANT SIGN.
003A0B  1  A6 B0        	LDX	FACEXP		;SET SIGNS ON THING TO ADD.
003A0D  1  4C E9 34     	JMP	FADDT		;ADD TOGETHER AND RETURN.
003A10  1               
003A10  1               	;HERE PACK IN THE NEXT DIGIT OF THE EXPONENT.
003A10  1               	;MULTIPLY THE OLD EXP BY 10 AND ADD IN THE NEXT
003A10  1               	;DIGIT. NOTE: EXP OVERFLOW IS NOT CHECKED FOR.
003A10  1  A5 AD        FINEDG: LDA	TENEXP		;GET EXP SO FAR.
003A12  1  C9 0A        	CMP	#$A		;WILL RESULT BE .GE. 100?
003A14  1  90 09        	BCC	MLEX10
003A16  1  A9 64        	LDA	#$64		;GET 100.
003A18  1  24 AF        	BIT	EXPSGN
003A1A  1  30 11        	BMI	MLEXMI		;IF NEG EXP, NO CHK FOR OVERR.
003A1C  1  4C FD 35     	JMP	OVERR
003A1F  1  0A           MLEX10: ASL	A 		;MULT BY 2 TWICE
003A20  1  0A           	ASL	A
003A21  1  18           	CLC			;POSSIBLE SHIFT OUT OF HIGH.
003A22  1  65 AD        	ADC	TENEXP		;LIKE MULTIPLYING BY FIVE.
003A24  1  0A           	ASL	A 		;AND NOW BY TEN.
003A25  1  18           	CLC
003A26  1  A0 00        	LDY	#0
003A28  1  71 C9        	ADCDY	TXTPTR
003A2A  1  38           	SEC
003A2B  1  E9 30        	SBC	#'0'
003A2D  1  85 AD        MLEXMI: STA	TENEXP		;SAVE RESULT.
003A2F  1  4C AF 39     	JMP	FINEC
003A32  1               ; PAGE
003A32  1               ; SUBTTL	FLOATING POINT OUTPUT ROUTINE.
003A32  1               
003A32  1               .IF	ADDPRC = 0
003A32  1               NZ0999: .BYTE $91	; 99999.9499
003A32  1               .BYTE	$43
003A32  1               .BYTE	$4F
003A32  1               .BYTE	$F8
003A32  1               NZ9999: .BYTE $94	; 999999.499
003A32  1               .BYTE	$74
003A32  1               .BYTE	$23
003A32  1               .BYTE	$F7
003A32  1               NZMIL:	.BYTE $94	; 10^6.
003A32  1               .BYTE	$74
003A32  1               .BYTE	$24
003A32  1               .BYTE	0
003A32  1               .ENDIF
003A32  1               .IF	ADDPRC <> 0
003A32  1  9B           NZ0999: .BYTE $9B	; 99999999.9499
003A33  1  3E           .BYTE	$3E
003A34  1  BC           .BYTE	$BC
003A35  1  1F           .BYTE	$1F
003A36  1  FD           .BYTE	$FD
003A37  1  9E           NZ9999: .BYTE $9E	; 999999999.499
003A38  1  6E           .BYTE	$6E
003A39  1  6B           .BYTE	$6B
003A3A  1  27           .BYTE	$27
003A3B  1  FD           .BYTE	$FD
003A3C  1  9E           NZMIL:	.BYTE $9E	; 10^9
003A3D  1  6E           .BYTE	$6E
003A3E  1  6B           .BYTE	$6B
003A3F  1  28           .BYTE	$28
003A40  1  00           .BYTE	0
003A41  1               .ENDIF
003A41  1               	;ENTRY TO LINPRT.
003A41  1  A9 8D A0 21  INPRT:	LDWDI	INTXT
003A45  1  20 59 3A     	JSR	STROU2
003A48  1  A5 89        	LDA	CURLIN+1
003A4A  1  A6 88        	LDX	CURLIN
003A4C  1  85 B1 86 B2  LINPRT: STWX	FACHO
003A50  1  A2 90        	LDX	#$90		;EXPONENT OF 16.
003A52  1  38           	SEC			;NUMBER IS POSITIVE.
003A53  1  20 C8 38     	JSR	FLOATC
003A56  1  20 5C 3A     	JSR	FOUT
003A59  1  4C 9B 28     STROU2: JMP	STROUT		;PRINT AND RETURN.
003A5C  1               
003A5C  1  A0 01        FOUT:	LDY	#1
003A5E  1  A9 20        FOUTC:	LDA	#' '		;PRINT SPACE IF POSITIVE.
003A60  1  24 B5        	BIT	FACSGN
003A62  1  10 02        	BPL	FOUT1
003A64  1  A9 2D        	LDA	#'-'
003A66  1  99 FF 00     FOUT1:	STA	FBUFFR-1,Y 	;STORE THE CHARACTER.
003A69  1  85 B5        	STA	FACSGN		;MAKE FAC POS FOR QINT.
003A6B  1  84 C0        	STY	FBUFPT		;SAVE FOR LATER.
003A6D  1  C8           	INY
003A6E  1  A9 30        	LDA	#'0'		;GET ZERO TO TYPE IF FAC=0.
003A70  1  A6 B0        	LDX	FACEXP
003A72  1  D0 03 4C 7F  	JEQ	FOUT19
003A76  1  3B           
003A77  1  A9 00        	LDA	#0
003A79  1  E0 80        	CPX	#$80		;IS NUMBER .LT. 1.0 ?
003A7B  1  F0 02        	BEQ	FOUT37		;NO.
003A7D  1  B0 09        	BCS	FOUT7
003A7F  1  A9 3C A0 3A  FOUT37: LDWDI	NZMIL		;MULTIPLY BY 10^6.
003A83  1  20 A7 36     	JSR	FMULT
003A86  1  A9 A5        	LDA	#$AE-3*ADDPRC-6
003A88  1  85 AC        FOUT7:	STA	DECCNT		;SAVE COUNT OR ZERO IT.
003A8A  1  A9 37 A0 3A  FOUT4:	LDWDI	NZ9999
003A8E  1  20 DA 38     	JSR	FCOMP		;IS NUMBER .GT. 999999.499 ?
003A91  1               				;OR 999999999.499?
003A91  1  F0 1E        	BEQ	BIGGES
003A93  1  10 12        	BPL	FOUT9		;YES. MAKE IT SMALLER.
003A95  1  A9 32 A0 3A  FOUT3:	LDWDI	NZ0999
003A99  1  20 DA 38     	JSR	FCOMP		;IS NUMBER .GT. 99999.9499 ?
003A9C  1               				; OR 99999999.9499?
003A9C  1  F0 02        	BEQ	FOUT38
003A9E  1  10 0E        	BPL	FOUT5		;YES. DONE MULTIPLYING.
003AA0  1  20 61 37     FOUT38: JSR	MUL10		;MAKE IT BIGGER.
003AA3  1  C6 AC        	DEC	DECCNT
003AA5  1  D0 EE        	BNE	FOUT3		;SEE IF THAT DOES IT.
003AA7  1               				;THIS ALWAYS GOES.
003AA7  1  20 7D 37     FOUT9:	JSR	DIV10		;MAKE IT SMALLER.
003AAA  1  E6 AC        	INC	DECCNT
003AAC  1  D0 DC        	BNE	FOUT4		;SEE IF THAT DOES IT.
003AAE  1               				;THIS ALWAYS GOES.
003AAE  1               
003AAE  1  20 C8 34     FOUT5:	JSR	FADDH		;ADD A HALF TO ROUND UP.
003AB1  1  20 1A 39     BIGGES: JSR	QINT
003AB4  1  A2 01        	LDX	#1		;DECIMAL POINT COUNT.
003AB6  1  A5 AC        	LDA	DECCNT
003AB8  1  18           	CLC
003AB9  1  69 0A        	ADC	#3*ADDPRC+7	;SHOULD NUMBER BE PRINTED IN E NOTATION?
003ABB  1               				;IE, IS NUMBER .LT. .01 ?
003ABB  1  30 09        	BMI	FOUTPI		;YES.
003ABD  1  C9 0B        	CMP	#3*ADDPRC+$8	;IS IT .GT. 999999 (999999999)?
003ABF  1  B0 06        	BCS	FOUT6		;YES. USE E NOTATION.
003AC1  1  69 FF        	ADC	#$FF		;NUMBER OF PLACES BEFORE DECIMAL POINT.
003AC3  1  AA           	TAX			;PUT INTO ACCX.
003AC4  1  A9 02        	LDA	#2		;NO E NOTATION.
003AC6  1  38           FOUTPI: SEC
003AC7  1  E9 02        FOUT6:	SBC	#2		;EFFECTIVELY ADD 5 TO ORIG EXP.
003AC9  1  85 AD        	STA	TENEXP		;THAT IS THE EXPONENT TO PRINT.
003ACB  1  86 AC        	STX	DECCNT		;NUMBER OF DECIMAL PLACES.
003ACD  1  8A           	TXA
003ACE  1  F0 02        	BEQ	FOUT39
003AD0  1  10 13        	BPL	FOUT8		;SOME PLACES BEFORE DEC PNT.
003AD2  1  A4 C0        FOUT39: LDY	FBUFPT		;GET POINTER TO OUTPUT.
003AD4  1  A9 2E        	LDA	#'.'		;PUT IN "."
003AD6  1  C8           	INY
003AD7  1  99 FF 00     	STA	FBUFFR-1,Y
003ADA  1  8A           	TXA
003ADB  1  F0 06        	BEQ	FOUT16
003ADD  1  A9 30        	LDA	#'0'		;GET THE ENSUING ZERO.
003ADF  1  C8           	INY
003AE0  1  99 FF 00     	STA	FBUFFR-1,Y
003AE3  1  84 C0        FOUT16: STY	FBUFPT		;SAVE FOR LATER.
003AE5  1  A0 00        FOUT8:	LDY	#0
003AE7  1  A2 80        FOUTIM: LDX	#$80		;FIRST PASS THRU, ACCX HAS MSB SET.
003AE9  1  A5 B4        FOUT2:	LDA	FACLO
003AEB  1  18           	CLC
003AEC  1  79 94 3B     	ADC	FOUTBL+2+ADDPRC,Y
003AEF  1  85 B4        	STA	FACLO
003AF1  1  A5 B3        	LDA	FACMO
003AF3  1  79 93 3B     	ADC	FOUTBL+1+ADDPRC,Y
003AF6  1  85 B3        	STA	FACMO
003AF8  1               .IF	ADDPRC <> 0
003AF8  1  A5 B2        	LDA	FACMOH
003AFA  1  79 92 3B     	ADC	FOUTBL+1,Y
003AFD  1  85 B2        	STA	FACMOH
003AFF  1               .ENDIF
003AFF  1  A5 B1        	LDA	FACHO
003B01  1  79 91 3B     	ADC	FOUTBL,Y
003B04  1  85 B1        	STA	FACHO
003B06  1  E8           	INX			;IT WAS DONE YET ANOTHER TIME.
003B07  1  B0 04        	BCS	FOUT41
003B09  1  10 DE        	BPL	FOUT2
003B0B  1  30 02        	BMI	FOUT40
003B0D  1  30 DA        FOUT41: BMI	FOUT2
003B0F  1  8A           FOUT40: TXA
003B10  1  90 04        	BCC	FOUTYP		;CAN USE ACCA AS IS.
003B12  1  49 FF        	EOR	#$FF		;FIND 11.-[A].
003B14  1  69 0A        	ADC	#$A		;C IS STILL ON TO COMPLETE NEGATION.
003B16  1               				;AND WILL ALWAYS BE ON AFTER.
003B16  1  69 2F        FOUTYP: ADC	#'0'-1		;GET A CHARACTER TO PRINT.
003B18  1  C8 C8 C8 C8  	REPEAT	3+ADDPRC,{INY}	;BUMP POINTER UP.
003B1C  1  84 96        	STY	FDECPT
003B1E  1  A4 C0        	LDY	FBUFPT
003B20  1  C8           	INY			;POINT TO PLACE TO STORE OUTPUT.
003B21  1  AA           	TAX
003B22  1  29 7F        	AND	#$7F		;GET RID OF MSB.
003B24  1  99 FF 00     	STA	FBUFFR-1,Y
003B27  1  C6 AC        	DEC	DECCNT
003B29  1  D0 06        	BNE	STXBUF		;NOT TIME FOR DP YET.
003B2B  1  A9 2E        	LDA	#'.'
003B2D  1  C8           	INY
003B2E  1  99 FF 00     	STA	FBUFFR-1,Y 	;STORE DP.
003B31  1  84 C0        STXBUF: STY	FBUFPT		;STORE PNTR FOR LATER.
003B33  1  A4 96        	LDY	FDECPT
003B35  1  8A           FOUTCM: TXA			;COMPLEMENT ACCX
003B36  1  49 FF        	EOR	#$FF		;COMPLEMENT ACCA.
003B38  1  29 80        	AND	#$80		;SAVE ONLY MSB.
003B3A  1  AA           	TAX
003B3B  1  C0 24        	CPY	#FDCEND-FOUTBL
003B3D  1               .IF	TIME <> 0
003B3D  1               	BEQ	FOULDY
003B3D  1               	CPY	#TIMEND-FOUTBL
003B3D  1               .ENDIF
003B3D  1  D0 AA        	BNE	FOUT2		;CONTINUE WITH OUTPUT.
003B3F  1  A4 C0        FOULDY: LDY	FBUFPT		;GET BACK OUTPUT PNTR.
003B41  1  B9 FF 00     FOUT11: LDA	FBUFFR-1,Y 	;REMOVE TRAILING ZEROES.
003B44  1  88           	DEY
003B45  1  C9 30        	CMP	#'0'
003B47  1  F0 F8        	BEQ	FOUT11
003B49  1  C9 2E        	CMP	#'.'
003B4B  1  F0 01        	BEQ	FOUT12		;RUN INTO DP. STOP.
003B4D  1  C8           	INY			;SOMETHING ELSE. SAVE IT.
003B4E  1  A9 2B        FOUT12: LDA	#'+'
003B50  1  A6 AD        	LDX	TENEXP
003B52  1  F0 2E        	BEQ	FOUT17		;NO EXPONENT TO OUTPUT.
003B54  1  10 08        	BPL	FOUT14
003B56  1  A9 00        	LDA	#0
003B58  1  38           	SEC
003B59  1  E5 AD        	SBC	TENEXP
003B5B  1  AA           	TAX
003B5C  1  A9 2D        	LDA	#'-'		;EXPONENT IS NEGATIVE.
003B5E  1  99 01 01     FOUT14: STA	FBUFFR-1+2,Y 	;STORE SIGN OF EXP
003B61  1  A9 45        	LDA	#'E'
003B63  1  99 00 01     	STA	FBUFFR-1+1,Y 	;STORE THE "E" CHARACTER.
003B66  1  8A           	TXA
003B67  1  A2 2F        	LDX	#'0'-1
003B69  1  38           	SEC
003B6A  1  E8           FOUT15: INX			;MOVE CLOSER TO OUTPUT VALUE.
003B6B  1  E9 0A        	SBC	#$A		;SUBTRACT 10.
003B6D  1  B0 FB        	BCS	FOUT15		;NOT NEGATIVE YET.
003B6F  1  69 3A        	ADC	#'0'+$A		;GET SECOND OUTPUT CHARACTER.
003B71  1  99 03 01     	STA	FBUFFR-1+4,Y 	;STORE HIGH DIGIT.
003B74  1  8A           	TXA
003B75  1  99 02 01     	STA	FBUFFR-1+3,Y 	;STORE	LOW DIGIT.
003B78  1  A9 00        	LDA	#0		;PUT IN TERMINATOR.
003B7A  1  99 04 01 F0  	STA	FBUFFR-1+5,Y
003B7E  1  08           
003B7F  1               	BEQA	FOUT20		;RETURN. (ALWAYS BRANCHES).
003B7F  1  99 FF 00     FOUT19: STA	FBUFFR-1,Y 	;STORE THE CHARACTER.
003B82  1  A9 00        FOUT17: LDA	#0		;A TERMINATOR.
003B84  1  99 00 01     	STA	FBUFFR-1+1,Y
003B87  1  A9 00 A0 01  FOUT20: LDWDI	FBUFFR
003B8B  1  60           FPWRRT: RTS			;ALL DONE.
003B8C  1  80           FHALF:	.BYTE $80	;1/2
003B8D  1  00           .BYTE	0
003B8E  1  00           ZERO:	.BYTE 0
003B8F  1  00           .BYTE	0
003B90  1               .IF	ADDPRC <> 0
003B90  1  00           .BYTE	0
003B91  1               .ENDIF
003B91  1               
003B91  1               ;POWER OF TEN TABLE
003B91  1               .IF	ADDPRC = 0
003B91  1               FOUTBL: .BYTE $FE	;-100000
003B91  1               .BYTE	$79
003B91  1               .BYTE	$60
003B91  1               .BYTE	0	;10000
003B91  1               .BYTE	$27
003B91  1               .BYTE	$10
003B91  1               .BYTE	$FF	;-1000
003B91  1               .BYTE	$FC
003B91  1               .BYTE	$18
003B91  1               .BYTE	0	;100
003B91  1               .BYTE	0
003B91  1               .BYTE	$64
003B91  1               .BYTE	$FF	;-10
003B91  1               .BYTE	$FF
003B91  1               .BYTE	$F6
003B91  1               .BYTE	0	;1
003B91  1               .BYTE	0
003B91  1               .BYTE	1
003B91  1               .ENDIF
003B91  1               
003B91  1               .IF	ADDPRC <> 0
003B91  1  FA           FOUTBL: .BYTE $FA	;-100,000,000
003B92  1  0A           .BYTE	$A
003B93  1  1F           .BYTE	$1F
003B94  1  00           .BYTE	0
003B95  1  00           .BYTE	0	;10,000,000
003B96  1  98           .BYTE	$98
003B97  1  96           .BYTE	$96
003B98  1  80           .BYTE	$80
003B99  1  FF           .BYTE	$FF	;-1,000,000
003B9A  1  F0           .BYTE	$F0
003B9B  1  BD           .BYTE	$BD
003B9C  1  C0           .BYTE	$C0
003B9D  1  00           .BYTE	0	;100,000
003B9E  1  01           .BYTE	1
003B9F  1  86           .BYTE	$86
003BA0  1  A0           .BYTE	$A0
003BA1  1  FF           .BYTE	$FF	;-10,000
003BA2  1  FF           .BYTE	$FF
003BA3  1  D8           .BYTE	$D8
003BA4  1  F0           .BYTE	$F0
003BA5  1  00           .BYTE	0	;1000
003BA6  1  00           .BYTE	0
003BA7  1  03           .BYTE	3
003BA8  1  E8           .BYTE	$E8
003BA9  1  FF           .BYTE	$FF	;-100
003BAA  1  FF           .BYTE	$FF
003BAB  1  FF           .BYTE	$FF
003BAC  1  9C           .BYTE	$9C
003BAD  1  00           .BYTE	0	;10
003BAE  1  00           .BYTE	0
003BAF  1  00           .BYTE	0
003BB0  1  0A           .BYTE	$A
003BB1  1  FF           .BYTE	$FF	;-1
003BB2  1  FF           .BYTE	$FF
003BB3  1  FF           .BYTE	$FF
003BB4  1  FF           .BYTE	$FF
003BB5  1               .ENDIF
003BB5  1               FDCEND:
003BB5  1               .IF	TIME <> 0
003BB5  1               .BYTE	$FF	; -2160000 FOR TIME CONVERTER.
003BB5  1               .BYTE	$DF
003BB5  1               .BYTE	$A
003BB5  1               .BYTE	$80
003BB5  1               .BYTE	0	; 216000
003BB5  1               .BYTE	3
003BB5  1               .BYTE	$4B
003BB5  1               .BYTE	$C0
003BB5  1               .BYTE	$FF	; -36000
003BB5  1               .BYTE	$FF
003BB5  1               .BYTE	$73
003BB5  1               .BYTE	$60
003BB5  1               .BYTE	0	; 3600
003BB5  1               .BYTE	0
003BB5  1               .BYTE	$E
003BB5  1               .BYTE	$10
003BB5  1               .BYTE	$FF	; -600
003BB5  1               .BYTE	$FF
003BB5  1               .BYTE	$FD
003BB5  1               .BYTE	$A8
003BB5  1               .BYTE	0	; 60
003BB5  1               .BYTE	0
003BB5  1               .BYTE	0
003BB5  1               .BYTE	$3C
003BB5  1               TIMEND:
003BB5  1               .ENDIF
003BB5  1               
003BB5  1               ; PAGE
003BB5  1               ; SUBTTL	EXPONENTIATION AND SQUARE ROOT FUNCTION.
003BB5  1               	;SQUARE ROOT FUNCTION --- SQR(A)
003BB5  1               	;USE SQR(X)=X^.5
003BB5  1  20 8B 38     SQR:	JSR	MOVAF		;MOVE FAC INTO ARG.
003BB8  1  A9 8C A0 3B  	LDWDI	FHALF
003BBC  1  20 21 38     	JSR	MOVFM		;PUT MEMORY INTO FAC.
003BBF  1               				;LAST THING FETCHED IS FACEXP. INTO ACCX.
003BBF  1               ;	JMP	FPWRT		;FALL INTO FPWRT.
003BBF  1               
003BBF  1               	;EXPONENTIATION ---  X^Y.
003BBF  1               	;N.B.  0^0=1
003BBF  1               	;FIRST CHECK IF Y=0. IF SO, THE RESULT IS 1.
003BBF  1               	;NEXT CHECK IF X=0. IF SO THE RESULT IS 0.
003BBF  1               	;THEN CHECK IF X.GT.0. IF NOT CHECK THAT Y IS AN INTEGER.
003BBF  1               	;IF SO, NEGATE X, SO THAT LOG DOESN'T GIVE FCERR.
003BBF  1               	;IF X IS NEGATIVE AND Y IS ODD, NEGATE THE RESULT
003BBF  1               	;RETURNED BY EXP.
003BBF  1               	;TO COMPUTE THE RESULT USE X^Y=EXP((Y*LOG(X)).
003BBF  1  F0 70        FPWRT:	BEQ	EXP		;IF FAC=0, JUST EXPONENTIATE THAT.
003BC1  1  A5 B8        	LDA	ARGEXP		;IS X=0?
003BC3  1  D0 03        	BNE	FPWRT1
003BC5  1  4C 78 35     	JMP	ZEROF1		;ZERO FAC.
003BC8  1  A2 9D A0 00  FPWRT1: LDXYI	TEMPF3		;SAVE FOR LATER IN A TEMP.
003BCC  1  20 53 38     	JSR	MOVMF
003BCF  1               	;Y=0 ALREADY. GOOD IN CASE NO ONE CALLS INT.
003BCF  1  A5 BD        	LDA	ARGSGN
003BD1  1  10 0F        	BPL	FPWR1		;NO PROBLEMS IF X.GT.0.
003BD3  1  20 4B 39     	JSR	INT		;INTEGERIZE THE FAC.
003BD6  1  A9 9D A0 00  	LDWDI	TEMPF3		;GET ADDR OF COMPERAND.
003BDA  1  20 DA 38     	JSR	FCOMP		;EQUAL?
003BDD  1  D0 03        	BNE	FPWR1		;LEAVE X NEG. LOG WILL BLOW HIM OUT.
003BDF  1               				;A=-1 AND Y IS IRRELEVANT.
003BDF  1  98           	TYA			;NEGATE X. MAKE POSITIVE.
003BE0  1  A4 0D        	LDY	INTEGR		;GET EVENNESS.
003BE2  1  20 7D 38     FPWR1:	JSR	MOVFA1		;ALTERNATE ENTRY POINT.
003BE5  1  98           	TYA
003BE6  1  48           	PHA			;SAVE EVENNESS FOR LATER.
003BE7  1  20 69 36     	JSR	LOG		;FIND LOG.
003BEA  1  A9 9D A0 00  	LDWDI	TEMPF3		;MULTIPLY FAC TIMES LOG(X).
003BEE  1  20 A7 36     	JSR	FMULT
003BF1  1  20 31 3C     	JSR	EXP		;EXPONENTIATE THE FAC.
003BF4  1  68           	PLA
003BF5  1  4A           	LSR	A 		;IS IT EVEN?
003BF6  1  90 0A        	BCC	NEGRTS		;YES. OR X.GT.0.
003BF8  1               	;NEGATE THE NUMBER IN FAC.
003BF8  1  A5 B0        NEGOP:	LDA	FACEXP
003BFA  1  F0 06        	BEQ	NEGRTS
003BFC  1  A5 B5 49 FF  	COM	FACSGN
003C00  1  85 B5        
003C02  1  60           NEGRTS: RTS
003C03  1               
003C03  1               ; PAGE
003C03  1               ; SUBTTL	EXPONENTIATION FUNCTION.
003C03  1               	;FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY
003C03  1               	;LOG2(E). THE RESULT IS USED TO DETERMINE IF OVERFLOW
003C03  1               	;WILL OCCUR SINCE EXP(X)=2^(X*LOG2(E)) WHERE
003C03  1               	;LOG2(E)=LOG(E) BASE 2. THEN SAVE THE INTEGER PART OF
003C03  1               	;THIS TO SCALE THE ANSWER AT THE END. SINCE
003C03  1               	;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2^INT(Y) IS EASY TO COMPUTE.
003C03  1               	;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E)) BY
003C03  1               	;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
003C03  1               	;POLYNOMIAL. THE RESULT IS THEN SCALED BY THE POWER OF 2
003C03  1               	;PREVIOUSLY SAVED.
003C03  1               
003C03  1  81           LOGEB2: .BYTE $81			;LOG(E) BASE 2.
003C04  1  38           .BYTE	$38
003C05  1  AA           .BYTE	$AA
003C06  1  3B           .BYTE	$3B
003C07  1               .IF	ADDPRC <> 0
003C07  1  29           .BYTE	$29
003C08  1               .ENDIF
003C08  1               
003C08  1               .IF	ADDPRC = 0
003C08  1               EXPCON: .BYTE 6	; degree -1.
003C08  1               .BYTE	$74	; .00021702255
003C08  1               .BYTE	$63
003C08  1               .BYTE	$90
003C08  1               .BYTE	$8C
003C08  1               .BYTE	$77	; .0012439688
003C08  1               .BYTE	$23
003C08  1               .BYTE	$C
003C08  1               .BYTE	$AB
003C08  1               .BYTE	$7A	; .0096788410
003C08  1               .BYTE	$1E
003C08  1               .BYTE	$94
003C08  1               .BYTE	0
003C08  1               .BYTE	$7C	; .055483342
003C08  1               .BYTE	$63
003C08  1               .BYTE	$42
003C08  1               .BYTE	$80
003C08  1               .BYTE	$7E	; .24022984
003C08  1               .BYTE	$75
003C08  1               .BYTE	$FE
003C08  1               .BYTE	$D0
003C08  1               .BYTE	$80	; .69314698
003C08  1               .BYTE	$31
003C08  1               .BYTE	$72
003C08  1               .BYTE	$15
003C08  1               .BYTE	$81	; 1.0
003C08  1               .BYTE	0
003C08  1               .BYTE	0
003C08  1               .BYTE	0
003C08  1               .ENDIF
003C08  1               
003C08  1               
003C08  1               .IF	ADDPRC <> 0
003C08  1  07           EXPCON: .BYTE 7	;DEGREE-1
003C09  1  71           .BYTE	$71	; .000021498763697
003C0A  1  34           .BYTE	$34
003C0B  1  58           .BYTE	$58
003C0C  1  3E           .BYTE	$3E
003C0D  1  56           .BYTE	$56
003C0E  1  74           .BYTE	$74	; .00014352314036
003C0F  1  16           .BYTE	$16
003C10  1  7E           .BYTE	$7E
003C11  1  B3           .BYTE	$B3
003C12  1  1B           .BYTE	$1B
003C13  1  77           .BYTE	$77	; .0013422634824
003C14  1  2F           .BYTE	$2F
003C15  1  EE           .BYTE	$EE
003C16  1  E3           .BYTE	$E3
003C17  1  85           .BYTE	$85
003C18  1  7A           .BYTE	$7A	; .0096140170119
003C19  1  1D           .BYTE	$1D
003C1A  1  84           .BYTE	$84
003C1B  1  1C           .BYTE	$1C
003C1C  1  2A           .BYTE	$2A
003C1D  1  7C           .BYTE	$7C	; .055505126860
003C1E  1  63           .BYTE	$63
003C1F  1  59           .BYTE	$59
003C20  1  58           .BYTE	$58
003C21  1  0A           .BYTE	$A
003C22  1  7E           .BYTE	$7E	; .24022638462
003C23  1  75           .BYTE	$75
003C24  1  FD           .BYTE	$FD
003C25  1  E7           .BYTE	$E7
003C26  1  C6           .BYTE	$C6
003C27  1  80           .BYTE	$80	; .69314718608
003C28  1  31           .BYTE	$31
003C29  1  72           .BYTE	$72
003C2A  1  18           .BYTE	$18
003C2B  1  10           .BYTE	$10
003C2C  1  81           .BYTE	$81	; 1.0
003C2D  1  00           .BYTE	0
003C2E  1  00           .BYTE	0
003C2F  1  00           .BYTE	0
003C30  1  00           .BYTE	0
003C31  1               .ENDIF
003C31  1               
003C31  1               EXP:
003C31  1  A9 03 A0 3C  	LDWDI	LOGEB2		;MULTIPLY BY LOG(E) BASE 2.
003C35  1  20 A7 36     	JSR	FMULT
003C38  1  A5 BF        	LDA	FACOV
003C3A  1  69 50        	ADC	#$50
003C3C  1  90 03        	BCC	STOLD
003C3E  1  20 A2 38     	JSR	INCRND
003C41  1  85 A5        STOLD:	STA	OLDOV
003C43  1  20 8E 38     	JSR	MOVEF		;TO SAVE IN ARG WITHOUT ROUND.
003C46  1  A5 B0        	LDA	FACEXP
003C48  1  C9 88        	CMP	#$88		;IF ABS(FAC) .GE. 128, TOO BIG.
003C4A  1  90 03        	BCC	EXP1
003C4C  1  20 53 37     GOMLDV: JSR	MLDVEX		;OVERFLOW OR OVERFLOW.
003C4F  1  20 4B 39     EXP1:	JSR	INT
003C52  1  A5 0D        	LDA	INTEGR	;GET LOW PART.
003C54  1  18           	CLC
003C55  1  69 81        	ADC	#$81
003C57  1  F0 F3        	BEQ	GOMLDV		;OVERFLOW OR OVERFLOW !!
003C59  1  38           	SEC
003C5A  1  E9 01        	SBC	#1		;SUBTRACT 1.
003C5C  1  48           	PHA			;SAVE A WHILE.
003C5D  1  A2 05        	LDX	#4+ADDPRC	;PREP TO SWAP FAC AND ARG.
003C5F  1  B5 B8        SWAPLP: LDA	ARGEXP,X
003C61  1  B4 B0        	LDY	FACEXP,X
003C63  1  95 B0        	STA	FACEXP,X
003C65  1  94 B8        	STY	ARGEXP,X
003C67  1  CA           	DEX
003C68  1  10 F5        	BPL	SWAPLP
003C6A  1  A5 A5        	LDA	OLDOV
003C6C  1  85 BF        	STA	FACOV
003C6E  1  20 D2 34     	JSR	FSUBT
003C71  1  20 F8 3B     	JSR	NEGOP		;NEGATE FAC.
003C74  1  A9 08 A0 3C  	LDWDI	EXPCON
003C78  1  20 9A 3C     	JSR	POLY
003C7B  1  A9 00 85 BE  	CLR	ARISGN		;MULTIPLY BY POSITIVE 1.0.
003C7F  1  68           	PLA			;GET SCALE FACTOR.
003C80  1  20 38 37     	JSR	MLDEXP		;MODIFY FACEXP AND CHECK FOR OVERFLOW.
003C83  1  60           	RTS			;HAS TO DO JSR DUE TO PULAS IN MULDIV.
003C84  1               
003C84  1               
003C84  1               ; PAGE
003C84  1               ; SUBTTL	POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR.
003C84  1               	;EVALUATE P(X^2)*X
003C84  1               	;POINTER TO DEGREE IS IN [Y,A].
003C84  1               	;THE CONSTANTS FOLLOW THE DEGREE.
003C84  1               	;FOR X=FAC, COMPUTE:
003C84  1               	; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
003C84  1  85 C0 84 C1  POLYX:	STWD	POLYPT		;RETAIN POLYNOMIAL POINTER FOR LATER.
003C88  1  20 49 38     	JSR	MOV1F		;SAVE FAC IN FACTMP.
003C8B  1  A9 A6        	LDA	#TEMPF1
003C8D  1  20 A7 36     	JSR	FMULT		;COMPUTE X^2.
003C90  1  20 9E 3C     	JSR	POLY1		;COMPUTE P(X^2).
003C93  1  A9 A6 A0 00  	LDWDI	TEMPF1
003C97  1  4C A7 36     	JMP	FMULT		;MULTIPLY BY FAC AGAIN.
003C9A  1               
003C9A  1               	;POLYNOMIAL EVALUATOR.
003C9A  1               	;POINTER TO DEGREE IS IN [Y,A].
003C9A  1               	;COMPUTE:
003C9A  1               	; C0+C1*X+C2*X^2+C3*X^3+C4*X^4+...+C(N-1)*X^(N-1)+C(N)*X^N.
003C9A  1  85 C0 84 C1  POLY:	STWD	POLYPT
003C9E  1  20 46 38     POLY1:	JSR	MOV2F		;SAVE FAC.
003CA1  1  B1 C0        	LDADY	POLYPT
003CA3  1  85 B6        	STA	DEGREE
003CA5  1  A4 C0        	LDY	POLYPT
003CA7  1  C8           	INY
003CA8  1  98           	TYA
003CA9  1  D0 02        	BNE	POLY3
003CAB  1  E6 C1        	INC	POLYPT+1
003CAD  1  85 C0        POLY3:	STA	POLYPT
003CAF  1  A4 C1        	LDY	POLYPT+1
003CB1  1  20 A7 36     POLY2:	JSR	FMULT
003CB4  1  A5 C0 A4 C1  	LDWD	POLYPT		;GET CURRENT POINTER.
003CB8  1  18           	CLC
003CB9  1  69 05        	ADC	#4+ADDPRC
003CBB  1  90 01        	BCC	POLY4
003CBD  1  C8           	INY
003CBE  1  85 C0 84 C1  POLY4:	STWD	POLYPT
003CC2  1  20 E6 34     	JSR	FADD		;ADD IN CONSTANT.
003CC5  1  A9 AB A0 00  	LDWDI	TEMPF2		;MULTIPLY THE ORIGINAL FAC.
003CC9  1  C6 B6        	DEC	DEGREE		;DONE?
003CCB  1  D0 E4        	BNE	POLY2
003CCD  1  60           RANDRT: RTS			;YES.
003CCE  1               
003CCE  1               	;PSUEDO-RANDOM NUMBER GENERATOR.
003CCE  1               	;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED.
003CCE  1               	;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS
003CCE  1               	;STARTED USING THE ARGUMENT.
003CCE  1               	;   TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE,
003CCE  1               	;MULTIPLY THE PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT
003CCE  1               	;AND ADD IN ANOTHER RANDOM CONSTANT. THE THEN HO
003CCE  1               	;AND LO BYTES ARE SWITCHED, THE EXPONENT IS PUT WHERE
003CCE  1               	;IT WILL BE SHIFTED IN BY NORMAL, AND THE EXPONENT IN THE FAC
003CCE  1               	;IS SET TO 200 SO THE RESULT WILL BE LESS THAN 1. THIS
003CCE  1               	;IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
003CCE  1               	;THE HO AND LOW BYTES WERE SWITCHED SO THERE WILL BE A
003CCE  1               	;RANDOM CHANCE OF GETTING A NUMBER LESS THAN OR GREATER
003CCE  1               	;THAN .5 .
003CCE  1               
003CCE  1  98           RMULZC: .BYTE $98
003CCF  1  35           .BYTE	$35
003CD0  1  44           .BYTE	$44
003CD1  1  7A           .BYTE	$7A
003CD2  1  68           RADDZC: .BYTE $68
003CD3  1  28           .BYTE	$28
003CD4  1  B1           .BYTE	$B1
003CD5  1  46           .BYTE	$46
003CD6  1               
003CD6  1  20 AA 38     RND:	JSR	SIGN		;GET SIGN INTO ACCX.
003CD9  1               .IF	REALIO-3 <> 0
003CD9  1  AA           	TAX			;GET INTO ACCX, SINCE "MOVFM" USES ACCX.
003CDA  1               .ENDIF
003CDA  1  30 18        	BMI	RND1		;START NEW SEQUENCE IF NEGATIVE.
003CDC  1               .IF	REALIO-3 = 0
003CDC  1               	BNE	QSETNR
003CDC  1               		;TIMERS ARE AT 9044(L0),45(HI),48(LO),49(HI) HEX.
003CDC  1               		;FIRST TWO ARE ALWAYS FREE RUNNING.
003CDC  1               		;SECOND PAIR IS NOT. LO IS FREER THAN HI THEN.
003CDC  1               		;SO ORDER IN FAC IS 44,48,45,49.
003CDC  1               	LDA	CQHTIM
003CDC  1               	STA	FACHO
003CDC  1               	LDA	CQHTIM+4
003CDC  1               	STA	FACMOH
003CDC  1               	LDA	CQHTIM+1
003CDC  1               	STA	FACMO
003CDC  1               	LDA	CQHTIM+5
003CDC  1               	STA	FACLO
003CDC  1               	JMP	STRNEX
003CDC  1               .ENDIF
003CDC  1  A9 DA A0 00  QSETNR: LDWDI	RNDX		;GET LAST ONE INTO FAC.
003CE0  1  20 21 38     	JSR	MOVFM
003CE3  1               .IF	REALIO-3 <> 0
003CE3  1  8A           	TXA			;FAC WAS ZERO?
003CE4  1  F0 E7        	BEQ	RANDRT		;RESTORE LAST ONE.
003CE6  1               .ENDIF
003CE6  1  A9 CE A0 3C  	LDWDI	RMULZC		;MULTIPLY BY RANDOM CONSTANT.
003CEA  1  20 A7 36     	JSR	FMULT
003CED  1  A9 D2 A0 3C  	LDWDI	RADDZC
003CF1  1  20 E6 34     	JSR	FADD		;ADD RANDOM CONSTANT.
003CF4  1  A6 B4        RND1:	LDX	FACLO
003CF6  1  A5 B1        	LDA	FACHO
003CF8  1  85 B4        	STA	FACLO
003CFA  1  86 B1        	STX	FACHO		;REVERSE HO AND LO.
003CFC  1               .IF	REALIO-3 = 0
003CFC  1               	LDX	FACMOH
003CFC  1               	LDA	FACMO
003CFC  1               	STA	FACMOH
003CFC  1               	STX	FACMO
003CFC  1               .ENDIF
003CFC  1  A9 00 85 B5  STRNEX: CLR	FACSGN		;MAKE NUMBER POSITIVE.
003D00  1  A5 B0        	LDA	FACEXP		;PUT EXP WHERE IT WILL
003D02  1  85 BF        	STA	FACOV		;BE SHIFTED IN BY NORMAL.
003D04  1  A9 80        	LDA	#$80
003D06  1  85 B0        	STA	FACEXP		;MAKE RESULT BETWEEN 0 AND 1.
003D08  1  20 56 35     	JSR	NORMAL		;NORMALIZE.
003D0B  1  A2 DA A0 00  	LDXYI	RNDX
003D0F  1  4C 53 38     GMOVMF: JMP	MOVMF		;PUT NEW ONE INTO MEMORY.
003D12  1               
003D12  1               ; PAGE
003D12  1               ; SUBTTL	SINE, COSINE AND TANGENT FUNCTIONS.
003D12  1               .IF	KIMROM = 0
003D12  1               	;COSINE FUNCTION.
003D12  1               	;USE COS(X)=SIN(X+PI/2)
003D12  1  A9 8E A0 3D  COS:	LDWDI	PI2		;PNTR TO PI/2.
003D16  1  20 E6 34     	JSR	FADD		;ADD IT IN.
003D19  1               				;FALL INTO SIN.
003D19  1               
003D19  1               
003D19  1               	;SINE FUNCTION.
003D19  1               	;USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV.
003D19  1               	;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED
003D19  1               	;BECAUSE SIN(X+2*PI)=SIN(X). THEN THE ARGUMENT CAN BE COMPARED
003D19  1               	;WITH PI/2 BY COMPARING THE RESULT OF THE DIVISION
003D19  1               	;WITH PI/2/(2*PI)=1/4.
003D19  1               	;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS
003D19  1               	;I OR IV. AN APPROXIMATION POLYNOMIAL IS THEN USED TO
003D19  1               	;COMPUTE SIN(X).
003D19  1  20 8B 38     SIN:	JSR	MOVAF
003D1C  1  A9 93 A0 3D  	LDWDI	TWOPI		;GET PNTR TO DIVISOR.
003D20  1  A6 BD        	LDX	ARGSGN		;GET SIGN OF RESULT.
003D22  1  20 86 37     	JSR	FDIVF
003D25  1  20 8B 38     	JSR	MOVAF		;GET RESULT INTO ARG.
003D28  1  20 4B 39     	JSR	INT		;INTEGERIZE FAC.
003D2B  1  A9 00 85 BE  	CLR	ARISGN		;ALWAYS HAVE THE SAME SIGN.
003D2F  1  20 D2 34     	JSR	FSUBT		;KEEP ONLY THE FRACTIONAL PART.
003D32  1  A9 98 A0 3D  	LDWDI	FR4		;GET PNTR TO 1/4.
003D36  1  20 CF 34     	JSR	FSUB		;COMPUTE 1/4-FAC.
003D39  1  A5 B5        	LDA	FACSGN		;SAVE SIGN FOR LATER.
003D3B  1  48           	PHA
003D3C  1  10 0D        	BPL	SIN1		;FIRST QUADRANT.
003D3E  1  20 C8 34     	JSR	FADDH		;ADD 1/2 TO FAC.
003D41  1  A5 B5        	LDA	FACSGN		;SIGN IS NEGATIVE?
003D43  1  30 09        	BMI	SIN2
003D45  1  A5 16 49 FF  	COM	TANSGN		;QUADRANTS II AND III COME HERE.
003D49  1  85 16        
003D4B  1  20 F8 3B     SIN1:	JSR	NEGOP		;IF POSITIVE, NEGATE IT.
003D4E  1  A9 98 A0 3D  SIN2:	LDWDI	FR4		;POINTER TO 1/4.
003D52  1  20 E6 34     	JSR	FADD		;ADD IT IN.
003D55  1  68           	PLA			;GET ORIGINAL QUADRANT.
003D56  1  10 03        	BPL	SIN3
003D58  1  20 F8 3B     	JSR	NEGOP		;IF NEGATIVE, NEGATE RESULT.
003D5B  1  A9 9D A0 3D  SIN3:	LDWDI	SINCON
003D5F  1  4C 84 3C     GPOLYX: JMP	POLYX		;DO APPROXIMATION POLYNOMIAL.
003D62  1               
003D62  1               
003D62  1               	;TANGENT FUNCTION.
003D62  1  20 49 38     TAN:	JSR	MOV1F		;MOVE FAC INTO TEMPORARY.
003D65  1  A9 00 85 16  	CLR	TANSGN		;REMEMBER WHETHER TO NEGATE.
003D69  1  20 19 3D     	JSR	SIN		;COMPUTE THE SIN.
003D6C  1  A2 9D A0 00  	LDXYI	TEMPF3
003D70  1  20 0F 3D     	JSR	GMOVMF		;PUT SIGN INTO OTHER TEMP.
003D73  1  A9 A6 A0 00  	LDWDI	TEMPF1
003D77  1  20 21 38     	JSR	MOVFM		;PUT THIS MEMORY LOC INTO FAC.
003D7A  1  A9 00 85 B5  	CLR	FACSGN		;START OFF POSITIVE.
003D7E  1  A5 16        	LDA	TANSGN
003D80  1  20 8A 3D     	JSR	COSC		;COMPUTE COSINE.
003D83  1  A9 9D A0 00  	LDWDI	TEMPF3		;ADDRESS OF SINE VALUE.
003D87  1  4C 8E 37     GFDIV:	JMP	FDIV		;DIVIDE SINE BY COSINE AND RETURN.
003D8A  1  48           COSC:	PHA
003D8B  1  4C 4B 3D     	JMP	SIN1
003D8E  1               
003D8E  1  81           PI2:	.BYTE $81	;PI/2
003D8F  1  49           .BYTE	$49
003D90  1  0F           .BYTE	$F
003D91  1  DA           .BYTE	$DB-ADDPRC
003D92  1               .IF	ADDPRC <> 0
003D92  1  A2           .BYTE	$A2
003D93  1               .ENDIF
003D93  1  83           TWOPI:	.BYTE $83	;2*PI.
003D94  1  49           .BYTE	$49
003D95  1  0F           .BYTE	$F
003D96  1  DA           .BYTE	$DB-ADDPRC
003D97  1               .IF	ADDPRC <> 0
003D97  1  A2           .BYTE	$A2
003D98  1               .ENDIF
003D98  1  7F           FR4:	.BYTE $7F	;1/4
003D99  1  00           .BYTE	0
003D9A  1  00           .BYTE	0
003D9B  1  00           .BYTE	0
003D9C  1               .IF	ADDPRC <> 0
003D9C  1  00           .BYTE	0
003D9D  1               .ENDIF
003D9D  1               .IF	ADDPRC = 0
003D9D  1               SINCON:	.BYTE 4	;DEGREE-1.
003D9D  1               .BYTE	$86	;39.710899
003D9D  1               .BYTE	$1E
003D9D  1               .BYTE	$D7
003D9D  1               .BYTE	$FB
003D9D  1               .BYTE	$87	;-76.574956
003D9D  1               .BYTE	$99
003D9D  1               .BYTE	$26
003D9D  1               .BYTE	$65
003D9D  1               .BYTE	$87	;81.602231
003D9D  1               .BYTE	$23
003D9D  1               .BYTE	$34
003D9D  1               .BYTE	$58
003D9D  1               .BYTE	$86	;-41.341677
003D9D  1               .BYTE	$A5
003D9D  1               .BYTE	$5D
003D9D  1               .BYTE	$E1
003D9D  1               .BYTE	$83	;6.2831853
003D9D  1               .BYTE	$49
003D9D  1               .BYTE	$F
003D9D  1               .BYTE	$DB
003D9D  1               .ENDIF
003D9D  1               
003D9D  1               .IF	ADDPRC <> 0
003D9D  1  05           SINCON: .BYTE 5		;DEGREE-1.
003D9E  1  84           .BYTE	$84	; -14.381383816
003D9F  1  E6           .BYTE	$E6
003DA0  1  1A           .BYTE	$1A
003DA1  1  2D           .BYTE	$2D
003DA2  1  1B           .BYTE	$1B
003DA3  1  86           .BYTE	$86	; 42.07777095
003DA4  1  28           .BYTE	$28
003DA5  1  07           .BYTE	7
003DA6  1  FB           .BYTE	$FB
003DA7  1  F8           .BYTE	$F8
003DA8  1  87           .BYTE	$87	; -76.704133676
003DA9  1  99           .BYTE	$99
003DAA  1  68           .BYTE	$68
003DAB  1  89           .BYTE	$89
003DAC  1  01           .BYTE	1
003DAD  1  87           .BYTE	$87	; 81.605223690
003DAE  1  23           .BYTE	$23
003DAF  1  35           .BYTE	$35
003DB0  1  DF           .BYTE	$DF
003DB1  1  E1           .BYTE	$E1
003DB2  1  86           .BYTE	$86	; -41.34170209
003DB3  1  A5           .BYTE	$A5
003DB4  1  5D           .BYTE	$5D
003DB5  1  E7           .BYTE	$E7
003DB6  1  28           .BYTE	$28
003DB7  1  83           .BYTE	$83	; 6.2831853070
003DB8  1  49           .BYTE	$49
003DB9  1  0F           .BYTE	$F
003DBA  1  DA           .BYTE	$DA
003DBB  1  A2           .BYTE	$A2
003DBC  1  A1           .BYTE	$A1	; 7.2362932E7
003DBD  1  54           .BYTE	$54
003DBE  1  46           .BYTE	$46
003DBF  1  8F           .BYTE	$8F
003DC0  1  13           .BYTE	$13
003DC1  1  8F           .BYTE	$8F	; 73276.2515
003DC2  1  52           .BYTE	$52
003DC3  1  43           .BYTE	$43
003DC4  1  89           .BYTE	$89
003DC5  1  CD           .BYTE	$CD
003DC6  1               .ENDIF
003DC6  1               ; PAGE
003DC6  1               ; SUBTTL	ARCTANGENT FUNCTION.
003DC6  1               	;USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
003DC6  1               	;APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X).
003DC6  1  A5 B5        ATN:	LDA	FACSGN		;WHAT IS SIGN?
003DC8  1  48           	PHA			;(MEANWHILE SAVE FOR LATER.)
003DC9  1  10 03        	BPL	ATN1
003DCB  1  20 F8 3B     	JSR	NEGOP		;IF NEGATIVE, NEGATE FAC.
003DCE  1               				;USE ARCTAN(X)=-ARCTAN(-X) .
003DCE  1  A5 B0        ATN1:	LDA	FACEXP
003DD0  1  48           	PHA			;SAVE THIS TOO FOR LATER.
003DD1  1  C9 81        	CMP	#$81		;SEE IF FAC .GE. 1.0 .
003DD3  1  90 07        	BCC	ATN2		;IT IS LESS THAN 1.
003DD5  1  A9 3B A0 36  	LDWDI	FONE		;GET PNTR TO 1.0 .
003DD9  1  20 8E 37     	JSR	FDIV		;COMPUTE RECIPROCAL.
003DDC  1               				;USE ARCTAN(X)=PI/2-ARCTAN(1/X) .
003DDC  1  A9 F6 A0 3D  ATN2:	LDWDI	ATNCON		;PNTR TO ARCTAN CONSTANTS.
003DE0  1  20 84 3C     	JSR	POLYX
003DE3  1  68           	PLA
003DE4  1  C9 81        	CMP	#$81		;WAS ORIGINAL ARGUMENT .LT. 1 ?
003DE6  1  90 07        	BCC	ATN3		;YES.
003DE8  1  A9 8E A0 3D  	LDWDI	PI2
003DEC  1  20 CF 34     	JSR	FSUB		;SUBTRACT ARCTAGN FROM PI/2.
003DEF  1  68           ATN3:	PLA			;WAS ORIGINAL ARGUMENT POSITIVE?
003DF0  1  10 03        	BPL	ATN4		;YES.
003DF2  1  4C F8 3B     	JMP	NEGOP		;IF NEGATIVE, NEGATE RESULT.
003DF5  1  60           ATN4:	RTS			;ALL DONE.
003DF6  1               
003DF6  1               .IF	ADDPRC = 0
003DF6  1               ATNCON:	 .BYTE $8	;DEGREE-1.
003DF6  1               .BYTE	$78	;.0028498896
003DF6  1               .BYTE	$3A
003DF6  1               .BYTE	$C5
003DF6  1               .BYTE	$37
003DF6  1               .BYTE	$7B	;-.016068629
003DF6  1               .BYTE	$83
003DF6  1               .BYTE	$A2
003DF6  1               .BYTE	$5C
003DF6  1               .BYTE	$7C	;.042691519
003DF6  1               .BYTE	$2E
003DF6  1               .BYTE	$DD
003DF6  1               .BYTE	$4D
003DF6  1               .BYTE	$7D	;-.075042945
003DF6  1               .BYTE	$99
003DF6  1               .BYTE	$B0
003DF6  1               .BYTE	$1E
003DF6  1               .BYTE	$7D	;.10640934
003DF6  1               .BYTE	$59
003DF6  1               .BYTE	$ED
003DF6  1               .BYTE	$24
003DF6  1               .BYTE	$7E	;-.14203644
003DF6  1               .BYTE	$91
003DF6  1               .BYTE	$72
003DF6  1               .BYTE	0
003DF6  1               .BYTE	$7E	;.19992619
003DF6  1               .BYTE	$4C
003DF6  1               .BYTE	$B9
003DF6  1               .BYTE	$73
003DF6  1               .BYTE	$7F	;.-33333073
003DF6  1               .BYTE	$AA
003DF6  1               .BYTE	$AA
003DF6  1               .BYTE	$53
003DF6  1               .BYTE	$81	;1.0
003DF6  1               .BYTE	0
003DF6  1               .BYTE	0
003DF6  1               .BYTE	0
003DF6  1               .ENDIF
003DF6  1               
003DF6  1               .IF	ADDPRC <> 0
003DF6  1  0B           ATNCON: .BYTE $B	;DEGREE-1.
003DF7  1  76           .BYTE	$76	; -.0006847939119
003DF8  1  B3           .BYTE	$B3
003DF9  1  83           .BYTE	$83
003DFA  1  BD           .BYTE	$BD
003DFB  1  D3           .BYTE	$D3
003DFC  1  79           .BYTE	$79	; .004850942156
003DFD  1  1E           .BYTE	$1E
003DFE  1  F4           .BYTE	$F4
003DFF  1  A6           .BYTE	$A6
003E00  1  F5           .BYTE	$F5
003E01  1  7B           .BYTE	$7B	; -.01611170184
003E02  1  83           .BYTE	$83
003E03  1  FC           .BYTE	$FC
003E04  1  B0           .BYTE	$B0
003E05  1  10           .BYTE	$10
003E06  1  7C           .BYTE	$7C	; .03420963805
003E07  1  0C           .BYTE	$C
003E08  1  1F           .BYTE	$1F
003E09  1  67           .BYTE	$67
003E0A  1  CA           .BYTE	$CA
003E0B  1  7C           .BYTE	$7C	; -.05427913276
003E0C  1  DE           .BYTE	$DE
003E0D  1  53           .BYTE	$53
003E0E  1  CB           .BYTE	$CB
003E0F  1  C1           .BYTE	$C1
003E10  1  7D           .BYTE	$7D	; .07245719654
003E11  1  14           .BYTE	$14
003E12  1  64           .BYTE	$64
003E13  1  70           .BYTE	$70
003E14  1  4C           .BYTE	$4C
003E15  1  7D           .BYTE	$7D	; -.08980239538
003E16  1  B7           .BYTE	$B7
003E17  1  EA           .BYTE	$EA
003E18  1  51           .BYTE	$51
003E19  1  7A           .BYTE	$7A
003E1A  1  7D           .BYTE	$7D	; .1109324134
003E1B  1  63           .BYTE	$63
003E1C  1  30           .BYTE	$30
003E1D  1  88           .BYTE	$88
003E1E  1  7E           .BYTE	$7E
003E1F  1  7E           .BYTE	$7E	; -.1428398077
003E20  1  92           .BYTE	$92
003E21  1  44           .BYTE	$44
003E22  1  99           .BYTE	$99
003E23  1  3A           .BYTE	$3A
003E24  1  7E           .BYTE	$7E	; .1999991205
003E25  1  4C           .BYTE	$4C
003E26  1  CC           .BYTE	$CC
003E27  1  91           .BYTE	$91
003E28  1  C7           .BYTE	$C7
003E29  1  7F           .BYTE	$7F	; -.3333333157
003E2A  1  AA           .BYTE	$AA
003E2B  1  AA           .BYTE	$AA
003E2C  1  AA           .BYTE	$AA
003E2D  1  13           .BYTE	$13
003E2E  1  81           .BYTE	$81	; 1.0
003E2F  1  00           .BYTE	0
003E30  1  00           .BYTE	0
003E31  1  00           .BYTE	0
003E32  1  00           .BYTE	0
003E33  1               .ENDIF
003E33  1               .ENDIF
003E33  1               ; PAGE
003E33  1               ; SUBTTL	SYSTEM INITIALIZATION CODE.
003E33  1               ; RADIX	10		;IN ALL NON-MATH-PACKAGE CODE.
003E33  1               ; THIS INITIALIZES THE BASIC INTERPRETER FOR THE M6502 AND SHOULD BE
003E33  1               ; LOCATED WHERE IT WILL BE WIPED OUT IN RAM IF CODE IS ALL IN RAM.
003E33  1               
003E33  1               .IF	ROMSW = 0
003E33  1               	BLOCK	1		;SO ZEROING AT TXTTAB DOESN'T PREVENT
003E33  1               .ENDIF
003E33  1               				;RESTARTING INIT
003E33  1  E6 C9        INITAT: INC	CHRGET+7	;INCREMENT THE WHOLE TXTPTR.
003E35  1  D0 02        	BNE	CHZGOT
003E37  1  E6 CA        	INC	CHRGET+8
003E39  1  AD 60 EA     CHZGOT: LDA	60000		;A LOAD WITH AN EXT ADDR.
003E3C  1  C9 3A        	CMP	#':'		;IS IT A ":"?
003E3E  1  B0 0A        	BCS	CHZRTS		;IT IS .GE. ":"
003E40  1  C9 20        	CMP	#' '		;SKIP SPACES.
003E42  1  F0 EF        	BEQ	INITAT
003E44  1  38           	SEC
003E45  1  E9 30        	SBC	#'0'		;ALL CHARS .GT. "9" HAVE RET'D SO
003E47  1  38           	SEC
003E48  1  E9 D0        	SBC	#256-'0'		;SEE IF NUMERIC.
003E4A  1               				;TURN CARRY ON IF NUMERIC.
003E4A  1               				;ALSO, SETZ IF NULL.
003E4A  1  60           CHZRTS: RTS			;RETURN TO CALLER.
003E4B  1               
003E4B  1  80           .BYTE	128			;LOADED OR FROM ROM.
003E4C  1  4F           .BYTE	79			;THE INITIAL RANDOM NUMBER.
003E4D  1  C7           .BYTE	199
003E4E  1  52           .BYTE	82
003E4F  1               .IF	ADDPRC <> 0
003E4F  1  58           .BYTE	88
003E50  1               .ENDIF
003E50  1               .IF	REALIO-3 <> 0
003E50  1               .IF	KIMROM = 0
003E50  1  A9 7B A0 3F  TYPAUT: LDWDI	AUTTXT
003E54  1  20 9B 28     	JSR	STROUT
003E57  1               .ENDIF
003E57  1               .ENDIF
003E57  1               INIT:
003E57  1               .IF	REALIO-3 <> 0
003E57  1  A2 FF        	LDX	#255		;MAKE IT LOOK DIRECT IN CASE OF
003E59  1  86 89        	STX	CURLIN+1	;ERROR MESSAGE.
003E5B  1               .ENDIF
003E5B  1               .IF	STKEND-511 <> 0
003E5B  1               	LDX	#STKEND-256
003E5B  1               .ENDIF
003E5B  1  9A           	TXS
003E5C  1               .IF	REALIO-3 <> 0
003E5C  1  A9 57 A0 3E  	LDWDI	INIT		;ALLOW RESTART.
003E60  1  85 01 84 02  	STWD	START+1
003E64  1  85 04 84 05  	STWD	RDYJSR+1	;RTS HERE ON ERRORS.
003E68  1  A9 3D A0 2E  	LDWDI	AYINT
003E6C  1  85 06 84 07  	STWD	ADRAYI
003E70  1  A9 10 A0 30  	LDWDI	GIVAYF
003E74  1  85 08 84 09  	STWD	ADRGAY
003E78  1               .ENDIF
003E78  1  A9 4C        	LDA	#76		;JMP INSTRUCTION.
003E7A  1               .IF	REALIO = 0
003E7A  1               	;HRLI 1,^O1000		;MAKE AN INST.	;LGB What was its role?!
003E7A  1               .ENDIF
003E7A  1               .IF	REALIO-3 <> 0
003E7A  1  85 00        	STA	START
003E7C  1  85 03        	STA	RDYJSR
003E7E  1               .ENDIF
003E7E  1  85 A3        	STA	JMPER
003E80  1               .IF	ROMSW <> 0
003E80  1  85 0A        	STA	USRPOK
003E82  1  A9 C6 A0 2E  	LDWDI	FCERR
003E86  1  85 0B 84 0C  	STWD	USRPOK+1
003E8A  1               .ENDIF
003E8A  1  A9 48        	LDA	#LINLEN		;THESE MUST BE NON-ZERO SO CHEAD WILL
003E8C  1  85 19        	STA	LINWID		;WORK AFTER MOVING A NEW LINE IN BUF
003E8E  1               				;INTO THE PROGRAM
003E8E  1  A9 38        	LDA	#NCMPOS
003E90  1  85 1A        	STA	NCMWID
003E92  1  A2 1C        	LDX	#RNDX+4-CHRGET
003E94  1  BD 32 3E     MOVCHG: LDA	INITAT-1,X
003E97  1  95 C1        	STA	CHRGET-1,X 	;MOVE TO RAM.
003E99  1  CA           	DEX
003E9A  1  D0 F8        	BNE	MOVCHG
003E9C  1  A9 03        	LDA	#STRSIZ
003E9E  1  85 A2        	STA	FOUR6
003EA0  1  8A           	TXA			;SET CONST IN RAM.
003EA1  1  85 B7        	STA	BITS
003EA3  1               .IF	EXTIO <> 0
003EA3  1               	STA	CHANNL
003EA3  1               .ENDIF
003EA3  1  85 67        	STA	LASTPT+1
003EA5  1               .IF	NULCMD <> 0
003EA5  1  85 17        	STA	NULCNT
003EA7  1               .ENDIF
003EA7  1  48           	PHA			;PUT ZERO AT THE END OF THE STACK
003EA8  1               				;SO FNDFOR WILL STOP
003EA8  1               .IF	REALIO <> 0
003EA8  1               	STA	CNTWFL		;BE TALKATIVE.
003EA8  1               .ENDIF
003EA8  1               .IF	BUFPAG <> 0
003EA8  1               	INX			;MAKE [X]=1
003EA8  1               	STX	BUF-3		;SET PRE-BUF BYTES NON-ZERO FOR CHEAD
003EA8  1               	STX	BUF-4
003EA8  1               .ENDIF
003EA8  1               .IF	REALIO-3 <> 0
003EA8  1  20 45 28     	JSR	CRDO		;TYPE A CR.
003EAB  1               .ENDIF
003EAB  1  A2 68        	LDX	#TEMPST
003EAD  1  86 65        	STX	TEMPPT		;SET UP STRING TEMPORARIES.
003EAF  1               .IF	(REALIO|LONGI) <> 0
003EAF  1               .IF	REALIO-3 <> 0
003EAF  1  A9 9B A0 3F  	LDWDI	MEMORY
003EB3  1  20 9B 28     	JSR	STROUT
003EB6  1  20 29 29     	JSR	QINLIN		;GET A LINE OF INPUT.
003EB9  1  86 C9 84 CA  	STXY	TXTPTR		;READ THIS !
003EBD  1  20 C2 00     	JSR	CHRGET		;GET THE FIRST CHARACTER.
003EC0  1               .IF	KIMROM = 0
003EC0  1  C9 41        	CMP	#'A'		;IS IT AN "A"?
003EC2  1  F0 8C        	BEQ	TYPAUT		;YES TYPE AUTHOR'S NAME.
003EC4  1               .ENDIF
003EC4  1  A8           	TAY			;NULL INPUT?
003EC5  1  D0 25        	BNE	USEDE9		;NO.
003EC7  1               .ENDIF
003EC7  1               .IF	REALIO-3 = 0
003EC7  1               	LDY	#RAMLOC/256
003EC7  1               .ENDIF
003EC7  1               .IF	REALIO-3 <> 0
003EC7  1               .IF	ROMSW = 0
003EC7  1               	LDWDI	LASTWR		;YES GET PNTR TO LAST WORD.
003EC7  1               .ENDIF
003EC7  1               .IF	ROMSW <> 0
003EC7  1  A9 00 A0 03  	LDWDI	RAMLOC
003ECB  1               .ENDIF
003ECB  1               .ENDIF
003ECB  1               .IF	ROMSW <> 0
003ECB  1  85 7A 84 7B  	STWD	TXTTAB		;SET UP START OF PROGRAM LOCATION
003ECF  1               .ENDIF
003ECF  1  85 1B 84 1C  	STWD	LINNUM
003ED3  1               .IF	REALIO-3 = 0
003ED3  1               	TAY
003ED3  1               .ENDIF
003ED3  1               .IF	REALIO-3 <> 0
003ED3  1  A0 00        	LDY	#0
003ED5  1               .ENDIF
003ED5  1  E6 1B        LOOPMM: INC	LINNUM
003ED7  1  D0 02        	BNE	LOOPM1
003ED9  1  E6 1C        	INC	LINNUM+1
003EDB  1               .IF	REALIO-3 = 0
003EDB  1               	BMI	USEDEC
003EDB  1               .ENDIF
003EDB  1  A9 55        LOOPM1: LDA	#85		;PUT RANDOM INFO INTO MEM.
003EDD  1  91 1B        	STADY	LINNUM
003EDF  1  D1 1B        	CMPDY	LINNUM		;WAS IT SAVED?
003EE1  1  D0 15        	BNE	USEDEC		;NO. THAT IS END OF MEMORY.
003EE3  1  0A           	ASL	A 		;LOOKS LIKE IT. TRY ANOTHER.
003EE4  1  91 1B        	STADY	LINNUM
003EE6  1  D1 1B        	CMPDY	LINNUM		;WAS IT SAVED?
003EE8  1               .IF	REALIO-3 <> 0
003EE8  1  D0 0E        	BNE	USEDEC		;NO. THIS IS THE END.
003EEA  1               .ENDIF
003EEA  1               .IF	REALIO-2 <> 0
003EEA  1  F0 E9        	BEQ	LOOPMM
003EEC  1               .ENDIF
003EEC  1               .IF	REALIO-2 = 0
003EEC  1               	BNE	USEDEC
003EEC  1               	CMP	0		;SEE IF HITTING PAGE 0
003EEC  1               	BNE	LOOPMM
003EEC  1               	LDA	#76
003EEC  1               	STA	0
003EEC  1               	BNEA	USEDEC
003EEC  1               .ENDIF
003EEC  1               .IF	REALIO-3 <> 0
003EEC  1  20 C8 00     USEDE9: JSR	CHRGOT		;GET CURRENT CHARACTER.
003EEF  1  20 3E 27     	JSR	LINGET		;GET DECIMAL ARGUMENT.
003EF2  1  A8           	TAY			;MAKE SURE A TERMINATOR EXISTS.
003EF3  1  F0 03        	BEQ	USEDEC		;IT DOES.
003EF5  1  4C 0F 2C     	JMP	SNERR		;IT DOESN'T.
003EF8  1               .ENDIF
003EF8  1  A5 1B A4 1C  USEDEC: LDWD	LINNUM		;GET SIZE OF MEMORY INPUT.
003EFC  1               USEDEF:				;HIGHEST ADDRESS.
003EFC  1               .ENDIF
003EFC  1               .IF	(REALIO|LONGI) = 0
003EFC  1               	LDWDI	16190		;A STRANGE NUMBER.
003EFC  1               .ENDIF
003EFC  1  85 86 84 87  	STWD	MEMSIZ		;THIS IS THE SIZE OF MEMORY.
003F00  1  85 82 84 83  	STWD	FRETOP		;TOP OF STRINGS TOO.
003F04  1               TTYW:
003F04  1               .IF	REALIO-3 <> 0
003F04  1               .IF	(REALIO|LONGI) <> 0
003F04  1  A9 A7 A0 3F  	LDWDI	TTYWID
003F08  1  20 9B 28     	JSR	STROUT
003F0B  1  20 29 29     	JSR	QINLIN		;GET LINE OF INPUT.
003F0E  1  86 C9 84 CA  	STXY	TXTPTR		;READ THIS !
003F12  1  20 C2 00     	JSR	CHRGET		;GET FIRST CHARACTER.
003F15  1  A8           	TAY			;TEST ACCA BUT DON'T AFFECT CARRY.
003F16  1  F0 1C        	BEQ	ASKAGN
003F18  1  20 3E 27     	JSR	LINGET		;GET ARGUMENT.
003F1B  1  A5 1C        	LDA	LINNUM+1
003F1D  1  D0 E5        	BNE	TTYW		;WIDTH MUST BE .LT. 256.
003F1F  1  A5 1B        	LDA	LINNUM
003F21  1  C9 10        	CMP	#16		;WIDTH MUST BE GREATER THAN 16.
003F23  1  90 DF        	BCC	TTYW
003F25  1  85 19        	STA	LINWID		;THAT IS THE LINE WIDTH.
003F27  1  E9 0E        MORCPS: SBC	#CLMWID		;COMPUTE POSITION BEYOND WHICH
003F29  1  B0 FC        	BCS	MORCPS		;THERE ARE NO MORE FIELDS.
003F2B  1  49 FF        	EOR	#255
003F2D  1  E9 0C        	SBC	#CLMWID-2
003F2F  1  18           	CLC
003F30  1  65 19        	ADC	LINWID
003F32  1  85 1A        	STA	NCMWID
003F34  1               .ENDIF
003F34  1               ASKAGN:
003F34  1               .IF	ROMSW = 0
003F34  1               .IF	(REALIO|LONGI) <> 0
003F34  1               	LDWDI	FNS
003F34  1               	JSR	STROUT
003F34  1               	JSR	QINLIN
003F34  1               	STXY	TXTPTR		;READ THIS !
003F34  1               	JSR	CHRGET
003F34  1               	LDXYI	INITAT		;DEFAULT.
003F34  1               	CMP	#'Y'
003F34  1               	BEQ	HAVFNS		;SAVE ALL FUNCTIONS.
003F34  1               	CMP	#'A'
003F34  1               	BEQ	OKCHAR		;SAVE ALL BUT ATN.
003F34  1               	CMP	#'N'
003F34  1               	BNE	ASKAGN		;BAD INPUT.
003F34  1               				;SAVE NOTHING.
003F34  1               OKCHAR: LDXYI	FCERR
003F34  1               	STXY	ATNFIX		;GET RID OF ATN FUNCTION.
003F34  1               	LDXYI	ATN		;UNTIL WE KNOW THAT WE SHOULD DEL MORE.
003F34  1               	CMP	#'A'
003F34  1               	BEQ	HAVFNS		;JUST GET RID OF ATN.
003F34  1               	LDXYI	FCERR
003F34  1               	STXY	COSFIX		;GET RID OF THE REST.
003F34  1               	STXY	TANFIX
003F34  1               	STXY	SINFIX
003F34  1               	LDXYI	COS		;AND GET RID OF ALL BACK TO "COS".
003F34  1               HAVFNS:
003F34  1               .ENDIF
003F34  1               .IF	(REALIO|LONGI) = 0
003F34  1               	LDXYI	INITAT-1	;GET RID OF ALL UP TO "INITAT".
003F34  1               .ENDIF
003F34  1               .ENDIF
003F34  1               .ENDIF
003F34  1               .IF	ROMSW <> 0
003F34  1  A2 00 A0 03  	LDXYI	RAMLOC
003F38  1  86 7A 84 7B  	STXY	TXTTAB
003F3C  1               .ENDIF
003F3C  1  A0 00        	LDY	#0
003F3E  1  98           	TYA
003F3F  1  91 7A        	STADY	TXTTAB		;SET UP TEXT TABLE.
003F41  1  E6 7A        	INC	TXTTAB
003F43  1               .IF	REALIO-3 <> 0
003F43  1  D0 02        	BNE	QROOM
003F45  1  E6 7B        	INC	TXTTAB+1
003F47  1               .ENDIF
003F47  1  A5 7A A4 7B  QROOM:	LDWD	TXTTAB		;PREPARE TO USE "REASON".
003F4B  1  20 1F 22     	JSR	REASON
003F4E  1               .IF	REALIO-3 = 0
003F4E  1               	LDWDI	FREMES
003F4E  1               	JSR	STROUT
003F4E  1               .ENDIF
003F4E  1               .IF	REALIO-3 <> 0
003F4E  1  20 45 28     	JSR	CRDO
003F51  1               .ENDIF
003F51  1  A5 86        	LDA	MEMSIZ		;COMPUTE [MEMSIZ]-[VARTAB].
003F53  1  38           	SEC
003F54  1  E5 7A        	SBC	TXTTAB
003F56  1  AA           	TAX
003F57  1  A5 87        	LDA	MEMSIZ+1
003F59  1  E5 7B        	SBC	TXTTAB+1
003F5B  1  20 4C 3A     	JSR	LINPRT		;TYPE THIS VALUE.
003F5E  1  A9 B6 A0 3F  	LDWDI	WORDS		;MORE BULLSHIT.
003F62  1  20 9B 28     	JSR	STROUT
003F65  1  20 3C 24     	JSR	SCRTCH		;SET UP EVERYTHING ELSE.
003F68  1               .IF	REALIO-3 = 0
003F68  1               	JMP	READY
003F68  1               .ENDIF
003F68  1               .IF	REALIO-3 <> 0
003F68  1  A9 9B A0 28  	LDWDI	STROUT
003F6C  1  85 04 84 05  	STWD	RDYJSR+1
003F70  1  A9 72 A0 22  	LDWDI	READY
003F74  1  85 01 84 02  	STWD	START+1
003F78  1  6C 01 00     	JMPD	START+1
003F7B  1               
003F7B  1               .IF	ROMSW = 0
003F7B  1               FNS:	DT"WANT SIN-COS-TAN-ATN"
003F7B  1               .BYTE	0
003F7B  1               .ENDIF
003F7B  1               .IF	KIMROM = 0
003F7B  1  0D 0A        AUTTXT: ACRLF
003F7D  1  0C           .BYTE	12			;ANOTHER LINE FEED.
003F7E  1  57 52 49 54  	DT"WRITTEN "
003F82  1  54 45 4E 20  
003F86  1  42 59 20 57  	DT"BY WEILAND & GATES"
003F8A  1  45 49 4C 41  
003F8E  1  4E 44 20 26  
003F98  1  0D 0A        	ACRLF
003F9A  1  00           .BYTE	0
003F9B  1               .ENDIF
003F9B  1  4D 45 4D 4F  MEMORY: DT"MEMORY SIZE"
003F9F  1  52 59 20 53  
003FA3  1  49 5A 45     
003FA6  1  00           .BYTE	0
003FA7  1               TTYWID:
003FA7  1               .IF	KIMROM = 0
003FA7  1  54 45 52 4D  	DT"TERMINAL "
003FAB  1  49 4E 41 4C  
003FAF  1  20           
003FB0  1               .ENDIF
003FB0  1  57 49 44 54  	DT"WIDTH"
003FB4  1  48           
003FB5  1  00           .BYTE	0
003FB6  1               .ENDIF
003FB6  1  20 42 59 54  WORDS:	DT" BYTES FREE"
003FBA  1  45 53 20 46  
003FBE  1  52 45 45     
003FC1  1               .IF	REALIO-3 <> 0
003FC1  1  0D 0A        	ACRLF
003FC3  1  0D 0A        	ACRLF
003FC5  1               .ENDIF
003FC5  1               .IF	REALIO-3 = 0
003FC5  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FC5  1               .BYTE	0
003FC5  1               FREMES:
003FC5  1               .ENDIF
003FC5  1               .IF	REALIO = 0
003FC5  1  53 49 4D 55  	DT"SIMULATED BASIC FOR THE 6502 V1.1"
003FC9  1  4C 41 54 45  
003FCD  1  44 20 42 41  
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-1 = 0
003FE6  1               	DT"KIM BASIC V1.1"
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-2 = 0
003FE6  1               	DT"OSI 6502 BASIC VERSION 1.1"
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-3 = 0
003FE6  1               	DT"### COMMODORE BASIC ###"
003FE6  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FE6  1               	EXPOP	$D		;LGB: EXP->EXPOP not to collide with the EXP: label
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-4 = 0
003FE6  1               	DT"APPLE BASIC V1.1"
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-5 = 0
003FE6  1               	DT"STM BASIC V1.1"
003FE6  1               .ENDIF
003FE6  1               .IF	REALIO-3 <> 0
003FE6  1  0D 0A        	ACRLF
003FE8  1  43 4F 50 59  	DT"COPYRIGHT 1978 MICROSOFT"
003FEC  1  52 49 47 48  
003FF0  1  54 20 31 39  
004000  1  0D 0A        	ACRLF
004002  1               .ENDIF
004002  1  00           .BYTE	0
004003  1               LASTWR:
004003  1  xx xx xx xx  	BLOCK	100		;SPACE FOR TEMP STACK.
004007  1  xx xx xx xx  
00400B  1  xx xx xx xx  
004067  1               .IF	REALIO = 0
004067  1  xx xx xx xx  TSTACK:	BLOCK	13600
00406B  1  xx xx xx xx  
00406F  1  xx xx xx xx  
007587  1               .ENDIF
007587  1               
007587  1               ;IF2,<
007587  1               ;	PURGE	A,X,Y
007587  1               ;>
007587  1               ;IFNDEF	START,<START==0>
007587  1               ;	END	$Z+START
007587  1               
007587  1               
007587  1               .OUT .SPRINTF("LGB: ROMLOC=$%04X", ROMLOC)
007587  1               .OUT .SPRINTF("LGB: INIT  =$%04X", INIT)
007587  1               
007587  1               
007587  1               ; --- CONV ERRORS ---
007587  1               ; 8
007587  1               ; 8
007587  1               ; 8
007587  1               
